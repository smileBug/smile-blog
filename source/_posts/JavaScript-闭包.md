---
title: JavaScript 闭包
date: 2016-07-26 17:35:35
categories:
    JS
tags:
	- 闭包
---
要想学好JavaScript有一道坎是无论如何都要迈过的，那就是闭包。它是JS中一个非常重要但又难以掌握的概念。
### 闭包的定义
让我们开门见山，什么是闭包？
<!-- more -->
“闭包是指有权访问另一个函数作用域中的变量的函数。”这是《JavaScript高级程序设计》给出的定义。这句话很简单，但不好理解。让我们直接看例子：
```javascript
function foo(){
    var a = 2;
    function bar(){
        console.log(a);
    }
    bar();
}
foo();  //2
```
首先，这是闭包吗？是，它是一个闭包。但它不能展示出闭包的特性。bar()对a的引用是基于词法作用域的查找规则，内部函数能访问外部作用域的变量。而下面这个例子就能很好地展示了闭包：
<!-- more -->
```javascript
function foo(){
    var a = 2;
    function bar(){
        console.log(a);
    }
    return bar;
}
var baz = foo();
baz();  //2
```
让我们先抛开闭包来看这段代码。首先，函数bar()能访问foo()的内部作用域中的变量a，没问题，这是基于词法作用域自里向外的查找规则。

在foo()执行后，其返回值(也就是内部的bar()函数)赋值给了变量baz并调用了baz(),实际上只是通过不同的标识符(也就是这里的bar和baz)引用调用了内部的函数bar()。但是这是它自己定义的词法作用域以外的地方执行，讲道理它应该无权访问到变量a的值啊，为什么最后还是输出结果2了呢？所以这就是闭包神奇的地方！

我们都知道JS的垃圾回收机制会释放不再使用的内存空间。看上去foo()的内容不再被使用，所以自然会考虑将其回收。而闭包“神奇”的地方就在于可以阻止这件事的发生。由于bar()声明在foo()内部，它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在之后任何时刻引用。这个引用就是闭包！

所以，无论通过何种手段将内部函数传递到所在词法作用域以外，他都会持有对原始作用域的引用，无论在何处执行这个函数都会使用闭包。
### 闭包与循环
在循环中使用闭包会有一个坑。例如：
```javascript
for(var i = 1; i <= 5; i++){
    setTimeout(function timer(){
        console.log(i);     //6,6,6,6,6
    },i*1000);
}
```
按照正常的思维，我们会觉得这段代码运行结果是每秒一个地输出1~5，但实际上，这段代码在运行时会 以每秒一次的频率输出五次6。这就很奇怪了，为什么它会和我们所想的结果不一样呢？
原来尽管循环中的五个函数在每次循环中分别定义的，但它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i，也就是循环满足终止条件时i的值6。
所以也就是说闭包只能取得包含函数中任何变量的最后一个值。

那如何改造代码，让它向我们所期望的结果运行呢？看代码：
```javascript
for(var i = 1; i <= 5; i++){
    (function(j){
        setTimeout(function timer(){
            console.log(j);     //1,2,3,4,5
        },j*1000);
    })(i);
}
```
这里我们通过声明并立即执行一个匿名函数来创建作用域。在调用每个匿名函数时，传入了变量i，由于函数参数是按值传递的，所以就会把变量i的当前值赋值给了j，从而产生了新的作用域，j的值是不会被循环改变的。这样一来每个函数都能获取到所对应的i的值。

上述方法在每次循环中都创建了一个新的作用域。换句话说，要想得到所期望的结果，每次循环我们都需要一个块级作用域。而在ES6中的let声明，可以用来劫持块作用域，并且在这个块级作用域中声明一个变量。如代码所示：
```javascript
for(let i = 1; i <= 5; i++){
    setTimeout(function timer(){
        console.log(i);     //1,2,3,4,5
    },i*1000);
}
```
通过let声明，变量i在循环过程中不止被声明一次，每次循环都会声明，随后的每一次迭代都会使用上一个迭代结束时的值来初始化这个变量。本质上就是通过let声明在每次迭代都会生成一个新的作用域。
## 资料参考
1.你不知道的JavaScript（上卷）
2.JavaScript高级程序设计（第3版）
