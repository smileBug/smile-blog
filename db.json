{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"61976b3c41e07f288a2246ee0617c3528c1ad1d4","modified":1536134887968},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1535447352301},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1535447352301},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1535447352303},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1535447352302},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1535447352303},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1535447352303},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1535447352304},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1535447352304},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1535447352304},{"_id":"themes/next/_config.yml","hash":"42d689aec952230c52482ec3a8798f581d2d5c1d","modified":1536060092533},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1535447352304},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1535447352304},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1535447352304},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1535447352306},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1535447352306},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1535447352326},{"_id":"source/_posts/ES6之Promise.md","hash":"3cd6ef858e51211158329d0b2490edf987d9936a","modified":1475875540000},{"_id":"source/_posts/ES6学习笔记之Class.md","hash":"3c0d8c3565f4a2baba55f16a0e060ad770afb11b","modified":1475875540000},{"_id":"source/_posts/ES6学习笔记之let和const.md","hash":"ccc3c7f111412b6aff2685a24c7517c6668047c7","modified":1475875540000},{"_id":"source/_posts/HTTP-状态码学习.md","hash":"6916856bf13acfa2034c618ddd68556192360a5e","modified":1475875540000},{"_id":"source/_posts/HelloBlog.md","hash":"d1f567728b161bf505584f8ae0e613e9d0c77082","modified":1475875540000},{"_id":"source/_posts/I-have-a-dream.md","hash":"2d7987582dccbb24bdc0a97b5f4e1fdd2ad161e2","modified":1475875540000},{"_id":"source/_posts/JavaScript 作用域变量查询.md","hash":"649ef7c7cf1fb3b02627fdc5b1756e153fb3b033","modified":1475875540000},{"_id":"source/_posts/JavaScript 判断数组以及instanceof的局限性.md","hash":"23befdd7f65606dc3059b22427b41115056524df","modified":1475875540000},{"_id":"source/_posts/JavaScript-Puzzlers-44道让人精分的题.md","hash":"e52bcc3946b82172791c493183e1f34314da385f","modified":1475875540000},{"_id":"source/_posts/JavaScript-关于this.md","hash":"850b073b3cefb846132122d84a257319c40d29bf","modified":1475875540000},{"_id":"source/_posts/.DS_Store","hash":"2b41d0bc95d52165f108f0e1031d5a8b73cc9c04","modified":1536134897638},{"_id":"source/_posts/JavaScript-正则表达式.md","hash":"efeae05db5f79f04140a40c663fc7a62aefe435a","modified":1475875540000},{"_id":"source/_posts/JavaScript-闭包.md","hash":"b7ecc1cf08600b94376d19ca7d7ee21d40bfd6d7","modified":1475875540000},{"_id":"source/_posts/MooTools-源码分析之Core.md","hash":"5b3bb05c0a6dbfadf7964051f36f0254a5d2ae3b","modified":1475875540000},{"_id":"source/_posts/一把梯子.md","hash":"2210de2ecf7d296065eaafcc0dd078574df982bb","modified":1475875540000},{"_id":"source/_posts/关于实习校招.md","hash":"a2e15ca17ce2c25d221a8acd8d60b7e51418fff7","modified":1475875540000},{"_id":"source/_posts/回望.md","hash":"21c68d6c5f0eb76c20027eb11fa3c64f773bfeb6","modified":1475875540000},{"_id":"source/_posts/是时候开始一门后端语言了.md","hash":"c5dfd22f06104f08ad0453baf3d7939ea5ddd29d","modified":1475875540000},{"_id":"source/_posts/我们的征途是星辰大海！.md","hash":"5b26a4f0e9f49f2977055b8f230d9bf2847c56d4","modified":1475875540000},{"_id":"source/_posts/留校以后.md","hash":"1d19aa5fe34c4c29d1746da0e8b0744992185559","modified":1475875540000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1535447352287},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1535447352289},{"_id":"themes/next/.git/index","hash":"57f4d70de493f9f42e9bcd5c238eaa9e0afe201c","modified":1536059128472},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1535447003161},{"_id":"themes/next/.git/packed-refs","hash":"69237944e31c16fe545d1f47b0b1e5b1d99660da","modified":1535447352284},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1535447352302},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1535447352302},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1535447352303},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1535447352302},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1535447352306},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1535447352306},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1535447352306},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1535447352306},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1535447352307},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1535447352307},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1535447352307},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1535447352307},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1535447352307},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1535447352307},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1535447352308},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1535447352308},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1535447352308},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1535447352308},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1535447352309},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1535447352309},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1535447352309},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1535447352325},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1535447352325},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1535447352325},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1535447352325},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1535447352325},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1535447352326},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1535447352326},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1535447352326},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1535447352327},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1535447352415},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1535447352414},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1535447352414},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535447352352},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1535447003162},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1535447003164},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1535447003165},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1535447003163},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1535447003163},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1535447003165},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1535447003166},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1535447003162},{"_id":"themes/next/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1535447003160},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1535447003165},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1535447003164},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1535447003166},{"_id":"themes/next/.git/logs/HEAD","hash":"d0332071797e4b6eb934e0e09d62afece3d20f27","modified":1535447352288},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1535447352309},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1535447352309},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1535447352310},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1535447352310},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1535447352310},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1535447352310},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1535447352311},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1535447352311},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1535447352311},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1535447352312},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1535447352312},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1535447352313},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1535447352313},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1535447352313},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1535447352313},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1535447352315},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1535447352315},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1535447352316},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1535447352321},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1535447352322},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1535447352322},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1535447352322},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1535447352322},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1535447352322},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1535447352323},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1535447352328},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1535447352328},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1535447352328},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1535447352328},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1535447352328},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1535447352329},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1535447352329},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1535447352329},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1535447352329},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1535447352352},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1535447352353},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1535447352352},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1535447352352},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1535447352353},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1535447352354},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1535447352354},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1535447352354},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1535447352355},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1535447352356},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1535447352355},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1535447352355},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1535447352356},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1535447352356},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1535447352356},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1535447352357},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1535447352357},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1535447352356},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1535447352357},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535447352316},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535447352316},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535447352345},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535447352345},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535447352345},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535447352351},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535447352352},{"_id":"themes/next/.git/refs/heads/master","hash":"7999da428ebb87e5a2b27315d8d5123c1ccdfaa5","modified":1535447352288},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1535447352312},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1535447352312},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1535447352313},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1535447352314},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1535447352314},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1535447352314},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1535447352314},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1535447352314},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1535447352315},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1535447352316},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1535447352316},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1535447352316},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1535447352317},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1535447352317},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1535447352317},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1535447352317},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1535447352318},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1535447352318},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1535447352318},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1535447352318},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1535447352318},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1535447352319},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1535447352319},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1535447352319},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1535447352319},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1535447352320},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1535447352320},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1535447352320},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1535447352320},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1535447352320},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1535447352321},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1535447352321},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1535447352321},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1535447352321},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1535447352323},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1535447352324},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1535447352324},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1535447352324},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1535447352344},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1535447352345},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1535447352345},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1535447352345},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1535447352351},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1535447352351},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1535447352351},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1535447352351},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1535447352359},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1535447352358},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1535447352357},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1535447352359},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1535447352358},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1535447352358},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1535447352359},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1535447352359},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1535447352360},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1535447352360},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1535447352360},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1535447352366},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1535447352371},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1535447352371},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1535447352371},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1535447352371},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1535447352376},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1535447352377},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1535447352376},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1535447352378},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1535447352376},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1535447352378},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1535447352378},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1535447352378},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1535447352378},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1535447352395},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1535447352397},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1535447352397},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1535447352397},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1535447352397},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1535447352398},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1535447352398},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1535447352400},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1535447352399},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1535447352400},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1535447352400},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1535447352400},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1535447352401},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1535447352401},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1535447352401},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1535447352402},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1535447352401},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1535447352402},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1535447352402},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1535447352402},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1535447352403},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1535447352403},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1535447352403},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1535447352403},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1535447352405},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1535447352404},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1535447352404},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1535447352410},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1535447352411},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1535447352413},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1535447352414},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1535447352414},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1535447352396},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"d0332071797e4b6eb934e0e09d62afece3d20f27","modified":1535447352288},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1535447352287},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1535447352323},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1535447352323},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1535447352330},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1535447352330},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1535447352330},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1535447352330},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1535447352330},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1535447352333},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1535447352338},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1535447352343},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1535447352343},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1535447352344},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1535447352343},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1535447352344},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1535447352344},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1535447352344},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1535447352346},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1535447352346},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1535447352346},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1535447352347},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1535447352346},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1535447352347},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1535447352347},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1535447352347},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1535447352348},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1535447352348},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1535447352349},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1535447352348},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1535447352349},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1535447352349},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1535447352350},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1535447352350},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1535447352350},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1535447352350},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1535447352350},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1535447352360},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1535447352363},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1535447352366},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1535447352365},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1535447352372},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1535447352372},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1535447352372},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1535447352373},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1535447352373},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1535447352373},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1535447352375},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1535447352376},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1535447352375},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1535447352377},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1535447352378},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1535447352379},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1535447352379},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1535447352380},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1535447352409},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1535447352410},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1535447352364},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1535447352413},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1535447352394},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1535447352393},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"d0332071797e4b6eb934e0e09d62afece3d20f27","modified":1535447352286},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1535447352331},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1535447352331},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1535447352331},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1535447352331},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1535447352331},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1535447352331},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1535447352332},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1535447352333},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1535447352332},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1535447352332},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1535447352332},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1535447352333},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1535447352334},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1535447352333},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1535447352333},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1535447352334},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1535447352334},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1535447352334},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1535447352334},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1535447352335},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1535447352335},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1535447352335},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1535447352335},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1535447352336},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1535447352335},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1535447352336},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1535447352336},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1535447352336},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1535447352336},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1535447352336},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1535447352337},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1535447352337},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1535447352337},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1535447352338},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1535447352337},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1535447352338},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1535447352338},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1535447352338},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1535447352338},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1535447352339},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1535447352339},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1535447352339},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1535447352339},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1535447352340},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1535447352340},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1535447352340},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1535447352340},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1535447352341},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1535447352341},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1535447352340},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1535447352341},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1535447352342},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1535447352342},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1535447352341},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1535447352342},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1535447352342},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1535447352342},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1535447352343},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1535447352347},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1535447352348},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1535447352349},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1535447352361},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1535447352361},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1535447352361},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1535447352362},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1535447352363},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1535447352373},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1535447352373},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1535447352374},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1535447352374},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1535447352374},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1535447352374},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1535447352385},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1535447352382},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1535447352391},{"_id":"themes/next/.git/objects/pack/pack-c612b977fdee8f070a000761134eeb6350850a38.idx","hash":"baccc333989b5a1b1719965c6c3a9891cce61ff6","modified":1535447352259},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1535447352370},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1535447352409},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1535447352389},{"_id":"themes/next/.git/objects/pack/pack-c612b977fdee8f070a000761134eeb6350850a38.pack","hash":"1310fd9358c94811f585a7fa3724d7431f130898","modified":1535447352252}],"Category":[{"name":"ES6","_id":"cjlov63w10002w9uayme91qxs"},{"name":"HTTP","_id":"cjlov63wb000cw9uant87dnkv"},{"name":"随笔","_id":"cjlov63wf000iw9uamklsxdpt"},{"name":"JS","_id":"cjlov63wj000sw9uanqdqej9m"},{"name":"工具","_id":"cjlov63ww001tw9uaqua7ospq"}],"Data":[],"Page":[],"Post":[{"title":"ES6学习笔记之Promise","date":"2016-08-18T08:47:59.000Z","_content":"### 概念\nPromise是JavaScript针对异步操作场景的解决方案\n\nPromise首先是个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件，并且这个事件提供统一的API，可供进一步处理。\n<!-- more -->\n以同步方式来写代码，但是执行方式是异步的，但是保证程序的执行顺序是同步的。\n### 三种状态\nPromise只有三种状态：未完成（pending）、已完成（fulfilled 或 Resolved）和失败（rejected）\n这三种状态的变化可以从未完成-->已完成，或者从未完成-->失败。\n过程只能发生一次，并且是不可逆的，也就是说不能从未完成-->已完成-->失败，也不能从已完成或者失败-->未完成\n### 特点\nPromise的链式写法，程序流程清晰。更易于维护。\n### 实现例子\n通过Promise实现的一个小动画\n[在线演示](http://smilebug.me/demos/ball.html)\n```\n//获取三个球\nvar ball1 = document.querySelector('.ball1');\nvar ball2 = document.querySelector('.ball2');\nvar ball3 = document.querySelector('.ball3');\n// Promise实现\nfunction promiseAnimate(ball,distance){\n\treturn new Promise(function(resolve,reject){\n\t\tfunction _animate(){\n\t\t\tsetTimeout(function(){\n\t\t\t\tvar marginLeft = parseInt(ball.style.marginLeft);\n\t\t\t\tif (marginLeft == distance) {\n\t\t\t\t\tresolve()\n\t\t\t\t} else {\n\t\t\t\t\tif (marginLeft < distance){\n\t\t\t\t\t\tmarginLeft++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmarginLeft--;\n\t\t\t\t\t}\n\t\t\t\t\tball.style.marginLeft = marginLeft + 'px';\n\t\t\t\t\t_animate();\n\t\t\t\t}\n\t\t\t},13)\n\t\t}\n\t\t_animate();\n\t})\n}\n\npromiseAnimate(ball1,100)\n\t.then(function(){\n\t\treturn promiseAnimate(ball2,100);\n}).then(function(){\n\t\treturn promiseAnimate(ball3,100);\n}).then(function(){\n\t\treturn promiseAnimate(ball1,200);\n}).then(function(){\n\t\treturn promiseAnimate(ball2,200);\n}).then(function(){\n\t\treturn promiseAnimate(ball3,200);\n})\n```\n\n","source":"_posts/ES6之Promise.md","raw":"---\ntitle: ES6学习笔记之Promise\ndate: 2016-08-18 16:47:59\ncategories:\n\tES6\ntags:\n\tPromise\n---\n### 概念\nPromise是JavaScript针对异步操作场景的解决方案\n\nPromise首先是个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件，并且这个事件提供统一的API，可供进一步处理。\n<!-- more -->\n以同步方式来写代码，但是执行方式是异步的，但是保证程序的执行顺序是同步的。\n### 三种状态\nPromise只有三种状态：未完成（pending）、已完成（fulfilled 或 Resolved）和失败（rejected）\n这三种状态的变化可以从未完成-->已完成，或者从未完成-->失败。\n过程只能发生一次，并且是不可逆的，也就是说不能从未完成-->已完成-->失败，也不能从已完成或者失败-->未完成\n### 特点\nPromise的链式写法，程序流程清晰。更易于维护。\n### 实现例子\n通过Promise实现的一个小动画\n[在线演示](http://smilebug.me/demos/ball.html)\n```\n//获取三个球\nvar ball1 = document.querySelector('.ball1');\nvar ball2 = document.querySelector('.ball2');\nvar ball3 = document.querySelector('.ball3');\n// Promise实现\nfunction promiseAnimate(ball,distance){\n\treturn new Promise(function(resolve,reject){\n\t\tfunction _animate(){\n\t\t\tsetTimeout(function(){\n\t\t\t\tvar marginLeft = parseInt(ball.style.marginLeft);\n\t\t\t\tif (marginLeft == distance) {\n\t\t\t\t\tresolve()\n\t\t\t\t} else {\n\t\t\t\t\tif (marginLeft < distance){\n\t\t\t\t\t\tmarginLeft++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmarginLeft--;\n\t\t\t\t\t}\n\t\t\t\t\tball.style.marginLeft = marginLeft + 'px';\n\t\t\t\t\t_animate();\n\t\t\t\t}\n\t\t\t},13)\n\t\t}\n\t\t_animate();\n\t})\n}\n\npromiseAnimate(ball1,100)\n\t.then(function(){\n\t\treturn promiseAnimate(ball2,100);\n}).then(function(){\n\t\treturn promiseAnimate(ball3,100);\n}).then(function(){\n\t\treturn promiseAnimate(ball1,200);\n}).then(function(){\n\t\treturn promiseAnimate(ball2,200);\n}).then(function(){\n\t\treturn promiseAnimate(ball3,200);\n})\n```\n\n","slug":"ES6之Promise","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63vv0000w9ua9bn6sufv","content":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>Promise是JavaScript针对异步操作场景的解决方案</p>\n<p>Promise首先是个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件，并且这个事件提供统一的API，可供进一步处理。<br><a id=\"more\"></a><br>以同步方式来写代码，但是执行方式是异步的，但是保证程序的执行顺序是同步的。</p>\n<h3 id=\"三种状态\"><a href=\"#三种状态\" class=\"headerlink\" title=\"三种状态\"></a>三种状态</h3><p>Promise只有三种状态：未完成（pending）、已完成（fulfilled 或 Resolved）和失败（rejected）<br>这三种状态的变化可以从未完成–&gt;已完成，或者从未完成–&gt;失败。<br>过程只能发生一次，并且是不可逆的，也就是说不能从未完成–&gt;已完成–&gt;失败，也不能从已完成或者失败–&gt;未完成</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>Promise的链式写法，程序流程清晰。更易于维护。</p>\n<h3 id=\"实现例子\"><a href=\"#实现例子\" class=\"headerlink\" title=\"实现例子\"></a>实现例子</h3><p>通过Promise实现的一个小动画<br><a href=\"http://smilebug.me/demos/ball.html\" target=\"_blank\" rel=\"noopener\">在线演示</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取三个球</span><br><span class=\"line\">var ball1 = document.querySelector(&apos;.ball1&apos;);</span><br><span class=\"line\">var ball2 = document.querySelector(&apos;.ball2&apos;);</span><br><span class=\"line\">var ball3 = document.querySelector(&apos;.ball3&apos;);</span><br><span class=\"line\">// Promise实现</span><br><span class=\"line\">function promiseAnimate(ball,distance)&#123;</span><br><span class=\"line\">\treturn new Promise(function(resolve,reject)&#123;</span><br><span class=\"line\">\t\tfunction _animate()&#123;</span><br><span class=\"line\">\t\t\tsetTimeout(function()&#123;</span><br><span class=\"line\">\t\t\t\tvar marginLeft = parseInt(ball.style.marginLeft);</span><br><span class=\"line\">\t\t\t\tif (marginLeft == distance) &#123;</span><br><span class=\"line\">\t\t\t\t\tresolve()</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\tif (marginLeft &lt; distance)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tmarginLeft++;</span><br><span class=\"line\">\t\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\t\tmarginLeft--;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tball.style.marginLeft = marginLeft + &apos;px&apos;;</span><br><span class=\"line\">\t\t\t\t\t_animate();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;,13)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t_animate();</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">promiseAnimate(ball1,100)</span><br><span class=\"line\">\t.then(function()&#123;</span><br><span class=\"line\">\t\treturn promiseAnimate(ball2,100);</span><br><span class=\"line\">&#125;).then(function()&#123;</span><br><span class=\"line\">\t\treturn promiseAnimate(ball3,100);</span><br><span class=\"line\">&#125;).then(function()&#123;</span><br><span class=\"line\">\t\treturn promiseAnimate(ball1,200);</span><br><span class=\"line\">&#125;).then(function()&#123;</span><br><span class=\"line\">\t\treturn promiseAnimate(ball2,200);</span><br><span class=\"line\">&#125;).then(function()&#123;</span><br><span class=\"line\">\t\treturn promiseAnimate(ball3,200);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>Promise是JavaScript针对异步操作场景的解决方案</p>\n<p>Promise首先是个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件，并且这个事件提供统一的API，可供进一步处理。<br>","more":"<br>以同步方式来写代码，但是执行方式是异步的，但是保证程序的执行顺序是同步的。</p>\n<h3 id=\"三种状态\"><a href=\"#三种状态\" class=\"headerlink\" title=\"三种状态\"></a>三种状态</h3><p>Promise只有三种状态：未完成（pending）、已完成（fulfilled 或 Resolved）和失败（rejected）<br>这三种状态的变化可以从未完成–&gt;已完成，或者从未完成–&gt;失败。<br>过程只能发生一次，并且是不可逆的，也就是说不能从未完成–&gt;已完成–&gt;失败，也不能从已完成或者失败–&gt;未完成</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>Promise的链式写法，程序流程清晰。更易于维护。</p>\n<h3 id=\"实现例子\"><a href=\"#实现例子\" class=\"headerlink\" title=\"实现例子\"></a>实现例子</h3><p>通过Promise实现的一个小动画<br><a href=\"http://smilebug.me/demos/ball.html\" target=\"_blank\" rel=\"noopener\">在线演示</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取三个球</span><br><span class=\"line\">var ball1 = document.querySelector(&apos;.ball1&apos;);</span><br><span class=\"line\">var ball2 = document.querySelector(&apos;.ball2&apos;);</span><br><span class=\"line\">var ball3 = document.querySelector(&apos;.ball3&apos;);</span><br><span class=\"line\">// Promise实现</span><br><span class=\"line\">function promiseAnimate(ball,distance)&#123;</span><br><span class=\"line\">\treturn new Promise(function(resolve,reject)&#123;</span><br><span class=\"line\">\t\tfunction _animate()&#123;</span><br><span class=\"line\">\t\t\tsetTimeout(function()&#123;</span><br><span class=\"line\">\t\t\t\tvar marginLeft = parseInt(ball.style.marginLeft);</span><br><span class=\"line\">\t\t\t\tif (marginLeft == distance) &#123;</span><br><span class=\"line\">\t\t\t\t\tresolve()</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\tif (marginLeft &lt; distance)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tmarginLeft++;</span><br><span class=\"line\">\t\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\t\tmarginLeft--;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tball.style.marginLeft = marginLeft + &apos;px&apos;;</span><br><span class=\"line\">\t\t\t\t\t_animate();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;,13)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t_animate();</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">promiseAnimate(ball1,100)</span><br><span class=\"line\">\t.then(function()&#123;</span><br><span class=\"line\">\t\treturn promiseAnimate(ball2,100);</span><br><span class=\"line\">&#125;).then(function()&#123;</span><br><span class=\"line\">\t\treturn promiseAnimate(ball3,100);</span><br><span class=\"line\">&#125;).then(function()&#123;</span><br><span class=\"line\">\t\treturn promiseAnimate(ball1,200);</span><br><span class=\"line\">&#125;).then(function()&#123;</span><br><span class=\"line\">\t\treturn promiseAnimate(ball2,200);</span><br><span class=\"line\">&#125;).then(function()&#123;</span><br><span class=\"line\">\t\treturn promiseAnimate(ball3,200);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>"},{"title":"ES6学习笔记之Class","date":"2016-09-07T01:58:28.000Z","_content":"## Class\n要说ES5中最让人头疼的部分，那原型，构造函数和继承这三个一定排得上前几，复杂难懂的语法，扑朔迷离的指针无不让我们纠结万分。\n<!-- more -->\n为此ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。\n### Class概述\n基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。\n例如：\n```\nclass People{\n    constructor(name,age){\n        this.name = name;\n        this.age = age;\n    }\n\n    say(){\n        console.log('I am ' + this.name)\n    }\n}\n```\n上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。这里的构造方法对应的就是ES5中的构造函数。\n简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。\nES6的类，完全可以看作构造函数的另一种写法。类的数据类型就是函数，类本身就指向构造函数。\n例如：\n```\nclass People{\n    //...\n}\n\ntypeof People;   //\"function\"\nPeople === People.prototype.constructor;   //true\n```\n\n### constructor方法\nconstructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。\n\n### 类的实例对象\n生成类的实例对象的写法，与ES5完全一样，也是使用new命令。但如果忘记加上new，像函数那样调用Class，将会报错。而普通构造函数不用new也可以执行。这是两者的主要区别。\n```\nvar p1 = new People('Tony',22); //正确\nvar p2 = People('Lucy',23);  //报错\n```\n### 不存在变量提升\nES6不会把类的声明提升到代码头部。也就是在定义类前使用它就会报错。这种规定的原因与继承有关，必须保证子类在父类之后定义。\n\n## Class的继承\n### extends关键字\nClass之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。\n```\nclass Actor extends People {}\n```\n上面代码定义了一个Actor类，该类通过extends关键字，继承了People类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个People类。下面在Actor内部加上代码 。\n```\nclass Actor extends People {\n    constructor(name,age,habbit){\n        super(name,age);\n        this.habbit = habbit;\n    }\n\n    say(){\n        console.log('I am ' + this.name + ', and I like ' + this.habbit)\n    }\n}\n```\n上面代码中，constructor方法和say方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。\n子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。\n### super关键字\nsuper这个关键字，有两种用法，含义不同。\n\n（1）作为函数调用时（即super(...args)），super代表父类的构造函数。\n\n（2）作为对象调用时（即super.prop或super.method()），super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。\n## 资料参考\n[《ES6 标准入门》](http://es6.ruanyifeng.com/#docs/let)\n","source":"_posts/ES6学习笔记之Class.md","raw":"---\ntitle: ES6学习笔记之Class\ndate: 2016-09-07 09:58:28\ncategories:\n\tES6\ntags:\n\t- Class\n\t- extends\n\t- super\n---\n## Class\n要说ES5中最让人头疼的部分，那原型，构造函数和继承这三个一定排得上前几，复杂难懂的语法，扑朔迷离的指针无不让我们纠结万分。\n<!-- more -->\n为此ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。\n### Class概述\n基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。\n例如：\n```\nclass People{\n    constructor(name,age){\n        this.name = name;\n        this.age = age;\n    }\n\n    say(){\n        console.log('I am ' + this.name)\n    }\n}\n```\n上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。这里的构造方法对应的就是ES5中的构造函数。\n简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。\nES6的类，完全可以看作构造函数的另一种写法。类的数据类型就是函数，类本身就指向构造函数。\n例如：\n```\nclass People{\n    //...\n}\n\ntypeof People;   //\"function\"\nPeople === People.prototype.constructor;   //true\n```\n\n### constructor方法\nconstructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。\n\n### 类的实例对象\n生成类的实例对象的写法，与ES5完全一样，也是使用new命令。但如果忘记加上new，像函数那样调用Class，将会报错。而普通构造函数不用new也可以执行。这是两者的主要区别。\n```\nvar p1 = new People('Tony',22); //正确\nvar p2 = People('Lucy',23);  //报错\n```\n### 不存在变量提升\nES6不会把类的声明提升到代码头部。也就是在定义类前使用它就会报错。这种规定的原因与继承有关，必须保证子类在父类之后定义。\n\n## Class的继承\n### extends关键字\nClass之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。\n```\nclass Actor extends People {}\n```\n上面代码定义了一个Actor类，该类通过extends关键字，继承了People类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个People类。下面在Actor内部加上代码 。\n```\nclass Actor extends People {\n    constructor(name,age,habbit){\n        super(name,age);\n        this.habbit = habbit;\n    }\n\n    say(){\n        console.log('I am ' + this.name + ', and I like ' + this.habbit)\n    }\n}\n```\n上面代码中，constructor方法和say方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。\n子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。\n### super关键字\nsuper这个关键字，有两种用法，含义不同。\n\n（1）作为函数调用时（即super(...args)），super代表父类的构造函数。\n\n（2）作为对象调用时（即super.prop或super.method()），super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。\n## 资料参考\n[《ES6 标准入门》](http://es6.ruanyifeng.com/#docs/let)\n","slug":"ES6学习笔记之Class","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63vy0001w9uaa077z5h0","content":"<h2 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h2><p>要说ES5中最让人头疼的部分，那原型，构造函数和继承这三个一定排得上前几，复杂难懂的语法，扑朔迷离的指针无不让我们纠结万分。<br><a id=\"more\"></a><br>为此ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</p>\n<h3 id=\"Class概述\"><a href=\"#Class概述\" class=\"headerlink\" title=\"Class概述\"></a>Class概述</h3><p>基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class People&#123;</span><br><span class=\"line\">    constructor(name,age)&#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    say()&#123;</span><br><span class=\"line\">        console.log(&apos;I am &apos; + this.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。这里的构造方法对应的就是ES5中的构造函数。<br>简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。<br>ES6的类，完全可以看作构造函数的另一种写法。类的数据类型就是函数，类本身就指向构造函数。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class People&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typeof People;   //&quot;function&quot;</span><br><span class=\"line\">People === People.prototype.constructor;   //true</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"constructor方法\"><a href=\"#constructor方法\" class=\"headerlink\" title=\"constructor方法\"></a>constructor方法</h3><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>\n<h3 id=\"类的实例对象\"><a href=\"#类的实例对象\" class=\"headerlink\" title=\"类的实例对象\"></a>类的实例对象</h3><p>生成类的实例对象的写法，与ES5完全一样，也是使用new命令。但如果忘记加上new，像函数那样调用Class，将会报错。而普通构造函数不用new也可以执行。这是两者的主要区别。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 = new People(&apos;Tony&apos;,22); //正确</span><br><span class=\"line\">var p2 = People(&apos;Lucy&apos;,23);  //报错</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h3><p>ES6不会把类的声明提升到代码头部。也就是在定义类前使用它就会报错。这种规定的原因与继承有关，必须保证子类在父类之后定义。</p>\n<h2 id=\"Class的继承\"><a href=\"#Class的继承\" class=\"headerlink\" title=\"Class的继承\"></a>Class的继承</h2><h3 id=\"extends关键字\"><a href=\"#extends关键字\" class=\"headerlink\" title=\"extends关键字\"></a>extends关键字</h3><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Actor extends People &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码定义了一个Actor类，该类通过extends关键字，继承了People类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个People类。下面在Actor内部加上代码 。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Actor extends People &#123;</span><br><span class=\"line\">    constructor(name,age,habbit)&#123;</span><br><span class=\"line\">        super(name,age);</span><br><span class=\"line\">        this.habbit = habbit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    say()&#123;</span><br><span class=\"line\">        console.log(&apos;I am &apos; + this.name + &apos;, and I like &apos; + this.habbit)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，constructor方法和say方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。<br>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>\n<h3 id=\"super关键字\"><a href=\"#super关键字\" class=\"headerlink\" title=\"super关键字\"></a>super关键字</h3><p>super这个关键字，有两种用法，含义不同。</p>\n<p>（1）作为函数调用时（即super(…args)），super代表父类的构造函数。</p>\n<p>（2）作为对象调用时（即super.prop或super.method()），super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。</p>\n<h2 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h2><p><a href=\"http://es6.ruanyifeng.com/#docs/let\" target=\"_blank\" rel=\"noopener\">《ES6 标准入门》</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h2><p>要说ES5中最让人头疼的部分，那原型，构造函数和继承这三个一定排得上前几，复杂难懂的语法，扑朔迷离的指针无不让我们纠结万分。<br>","more":"<br>为此ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</p>\n<h3 id=\"Class概述\"><a href=\"#Class概述\" class=\"headerlink\" title=\"Class概述\"></a>Class概述</h3><p>基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class People&#123;</span><br><span class=\"line\">    constructor(name,age)&#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    say()&#123;</span><br><span class=\"line\">        console.log(&apos;I am &apos; + this.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。这里的构造方法对应的就是ES5中的构造函数。<br>简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。<br>ES6的类，完全可以看作构造函数的另一种写法。类的数据类型就是函数，类本身就指向构造函数。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class People&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typeof People;   //&quot;function&quot;</span><br><span class=\"line\">People === People.prototype.constructor;   //true</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"constructor方法\"><a href=\"#constructor方法\" class=\"headerlink\" title=\"constructor方法\"></a>constructor方法</h3><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>\n<h3 id=\"类的实例对象\"><a href=\"#类的实例对象\" class=\"headerlink\" title=\"类的实例对象\"></a>类的实例对象</h3><p>生成类的实例对象的写法，与ES5完全一样，也是使用new命令。但如果忘记加上new，像函数那样调用Class，将会报错。而普通构造函数不用new也可以执行。这是两者的主要区别。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 = new People(&apos;Tony&apos;,22); //正确</span><br><span class=\"line\">var p2 = People(&apos;Lucy&apos;,23);  //报错</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h3><p>ES6不会把类的声明提升到代码头部。也就是在定义类前使用它就会报错。这种规定的原因与继承有关，必须保证子类在父类之后定义。</p>\n<h2 id=\"Class的继承\"><a href=\"#Class的继承\" class=\"headerlink\" title=\"Class的继承\"></a>Class的继承</h2><h3 id=\"extends关键字\"><a href=\"#extends关键字\" class=\"headerlink\" title=\"extends关键字\"></a>extends关键字</h3><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Actor extends People &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码定义了一个Actor类，该类通过extends关键字，继承了People类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个People类。下面在Actor内部加上代码 。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Actor extends People &#123;</span><br><span class=\"line\">    constructor(name,age,habbit)&#123;</span><br><span class=\"line\">        super(name,age);</span><br><span class=\"line\">        this.habbit = habbit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    say()&#123;</span><br><span class=\"line\">        console.log(&apos;I am &apos; + this.name + &apos;, and I like &apos; + this.habbit)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，constructor方法和say方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。<br>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>\n<h3 id=\"super关键字\"><a href=\"#super关键字\" class=\"headerlink\" title=\"super关键字\"></a>super关键字</h3><p>super这个关键字，有两种用法，含义不同。</p>\n<p>（1）作为函数调用时（即super(…args)），super代表父类的构造函数。</p>\n<p>（2）作为对象调用时（即super.prop或super.method()），super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。</p>\n<h2 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h2><p><a href=\"http://es6.ruanyifeng.com/#docs/let\" target=\"_blank\" rel=\"noopener\">《ES6 标准入门》</a></p>"},{"title":"HTTP 状态码学习（喵星人版）","date":"2016-08-07T05:31:45.000Z","_content":"## HTTP学习\n个人觉得作为一个有理想有抱负的前端工程师HTTP这块的知识是非常有必要掌握的，熟悉了HTTP协议，以后进行调试的时候，才能看明白捕获回来的HTTP请求，并且知道是不是其中某个地方有问题导致出现你想要修复的bug，如何处理能够最终修复这个bug。\n<!-- more -->\n## HTTP状态码\n状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。\n\n状态码由3位数字和原因短语组成，数字中第一位指定相应类别，后两位无分类，有以下5中响应类别。\n\n| 状态码     | 类别   \t\t\t\t\t\t\t\t\t\t\t\t | 原因短语  \t\t\t\t\t\t\t\t\t\t|\n| --------   | :----- \t\t\t\t\t\t\t\t\t\t\t\t | :----  \t\t\t\t\t\t\t\t\t\t\t|\n| 1XX        | Informational(信息性状态码)\t\t | 接受的请求正在处理   \t\t\t  |\n| 2XX        | Success(成功状态码)  \t\t\t\t\t | 请求正常处理完毕  \t\t\t\t\t\t|\n| 3XX        | Redirection(重定向状态码)   \t\t | 需要进行附加操作以完成请求   |\n| 4XX        | Client Error(客户端错误状态码)  | 服务器无法处理请求  \t\t\t\t\t|\n| 5XX        | Server Error(服务器错误状态码)  | 服务器处理请求出错  \t\t\t\t\t|\n\n\n网上看到HTTP趣味记法。通过ps了一系列的HTTP信息，让人印象深刻。[原文地址](http://rightyaleft.com/funhumor/http-status-codes-with-meooowwwwww-using-cat-photos/)\n原文状态码比较全，这里我只选取了部分比较正常常用的。\n## 2XX 成功\n2XX的响应结果表明请求被正常处理了。\n### 200 OK\n![](http://7xsb4y.com1.z0.glb.clouddn.com/200.jpg)\n最常见的“200 OK”表示从客户端发来的请求在服务器端被正常处理了。\n### 204 No Content（无内容）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/204.jpg)\n该状态码代表请求已成功被服务器处理，但没有返回任何实体内容。\n\n例如浏览器发送请求处理后，返回204响应，浏览器显示页面就不发生更新。\n\n一般只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。\n### 206 Partial Content（局部内容）\n该状态码表示客户端进行请求头中包含Range字段指定范围的请求，服务器端成功执行GET请求，响应报文中包含Content-Range指定范围的实体内容。\n## 3XX 重定向\n3XX响应结果表明浏览器需要执行某些特殊的处理来正确处理请求。\n### 301 Moved Permanently（永久重定向）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/301.jpg)\n永久重定向。\n\n该状态码表示请求的资源被分配了新的URI，以后应使用响应报文头部中Location所指的URI。\n\n举个例子，如果已经把资源对应的URI保存为书签，这时应该按Location首部字段提示的URI重新保存。\n### 302 Found（找到）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/302.jpg)\n临时重定向。\n\n该状态码表示请求的资源被分配了新的URI，本次应使用响应报文头部中Location所指的URI。\n\n举个例子，如果已经把资源对应的URI保存为书签，不需要重新保存。\n### 304 Not Modified（未修改）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/304.jpg)\n该状态码表示资源自上次请求以来没有被改变。\n\n304状态码返回时，不包含任何响应的主体部分。\n## 4XX 客户端错误\n4XX的响应结果表明客户端是发生错误的原因所在。\n### 400 Bad Request（错误请求）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/400.jpg)\n该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。\n### 401 Unanthorized（未授权）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/401.jpg)\n该状态码表示发送的请求需要有通过HTTP认证(BASIC认证、DIGEST认证)的认证信息。\n\n返回401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询(challenge)用户信息。\n\n浏览器初次接受401响应，会弹出认证用的对话窗口。输入密码、用户名之后会再次请求，此时的请求头中会包含Authorization首部字段，用来说明认证算法、用户和密码。如果授权证书是正确的，服务器就会将文档返回。\n### 403 Forbidden（禁止）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/403.jpg)\n该状态码表明对请求资源的访问被服务器拒绝了。\n### 404 Not Found（未找到）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/404.jpg)\n该状态码表示服务器上无法找到请求的资源。除此之外，也可以在服务器拒绝请求且不想说明的理由时使用。\n## 5XX 服务器错误\n5XX的响应结果表明服务器本身发生错误。\n### 500 Internal Server Error（服务器内部错误）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/500.jpg)\n该状态码表明服务器在执行请求时发生了错误。也有可能是Web应用存在的bug活某些临时故障。\n### 503 Service Unavailable（服务不可用）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/503.jpg)\n该状态码表明服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端，该字段会告知客户端应该在多久之后再次发送请求。\n## 参考资料\n1.《图解HTTP》\n2.[喵星人教你HTTP状态码](http://rightyaleft.com/funhumor/http-status-codes-with-meooowwwwww-using-cat-photos/)\n","source":"_posts/HTTP-状态码学习.md","raw":"---\ntitle: HTTP 状态码学习（喵星人版）\ndate: 2016-08-07 13:31:45\ncategories:\n    HTTP\ntags:\n\t- 状态码\n\t- 喵星人\n---\n## HTTP学习\n个人觉得作为一个有理想有抱负的前端工程师HTTP这块的知识是非常有必要掌握的，熟悉了HTTP协议，以后进行调试的时候，才能看明白捕获回来的HTTP请求，并且知道是不是其中某个地方有问题导致出现你想要修复的bug，如何处理能够最终修复这个bug。\n<!-- more -->\n## HTTP状态码\n状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。\n\n状态码由3位数字和原因短语组成，数字中第一位指定相应类别，后两位无分类，有以下5中响应类别。\n\n| 状态码     | 类别   \t\t\t\t\t\t\t\t\t\t\t\t | 原因短语  \t\t\t\t\t\t\t\t\t\t|\n| --------   | :----- \t\t\t\t\t\t\t\t\t\t\t\t | :----  \t\t\t\t\t\t\t\t\t\t\t|\n| 1XX        | Informational(信息性状态码)\t\t | 接受的请求正在处理   \t\t\t  |\n| 2XX        | Success(成功状态码)  \t\t\t\t\t | 请求正常处理完毕  \t\t\t\t\t\t|\n| 3XX        | Redirection(重定向状态码)   \t\t | 需要进行附加操作以完成请求   |\n| 4XX        | Client Error(客户端错误状态码)  | 服务器无法处理请求  \t\t\t\t\t|\n| 5XX        | Server Error(服务器错误状态码)  | 服务器处理请求出错  \t\t\t\t\t|\n\n\n网上看到HTTP趣味记法。通过ps了一系列的HTTP信息，让人印象深刻。[原文地址](http://rightyaleft.com/funhumor/http-status-codes-with-meooowwwwww-using-cat-photos/)\n原文状态码比较全，这里我只选取了部分比较正常常用的。\n## 2XX 成功\n2XX的响应结果表明请求被正常处理了。\n### 200 OK\n![](http://7xsb4y.com1.z0.glb.clouddn.com/200.jpg)\n最常见的“200 OK”表示从客户端发来的请求在服务器端被正常处理了。\n### 204 No Content（无内容）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/204.jpg)\n该状态码代表请求已成功被服务器处理，但没有返回任何实体内容。\n\n例如浏览器发送请求处理后，返回204响应，浏览器显示页面就不发生更新。\n\n一般只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。\n### 206 Partial Content（局部内容）\n该状态码表示客户端进行请求头中包含Range字段指定范围的请求，服务器端成功执行GET请求，响应报文中包含Content-Range指定范围的实体内容。\n## 3XX 重定向\n3XX响应结果表明浏览器需要执行某些特殊的处理来正确处理请求。\n### 301 Moved Permanently（永久重定向）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/301.jpg)\n永久重定向。\n\n该状态码表示请求的资源被分配了新的URI，以后应使用响应报文头部中Location所指的URI。\n\n举个例子，如果已经把资源对应的URI保存为书签，这时应该按Location首部字段提示的URI重新保存。\n### 302 Found（找到）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/302.jpg)\n临时重定向。\n\n该状态码表示请求的资源被分配了新的URI，本次应使用响应报文头部中Location所指的URI。\n\n举个例子，如果已经把资源对应的URI保存为书签，不需要重新保存。\n### 304 Not Modified（未修改）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/304.jpg)\n该状态码表示资源自上次请求以来没有被改变。\n\n304状态码返回时，不包含任何响应的主体部分。\n## 4XX 客户端错误\n4XX的响应结果表明客户端是发生错误的原因所在。\n### 400 Bad Request（错误请求）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/400.jpg)\n该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。\n### 401 Unanthorized（未授权）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/401.jpg)\n该状态码表示发送的请求需要有通过HTTP认证(BASIC认证、DIGEST认证)的认证信息。\n\n返回401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询(challenge)用户信息。\n\n浏览器初次接受401响应，会弹出认证用的对话窗口。输入密码、用户名之后会再次请求，此时的请求头中会包含Authorization首部字段，用来说明认证算法、用户和密码。如果授权证书是正确的，服务器就会将文档返回。\n### 403 Forbidden（禁止）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/403.jpg)\n该状态码表明对请求资源的访问被服务器拒绝了。\n### 404 Not Found（未找到）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/404.jpg)\n该状态码表示服务器上无法找到请求的资源。除此之外，也可以在服务器拒绝请求且不想说明的理由时使用。\n## 5XX 服务器错误\n5XX的响应结果表明服务器本身发生错误。\n### 500 Internal Server Error（服务器内部错误）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/500.jpg)\n该状态码表明服务器在执行请求时发生了错误。也有可能是Web应用存在的bug活某些临时故障。\n### 503 Service Unavailable（服务不可用）\n![](http://7xsb4y.com1.z0.glb.clouddn.com/503.jpg)\n该状态码表明服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端，该字段会告知客户端应该在多久之后再次发送请求。\n## 参考资料\n1.《图解HTTP》\n2.[喵星人教你HTTP状态码](http://rightyaleft.com/funhumor/http-status-codes-with-meooowwwwww-using-cat-photos/)\n","slug":"HTTP-状态码学习","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63w30004w9ua53j4mrx6","content":"<h2 id=\"HTTP学习\"><a href=\"#HTTP学习\" class=\"headerlink\" title=\"HTTP学习\"></a>HTTP学习</h2><p>个人觉得作为一个有理想有抱负的前端工程师HTTP这块的知识是非常有必要掌握的，熟悉了HTTP协议，以后进行调试的时候，才能看明白捕获回来的HTTP请求，并且知道是不是其中某个地方有问题导致出现你想要修复的bug，如何处理能够最终修复这个bug。<br><a id=\"more\"></a></p>\n<h2 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p>\n<p>状态码由3位数字和原因短语组成，数字中第一位指定相应类别，后两位无分类，有以下5中响应类别。</p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th style=\"text-align:left\">类别</th>\n<th style=\"text-align:left\">原因短语</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td style=\"text-align:left\">Informational(信息性状态码)</td>\n<td style=\"text-align:left\">接受的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td style=\"text-align:left\">Success(成功状态码)</td>\n<td style=\"text-align:left\">请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td style=\"text-align:left\">Redirection(重定向状态码)</td>\n<td style=\"text-align:left\">需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td style=\"text-align:left\">Client Error(客户端错误状态码)</td>\n<td style=\"text-align:left\">服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td style=\"text-align:left\">Server Error(服务器错误状态码)</td>\n<td style=\"text-align:left\">服务器处理请求出错</td>\n</tr>\n</tbody>\n</table>\n<p>网上看到HTTP趣味记法。通过ps了一系列的HTTP信息，让人印象深刻。<a href=\"http://rightyaleft.com/funhumor/http-status-codes-with-meooowwwwww-using-cat-photos/\" target=\"_blank\" rel=\"noopener\">原文地址</a><br>原文状态码比较全，这里我只选取了部分比较正常常用的。</p>\n<h2 id=\"2XX-成功\"><a href=\"#2XX-成功\" class=\"headerlink\" title=\"2XX 成功\"></a>2XX 成功</h2><p>2XX的响应结果表明请求被正常处理了。</p>\n<h3 id=\"200-OK\"><a href=\"#200-OK\" class=\"headerlink\" title=\"200 OK\"></a>200 OK</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/200.jpg\" alt=\"\"><br>最常见的“200 OK”表示从客户端发来的请求在服务器端被正常处理了。</p>\n<h3 id=\"204-No-Content（无内容）\"><a href=\"#204-No-Content（无内容）\" class=\"headerlink\" title=\"204 No Content（无内容）\"></a>204 No Content（无内容）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/204.jpg\" alt=\"\"><br>该状态码代表请求已成功被服务器处理，但没有返回任何实体内容。</p>\n<p>例如浏览器发送请求处理后，返回204响应，浏览器显示页面就不发生更新。</p>\n<p>一般只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>\n<h3 id=\"206-Partial-Content（局部内容）\"><a href=\"#206-Partial-Content（局部内容）\" class=\"headerlink\" title=\"206 Partial Content（局部内容）\"></a>206 Partial Content（局部内容）</h3><p>该状态码表示客户端进行请求头中包含Range字段指定范围的请求，服务器端成功执行GET请求，响应报文中包含Content-Range指定范围的实体内容。</p>\n<h2 id=\"3XX-重定向\"><a href=\"#3XX-重定向\" class=\"headerlink\" title=\"3XX 重定向\"></a>3XX 重定向</h2><p>3XX响应结果表明浏览器需要执行某些特殊的处理来正确处理请求。</p>\n<h3 id=\"301-Moved-Permanently（永久重定向）\"><a href=\"#301-Moved-Permanently（永久重定向）\" class=\"headerlink\" title=\"301 Moved Permanently（永久重定向）\"></a>301 Moved Permanently（永久重定向）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/301.jpg\" alt=\"\"><br>永久重定向。</p>\n<p>该状态码表示请求的资源被分配了新的URI，以后应使用响应报文头部中Location所指的URI。</p>\n<p>举个例子，如果已经把资源对应的URI保存为书签，这时应该按Location首部字段提示的URI重新保存。</p>\n<h3 id=\"302-Found（找到）\"><a href=\"#302-Found（找到）\" class=\"headerlink\" title=\"302 Found（找到）\"></a>302 Found（找到）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/302.jpg\" alt=\"\"><br>临时重定向。</p>\n<p>该状态码表示请求的资源被分配了新的URI，本次应使用响应报文头部中Location所指的URI。</p>\n<p>举个例子，如果已经把资源对应的URI保存为书签，不需要重新保存。</p>\n<h3 id=\"304-Not-Modified（未修改）\"><a href=\"#304-Not-Modified（未修改）\" class=\"headerlink\" title=\"304 Not Modified（未修改）\"></a>304 Not Modified（未修改）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/304.jpg\" alt=\"\"><br>该状态码表示资源自上次请求以来没有被改变。</p>\n<p>304状态码返回时，不包含任何响应的主体部分。</p>\n<h2 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h2><p>4XX的响应结果表明客户端是发生错误的原因所在。</p>\n<h3 id=\"400-Bad-Request（错误请求）\"><a href=\"#400-Bad-Request（错误请求）\" class=\"headerlink\" title=\"400 Bad Request（错误请求）\"></a>400 Bad Request（错误请求）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/400.jpg\" alt=\"\"><br>该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。</p>\n<h3 id=\"401-Unanthorized（未授权）\"><a href=\"#401-Unanthorized（未授权）\" class=\"headerlink\" title=\"401 Unanthorized（未授权）\"></a>401 Unanthorized（未授权）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/401.jpg\" alt=\"\"><br>该状态码表示发送的请求需要有通过HTTP认证(BASIC认证、DIGEST认证)的认证信息。</p>\n<p>返回401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询(challenge)用户信息。</p>\n<p>浏览器初次接受401响应，会弹出认证用的对话窗口。输入密码、用户名之后会再次请求，此时的请求头中会包含Authorization首部字段，用来说明认证算法、用户和密码。如果授权证书是正确的，服务器就会将文档返回。</p>\n<h3 id=\"403-Forbidden（禁止）\"><a href=\"#403-Forbidden（禁止）\" class=\"headerlink\" title=\"403 Forbidden（禁止）\"></a>403 Forbidden（禁止）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/403.jpg\" alt=\"\"><br>该状态码表明对请求资源的访问被服务器拒绝了。</p>\n<h3 id=\"404-Not-Found（未找到）\"><a href=\"#404-Not-Found（未找到）\" class=\"headerlink\" title=\"404 Not Found（未找到）\"></a>404 Not Found（未找到）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/404.jpg\" alt=\"\"><br>该状态码表示服务器上无法找到请求的资源。除此之外，也可以在服务器拒绝请求且不想说明的理由时使用。</p>\n<h2 id=\"5XX-服务器错误\"><a href=\"#5XX-服务器错误\" class=\"headerlink\" title=\"5XX 服务器错误\"></a>5XX 服务器错误</h2><p>5XX的响应结果表明服务器本身发生错误。</p>\n<h3 id=\"500-Internal-Server-Error（服务器内部错误）\"><a href=\"#500-Internal-Server-Error（服务器内部错误）\" class=\"headerlink\" title=\"500 Internal Server Error（服务器内部错误）\"></a>500 Internal Server Error（服务器内部错误）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/500.jpg\" alt=\"\"><br>该状态码表明服务器在执行请求时发生了错误。也有可能是Web应用存在的bug活某些临时故障。</p>\n<h3 id=\"503-Service-Unavailable（服务不可用）\"><a href=\"#503-Service-Unavailable（服务不可用）\" class=\"headerlink\" title=\"503 Service Unavailable（服务不可用）\"></a>503 Service Unavailable（服务不可用）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/503.jpg\" alt=\"\"><br>该状态码表明服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端，该字段会告知客户端应该在多久之后再次发送请求。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>1.《图解HTTP》<br>2.<a href=\"http://rightyaleft.com/funhumor/http-status-codes-with-meooowwwwww-using-cat-photos/\" target=\"_blank\" rel=\"noopener\">喵星人教你HTTP状态码</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"HTTP学习\"><a href=\"#HTTP学习\" class=\"headerlink\" title=\"HTTP学习\"></a>HTTP学习</h2><p>个人觉得作为一个有理想有抱负的前端工程师HTTP这块的知识是非常有必要掌握的，熟悉了HTTP协议，以后进行调试的时候，才能看明白捕获回来的HTTP请求，并且知道是不是其中某个地方有问题导致出现你想要修复的bug，如何处理能够最终修复这个bug。<br>","more":"</p>\n<h2 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p>\n<p>状态码由3位数字和原因短语组成，数字中第一位指定相应类别，后两位无分类，有以下5中响应类别。</p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th style=\"text-align:left\">类别</th>\n<th style=\"text-align:left\">原因短语</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td style=\"text-align:left\">Informational(信息性状态码)</td>\n<td style=\"text-align:left\">接受的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td style=\"text-align:left\">Success(成功状态码)</td>\n<td style=\"text-align:left\">请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td style=\"text-align:left\">Redirection(重定向状态码)</td>\n<td style=\"text-align:left\">需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td style=\"text-align:left\">Client Error(客户端错误状态码)</td>\n<td style=\"text-align:left\">服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td style=\"text-align:left\">Server Error(服务器错误状态码)</td>\n<td style=\"text-align:left\">服务器处理请求出错</td>\n</tr>\n</tbody>\n</table>\n<p>网上看到HTTP趣味记法。通过ps了一系列的HTTP信息，让人印象深刻。<a href=\"http://rightyaleft.com/funhumor/http-status-codes-with-meooowwwwww-using-cat-photos/\" target=\"_blank\" rel=\"noopener\">原文地址</a><br>原文状态码比较全，这里我只选取了部分比较正常常用的。</p>\n<h2 id=\"2XX-成功\"><a href=\"#2XX-成功\" class=\"headerlink\" title=\"2XX 成功\"></a>2XX 成功</h2><p>2XX的响应结果表明请求被正常处理了。</p>\n<h3 id=\"200-OK\"><a href=\"#200-OK\" class=\"headerlink\" title=\"200 OK\"></a>200 OK</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/200.jpg\" alt=\"\"><br>最常见的“200 OK”表示从客户端发来的请求在服务器端被正常处理了。</p>\n<h3 id=\"204-No-Content（无内容）\"><a href=\"#204-No-Content（无内容）\" class=\"headerlink\" title=\"204 No Content（无内容）\"></a>204 No Content（无内容）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/204.jpg\" alt=\"\"><br>该状态码代表请求已成功被服务器处理，但没有返回任何实体内容。</p>\n<p>例如浏览器发送请求处理后，返回204响应，浏览器显示页面就不发生更新。</p>\n<p>一般只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>\n<h3 id=\"206-Partial-Content（局部内容）\"><a href=\"#206-Partial-Content（局部内容）\" class=\"headerlink\" title=\"206 Partial Content（局部内容）\"></a>206 Partial Content（局部内容）</h3><p>该状态码表示客户端进行请求头中包含Range字段指定范围的请求，服务器端成功执行GET请求，响应报文中包含Content-Range指定范围的实体内容。</p>\n<h2 id=\"3XX-重定向\"><a href=\"#3XX-重定向\" class=\"headerlink\" title=\"3XX 重定向\"></a>3XX 重定向</h2><p>3XX响应结果表明浏览器需要执行某些特殊的处理来正确处理请求。</p>\n<h3 id=\"301-Moved-Permanently（永久重定向）\"><a href=\"#301-Moved-Permanently（永久重定向）\" class=\"headerlink\" title=\"301 Moved Permanently（永久重定向）\"></a>301 Moved Permanently（永久重定向）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/301.jpg\" alt=\"\"><br>永久重定向。</p>\n<p>该状态码表示请求的资源被分配了新的URI，以后应使用响应报文头部中Location所指的URI。</p>\n<p>举个例子，如果已经把资源对应的URI保存为书签，这时应该按Location首部字段提示的URI重新保存。</p>\n<h3 id=\"302-Found（找到）\"><a href=\"#302-Found（找到）\" class=\"headerlink\" title=\"302 Found（找到）\"></a>302 Found（找到）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/302.jpg\" alt=\"\"><br>临时重定向。</p>\n<p>该状态码表示请求的资源被分配了新的URI，本次应使用响应报文头部中Location所指的URI。</p>\n<p>举个例子，如果已经把资源对应的URI保存为书签，不需要重新保存。</p>\n<h3 id=\"304-Not-Modified（未修改）\"><a href=\"#304-Not-Modified（未修改）\" class=\"headerlink\" title=\"304 Not Modified（未修改）\"></a>304 Not Modified（未修改）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/304.jpg\" alt=\"\"><br>该状态码表示资源自上次请求以来没有被改变。</p>\n<p>304状态码返回时，不包含任何响应的主体部分。</p>\n<h2 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h2><p>4XX的响应结果表明客户端是发生错误的原因所在。</p>\n<h3 id=\"400-Bad-Request（错误请求）\"><a href=\"#400-Bad-Request（错误请求）\" class=\"headerlink\" title=\"400 Bad Request（错误请求）\"></a>400 Bad Request（错误请求）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/400.jpg\" alt=\"\"><br>该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。</p>\n<h3 id=\"401-Unanthorized（未授权）\"><a href=\"#401-Unanthorized（未授权）\" class=\"headerlink\" title=\"401 Unanthorized（未授权）\"></a>401 Unanthorized（未授权）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/401.jpg\" alt=\"\"><br>该状态码表示发送的请求需要有通过HTTP认证(BASIC认证、DIGEST认证)的认证信息。</p>\n<p>返回401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询(challenge)用户信息。</p>\n<p>浏览器初次接受401响应，会弹出认证用的对话窗口。输入密码、用户名之后会再次请求，此时的请求头中会包含Authorization首部字段，用来说明认证算法、用户和密码。如果授权证书是正确的，服务器就会将文档返回。</p>\n<h3 id=\"403-Forbidden（禁止）\"><a href=\"#403-Forbidden（禁止）\" class=\"headerlink\" title=\"403 Forbidden（禁止）\"></a>403 Forbidden（禁止）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/403.jpg\" alt=\"\"><br>该状态码表明对请求资源的访问被服务器拒绝了。</p>\n<h3 id=\"404-Not-Found（未找到）\"><a href=\"#404-Not-Found（未找到）\" class=\"headerlink\" title=\"404 Not Found（未找到）\"></a>404 Not Found（未找到）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/404.jpg\" alt=\"\"><br>该状态码表示服务器上无法找到请求的资源。除此之外，也可以在服务器拒绝请求且不想说明的理由时使用。</p>\n<h2 id=\"5XX-服务器错误\"><a href=\"#5XX-服务器错误\" class=\"headerlink\" title=\"5XX 服务器错误\"></a>5XX 服务器错误</h2><p>5XX的响应结果表明服务器本身发生错误。</p>\n<h3 id=\"500-Internal-Server-Error（服务器内部错误）\"><a href=\"#500-Internal-Server-Error（服务器内部错误）\" class=\"headerlink\" title=\"500 Internal Server Error（服务器内部错误）\"></a>500 Internal Server Error（服务器内部错误）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/500.jpg\" alt=\"\"><br>该状态码表明服务器在执行请求时发生了错误。也有可能是Web应用存在的bug活某些临时故障。</p>\n<h3 id=\"503-Service-Unavailable（服务不可用）\"><a href=\"#503-Service-Unavailable（服务不可用）\" class=\"headerlink\" title=\"503 Service Unavailable（服务不可用）\"></a>503 Service Unavailable（服务不可用）</h3><p><img src=\"http://7xsb4y.com1.z0.glb.clouddn.com/503.jpg\" alt=\"\"><br>该状态码表明服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端，该字段会告知客户端应该在多久之后再次发送请求。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>1.《图解HTTP》<br>2.<a href=\"http://rightyaleft.com/funhumor/http-status-codes-with-meooowwwwww-using-cat-photos/\" target=\"_blank\" rel=\"noopener\">喵星人教你HTTP状态码</a></p>"},{"title":"HelloBlog!","date":"2016-04-01T09:18:22.000Z","_content":"终于配置好了Hexo，说难不难，说简单也不简单。按照网上的教程一步一步下来如果顺利的话很简单，但是如果遇到一些版本问题，会有许多坑，让人抓狂。\n<!-- more -->\n说起来早就想写博客了，不过迟迟没有动手。大概是嫌麻烦，也怕自己不能坚持下去。但是我现在觉得搞技术的如果怕麻烦，很难在这领域有所建树。而且通过写博客给自己的生活留下点痕迹，不然就像之前3年大学读下来感觉一片空白，也没啥能够记起来的。\n\n我是学前端开发的，喜欢的是当自己的代码从浏览器展现出来的那种享受。把自己生活学习中的经历通过文字记录在博客上在我看来也极好的。\n\n有些地方还没配置好，先发这篇文章看看效果。\n\n","source":"_posts/HelloBlog.md","raw":"---\ntitle: HelloBlog!\ndate: 2016-04-01 17:18:22\ncategories: \n\t随笔\ntags:\n \tblog\n---\n终于配置好了Hexo，说难不难，说简单也不简单。按照网上的教程一步一步下来如果顺利的话很简单，但是如果遇到一些版本问题，会有许多坑，让人抓狂。\n<!-- more -->\n说起来早就想写博客了，不过迟迟没有动手。大概是嫌麻烦，也怕自己不能坚持下去。但是我现在觉得搞技术的如果怕麻烦，很难在这领域有所建树。而且通过写博客给自己的生活留下点痕迹，不然就像之前3年大学读下来感觉一片空白，也没啥能够记起来的。\n\n我是学前端开发的，喜欢的是当自己的代码从浏览器展现出来的那种享受。把自己生活学习中的经历通过文字记录在博客上在我看来也极好的。\n\n有些地方还没配置好，先发这篇文章看看效果。\n\n","slug":"HelloBlog","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63w40005w9uap8t6uzdo","content":"<p>终于配置好了Hexo，说难不难，说简单也不简单。按照网上的教程一步一步下来如果顺利的话很简单，但是如果遇到一些版本问题，会有许多坑，让人抓狂。<br><a id=\"more\"></a><br>说起来早就想写博客了，不过迟迟没有动手。大概是嫌麻烦，也怕自己不能坚持下去。但是我现在觉得搞技术的如果怕麻烦，很难在这领域有所建树。而且通过写博客给自己的生活留下点痕迹，不然就像之前3年大学读下来感觉一片空白，也没啥能够记起来的。</p>\n<p>我是学前端开发的，喜欢的是当自己的代码从浏览器展现出来的那种享受。把自己生活学习中的经历通过文字记录在博客上在我看来也极好的。</p>\n<p>有些地方还没配置好，先发这篇文章看看效果。</p>\n","site":{"data":{}},"excerpt":"<p>终于配置好了Hexo，说难不难，说简单也不简单。按照网上的教程一步一步下来如果顺利的话很简单，但是如果遇到一些版本问题，会有许多坑，让人抓狂。<br>","more":"<br>说起来早就想写博客了，不过迟迟没有动手。大概是嫌麻烦，也怕自己不能坚持下去。但是我现在觉得搞技术的如果怕麻烦，很难在这领域有所建树。而且通过写博客给自己的生活留下点痕迹，不然就像之前3年大学读下来感觉一片空白，也没啥能够记起来的。</p>\n<p>我是学前端开发的，喜欢的是当自己的代码从浏览器展现出来的那种享受。把自己生活学习中的经历通过文字记录在博客上在我看来也极好的。</p>\n<p>有些地方还没配置好，先发这篇文章看看效果。</p>"},{"title":"I have a dream.","date":"2016-08-11T11:23:37.000Z","_content":"最近老是在做梦，还老是梦见自己去面试什么的。找工作这个心思真的蛮重的。\n<!-- more -->\n突然有个想法，做一个关于梦分享的网站或者app。我们可以在上面记录下自己的梦。我们晚上做梦第二天刚醒来还历历在目，但慢慢就淡忘了，用不了多久就只剩“我昨晚做了个梦，但是梦见什么我忘了”。在我看来，虽然梦是虚幻的，但是它也是一种“经历”，不应该就这么让它白白消失。\n\n当然现在这只是个设想，要实现它还要好好折腾。\n\n之前再看MooTools.js的源码发现自己js那块基础知识有点弱。然后又拿起了那本字典般后的红宝书(js高程)开始看。之前听前辈们说每次看这本书都能有不同体会我起初还不信，但是这次重新开始看了以后，我深有体会。我发现好多之前匆匆瞄过一眼的地方原来暗藏玄机，好多之前搞不懂的地方现在也能想明白了，收获良多。不得不说这真是一本不可多得的前端好书。\n\n八月即将中旬，一大波校招就要来了。好好干！\n","source":"_posts/I-have-a-dream.md","raw":"---\ntitle: I have a dream.\ndate: 2016-08-11 19:23:37\ncategories:\n\t随笔\ntags:\n\t-idea\n\t-红宝书\n---\n最近老是在做梦，还老是梦见自己去面试什么的。找工作这个心思真的蛮重的。\n<!-- more -->\n突然有个想法，做一个关于梦分享的网站或者app。我们可以在上面记录下自己的梦。我们晚上做梦第二天刚醒来还历历在目，但慢慢就淡忘了，用不了多久就只剩“我昨晚做了个梦，但是梦见什么我忘了”。在我看来，虽然梦是虚幻的，但是它也是一种“经历”，不应该就这么让它白白消失。\n\n当然现在这只是个设想，要实现它还要好好折腾。\n\n之前再看MooTools.js的源码发现自己js那块基础知识有点弱。然后又拿起了那本字典般后的红宝书(js高程)开始看。之前听前辈们说每次看这本书都能有不同体会我起初还不信，但是这次重新开始看了以后，我深有体会。我发现好多之前匆匆瞄过一眼的地方原来暗藏玄机，好多之前搞不懂的地方现在也能想明白了，收获良多。不得不说这真是一本不可多得的前端好书。\n\n八月即将中旬，一大波校招就要来了。好好干！\n","slug":"I-have-a-dream","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63w50006w9ua90kxq7jh","content":"<p>最近老是在做梦，还老是梦见自己去面试什么的。找工作这个心思真的蛮重的。<br><a id=\"more\"></a><br>突然有个想法，做一个关于梦分享的网站或者app。我们可以在上面记录下自己的梦。我们晚上做梦第二天刚醒来还历历在目，但慢慢就淡忘了，用不了多久就只剩“我昨晚做了个梦，但是梦见什么我忘了”。在我看来，虽然梦是虚幻的，但是它也是一种“经历”，不应该就这么让它白白消失。</p>\n<p>当然现在这只是个设想，要实现它还要好好折腾。</p>\n<p>之前再看MooTools.js的源码发现自己js那块基础知识有点弱。然后又拿起了那本字典般后的红宝书(js高程)开始看。之前听前辈们说每次看这本书都能有不同体会我起初还不信，但是这次重新开始看了以后，我深有体会。我发现好多之前匆匆瞄过一眼的地方原来暗藏玄机，好多之前搞不懂的地方现在也能想明白了，收获良多。不得不说这真是一本不可多得的前端好书。</p>\n<p>八月即将中旬，一大波校招就要来了。好好干！</p>\n","site":{"data":{}},"excerpt":"<p>最近老是在做梦，还老是梦见自己去面试什么的。找工作这个心思真的蛮重的。<br>","more":"<br>突然有个想法，做一个关于梦分享的网站或者app。我们可以在上面记录下自己的梦。我们晚上做梦第二天刚醒来还历历在目，但慢慢就淡忘了，用不了多久就只剩“我昨晚做了个梦，但是梦见什么我忘了”。在我看来，虽然梦是虚幻的，但是它也是一种“经历”，不应该就这么让它白白消失。</p>\n<p>当然现在这只是个设想，要实现它还要好好折腾。</p>\n<p>之前再看MooTools.js的源码发现自己js那块基础知识有点弱。然后又拿起了那本字典般后的红宝书(js高程)开始看。之前听前辈们说每次看这本书都能有不同体会我起初还不信，但是这次重新开始看了以后，我深有体会。我发现好多之前匆匆瞄过一眼的地方原来暗藏玄机，好多之前搞不懂的地方现在也能想明白了，收获良多。不得不说这真是一本不可多得的前端好书。</p>\n<p>八月即将中旬，一大波校招就要来了。好好干！</p>"},{"title":"JavaScript 作用域变量查询","date":"2016-07-20T07:56:48.000Z","_content":"### 作用域\n作用域是一套用于确定在何处以及如何查找变量的规则。\n<!-- more -->\n### 变量查询\n如果查找的目的是为了对变量进行赋值，则会使用LHS查询；如果查找的目的是为了获取变量的值，则会使用RHS查询。其中“L”和“R”的含义不难猜测，它们分别代表左侧和右侧。换句话说，当变量出现在赋值操作的左边进行LHS查询，出现在右侧时进行RHS查询。\n\n例如代码：\n```javascript\nvar a = 3，\n    b = a;\nconsole.log(a);\n```\n其中对于“var a = 3”js引擎会为等号左边变量a进行LHS查询，试图找到变量的容器本身，从而可以对其赋值；而对于“b = a”中等号右边的变量a则是进行RHS查询，可以理解“取得a的值”，然后赋值给变量b；最后对于“console.log(a)”中对于变量a也是进行RHS查询，并且将得到的值传给console.log(..)执行。\n所以最好将其理解成“给谁进行赋值操作（LHS）”以及“获取谁的值（RHS）”\n### 作用域嵌套\n当一个函数嵌套在另一个函数中时，就会发生作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层作用域（也就是全局作用域）为止。\n### 异常\n区分LHS与RHS是很重要的，因为在变量还没有声明的情况下，这两种查询行为是不一样的。\n考虑如下代码：\n```javascript\nfunction foo(a){\n    console.log(a + b);\n    b = a;\n}\n\nfoo(2);\n```\n在“console.log(a + b)”中第一次对b进行RHS查询是无法找到改变量的。此时b还未声明，浏览器会抛出ReferenceError（引用错误）异常；而在“b = a”中对b执行LHS查询，在全局作用域中也无法找到目标变量，就会创建一个名为b的全局变量，并将其返还给引擎，前提是在非“严格模式”下。如果在“严格模式”下，也会抛出ReferenceError异常。\n### 资料参考\n1.你不知道的JavaScript（上卷）","source":"_posts/JavaScript 作用域变量查询.md","raw":"---\ntitle: JavaScript 作用域变量查询\ndate: 2016-07-20 15:56:48\ncategories:\n JS\ntags:\n - 作用域\n---\n### 作用域\n作用域是一套用于确定在何处以及如何查找变量的规则。\n<!-- more -->\n### 变量查询\n如果查找的目的是为了对变量进行赋值，则会使用LHS查询；如果查找的目的是为了获取变量的值，则会使用RHS查询。其中“L”和“R”的含义不难猜测，它们分别代表左侧和右侧。换句话说，当变量出现在赋值操作的左边进行LHS查询，出现在右侧时进行RHS查询。\n\n例如代码：\n```javascript\nvar a = 3，\n    b = a;\nconsole.log(a);\n```\n其中对于“var a = 3”js引擎会为等号左边变量a进行LHS查询，试图找到变量的容器本身，从而可以对其赋值；而对于“b = a”中等号右边的变量a则是进行RHS查询，可以理解“取得a的值”，然后赋值给变量b；最后对于“console.log(a)”中对于变量a也是进行RHS查询，并且将得到的值传给console.log(..)执行。\n所以最好将其理解成“给谁进行赋值操作（LHS）”以及“获取谁的值（RHS）”\n### 作用域嵌套\n当一个函数嵌套在另一个函数中时，就会发生作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层作用域（也就是全局作用域）为止。\n### 异常\n区分LHS与RHS是很重要的，因为在变量还没有声明的情况下，这两种查询行为是不一样的。\n考虑如下代码：\n```javascript\nfunction foo(a){\n    console.log(a + b);\n    b = a;\n}\n\nfoo(2);\n```\n在“console.log(a + b)”中第一次对b进行RHS查询是无法找到改变量的。此时b还未声明，浏览器会抛出ReferenceError（引用错误）异常；而在“b = a”中对b执行LHS查询，在全局作用域中也无法找到目标变量，就会创建一个名为b的全局变量，并将其返还给引擎，前提是在非“严格模式”下。如果在“严格模式”下，也会抛出ReferenceError异常。\n### 资料参考\n1.你不知道的JavaScript（上卷）","slug":"JavaScript 作用域变量查询","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63w8000aw9uar0jr03is","content":"<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>作用域是一套用于确定在何处以及如何查找变量的规则。<br><a id=\"more\"></a></p>\n<h3 id=\"变量查询\"><a href=\"#变量查询\" class=\"headerlink\" title=\"变量查询\"></a>变量查询</h3><p>如果查找的目的是为了对变量进行赋值，则会使用LHS查询；如果查找的目的是为了获取变量的值，则会使用RHS查询。其中“L”和“R”的含义不难猜测，它们分别代表左侧和右侧。换句话说，当变量出现在赋值操作的左边进行LHS查询，出现在右侧时进行RHS查询。</p>\n<p>例如代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">3</span>，</span><br><span class=\"line\">    b = a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure></p>\n<p>其中对于“var a = 3”js引擎会为等号左边变量a进行LHS查询，试图找到变量的容器本身，从而可以对其赋值；而对于“b = a”中等号右边的变量a则是进行RHS查询，可以理解“取得a的值”，然后赋值给变量b；最后对于“console.log(a)”中对于变量a也是进行RHS查询，并且将得到的值传给console.log(..)执行。<br>所以最好将其理解成“给谁进行赋值操作（LHS）”以及“获取谁的值（RHS）”</p>\n<h3 id=\"作用域嵌套\"><a href=\"#作用域嵌套\" class=\"headerlink\" title=\"作用域嵌套\"></a>作用域嵌套</h3><p>当一个函数嵌套在另一个函数中时，就会发生作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层作用域（也就是全局作用域）为止。</p>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>区分LHS与RHS是很重要的，因为在变量还没有声明的情况下，这两种查询行为是不一样的。<br>考虑如下代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a + b);</span><br><span class=\"line\">    b = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure></p>\n<p>在“console.log(a + b)”中第一次对b进行RHS查询是无法找到改变量的。此时b还未声明，浏览器会抛出ReferenceError（引用错误）异常；而在“b = a”中对b执行LHS查询，在全局作用域中也无法找到目标变量，就会创建一个名为b的全局变量，并将其返还给引擎，前提是在非“严格模式”下。如果在“严格模式”下，也会抛出ReferenceError异常。</p>\n<h3 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h3><p>1.你不知道的JavaScript（上卷）</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>作用域是一套用于确定在何处以及如何查找变量的规则。<br>","more":"</p>\n<h3 id=\"变量查询\"><a href=\"#变量查询\" class=\"headerlink\" title=\"变量查询\"></a>变量查询</h3><p>如果查找的目的是为了对变量进行赋值，则会使用LHS查询；如果查找的目的是为了获取变量的值，则会使用RHS查询。其中“L”和“R”的含义不难猜测，它们分别代表左侧和右侧。换句话说，当变量出现在赋值操作的左边进行LHS查询，出现在右侧时进行RHS查询。</p>\n<p>例如代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">3</span>，</span><br><span class=\"line\">    b = a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure></p>\n<p>其中对于“var a = 3”js引擎会为等号左边变量a进行LHS查询，试图找到变量的容器本身，从而可以对其赋值；而对于“b = a”中等号右边的变量a则是进行RHS查询，可以理解“取得a的值”，然后赋值给变量b；最后对于“console.log(a)”中对于变量a也是进行RHS查询，并且将得到的值传给console.log(..)执行。<br>所以最好将其理解成“给谁进行赋值操作（LHS）”以及“获取谁的值（RHS）”</p>\n<h3 id=\"作用域嵌套\"><a href=\"#作用域嵌套\" class=\"headerlink\" title=\"作用域嵌套\"></a>作用域嵌套</h3><p>当一个函数嵌套在另一个函数中时，就会发生作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层作用域（也就是全局作用域）为止。</p>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>区分LHS与RHS是很重要的，因为在变量还没有声明的情况下，这两种查询行为是不一样的。<br>考虑如下代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a + b);</span><br><span class=\"line\">    b = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure></p>\n<p>在“console.log(a + b)”中第一次对b进行RHS查询是无法找到改变量的。此时b还未声明，浏览器会抛出ReferenceError（引用错误）异常；而在“b = a”中对b执行LHS查询，在全局作用域中也无法找到目标变量，就会创建一个名为b的全局变量，并将其返还给引擎，前提是在非“严格模式”下。如果在“严格模式”下，也会抛出ReferenceError异常。</p>\n<h3 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h3><p>1.你不知道的JavaScript（上卷）</p>"},{"title":"JavaScript 判断数组以及instanceof的局限性","date":"2016-04-23T06:13:52.000Z","_content":"### 检测数组\n说到JavaScript里的数组检测，你也许会马上想到用instanceof判断。的确对于一个网页，或者一个全局作用域而言，使用instanceof操作符 就能得到满意的结果：\n```javascript\nvar arr = [1,2,3];\nconsole.log(arr instanceof Array) //true\n```\n<!-- more -->\n与它类似的还有通过原型链判断数组：\n```javascript\nvar arr = [1,2,3];\nconsole.log(arr.constructor == Array) //true\n```\n用这两种方法来判断数组感觉很美好，但实际上是有漏洞的。\n### 局限性\ninstanceof操作符与constructor属性的问题在于，它们都假定单一的全局执行环境。如果网页中多个框架，那实际上就存在两个以上不同的全局执行环境，从而就存在两个以上版本的Array构造函数。如果arr是另个框架定义的数组，那么上述两种方法就都会返回flase。\n### 手动判断\n在任何值上调用Object原生的toString()方法，都会返回一个[object NativeConstructorName]格式的字符串。由于原生数组的构造函数名与全局作用域无关，因此使用toString()就能保证返回一致的值。通过Object.prototype.toString()和call()取得任何值的内置属性，把类型检测转换成字符串比较，最终达到检测目的。\n```javascript\nfunction isArray(value){    \n return Object.prototype.toString.call(value) == '[object Array]';   \n}\nvar arr = [1,2,3];\nconsole.log(isArray(arr)); //true\n```\n基于该思路同样也可以检测某个值是不是原生函数或正则表达式：\n```javascript\nfunction isFunction(value){    \n return Object.prototype.toString.call(value) == '[object Function]';\n}\nfunction isRegExp(value){    \n return Object.prototype.toString.call(value) == '[object RegExp]';\n}\n```\n### 自动判断\n此外ECMAScript5新增了Array.isArray()方法。这个方法能自动判断某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。IE9+、 Firefox 4+、Safari 5+、Opera10.5+和Chrome都实现了这个方法。但是在IE8之前的版本是不支持的。\n### 资料参考\n1.JavaScript高级程序设计（第3版）\n2.[MDN JavaScript 参考文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)\n\n\n\n\n\n","source":"_posts/JavaScript 判断数组以及instanceof的局限性.md","raw":"---\ntitle: JavaScript 判断数组以及instanceof的局限性\ndate: 2016-04-23 14:13:52\ncategories:\n\tJS\ntags:\n\t- instanceof\n\t- isArray\n---\n### 检测数组\n说到JavaScript里的数组检测，你也许会马上想到用instanceof判断。的确对于一个网页，或者一个全局作用域而言，使用instanceof操作符 就能得到满意的结果：\n```javascript\nvar arr = [1,2,3];\nconsole.log(arr instanceof Array) //true\n```\n<!-- more -->\n与它类似的还有通过原型链判断数组：\n```javascript\nvar arr = [1,2,3];\nconsole.log(arr.constructor == Array) //true\n```\n用这两种方法来判断数组感觉很美好，但实际上是有漏洞的。\n### 局限性\ninstanceof操作符与constructor属性的问题在于，它们都假定单一的全局执行环境。如果网页中多个框架，那实际上就存在两个以上不同的全局执行环境，从而就存在两个以上版本的Array构造函数。如果arr是另个框架定义的数组，那么上述两种方法就都会返回flase。\n### 手动判断\n在任何值上调用Object原生的toString()方法，都会返回一个[object NativeConstructorName]格式的字符串。由于原生数组的构造函数名与全局作用域无关，因此使用toString()就能保证返回一致的值。通过Object.prototype.toString()和call()取得任何值的内置属性，把类型检测转换成字符串比较，最终达到检测目的。\n```javascript\nfunction isArray(value){    \n return Object.prototype.toString.call(value) == '[object Array]';   \n}\nvar arr = [1,2,3];\nconsole.log(isArray(arr)); //true\n```\n基于该思路同样也可以检测某个值是不是原生函数或正则表达式：\n```javascript\nfunction isFunction(value){    \n return Object.prototype.toString.call(value) == '[object Function]';\n}\nfunction isRegExp(value){    \n return Object.prototype.toString.call(value) == '[object RegExp]';\n}\n```\n### 自动判断\n此外ECMAScript5新增了Array.isArray()方法。这个方法能自动判断某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。IE9+、 Firefox 4+、Safari 5+、Opera10.5+和Chrome都实现了这个方法。但是在IE8之前的版本是不支持的。\n### 资料参考\n1.JavaScript高级程序设计（第3版）\n2.[MDN JavaScript 参考文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)\n\n\n\n\n\n","slug":"JavaScript 判断数组以及instanceof的局限性","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63wa000bw9ualdn4qcfb","content":"<h3 id=\"检测数组\"><a href=\"#检测数组\" class=\"headerlink\" title=\"检测数组\"></a>检测数组</h3><p>说到JavaScript里的数组检测，你也许会马上想到用instanceof判断。的确对于一个网页，或者一个全局作用域而言，使用instanceof操作符 就能得到满意的结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>与它类似的还有通过原型链判断数组：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.constructor == <span class=\"built_in\">Array</span>) <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>用这两种方法来判断数组感觉很美好，但实际上是有漏洞的。</p>\n<h3 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h3><p>instanceof操作符与constructor属性的问题在于，它们都假定单一的全局执行环境。如果网页中多个框架，那实际上就存在两个以上不同的全局执行环境，从而就存在两个以上版本的Array构造函数。如果arr是另个框架定义的数组，那么上述两种方法就都会返回flase。</p>\n<h3 id=\"手动判断\"><a href=\"#手动判断\" class=\"headerlink\" title=\"手动判断\"></a>手动判断</h3><p>在任何值上调用Object原生的toString()方法，都会返回一个[object NativeConstructorName]格式的字符串。由于原生数组的构造函数名与全局作用域无关，因此使用toString()就能保证返回一致的值。通过Object.prototype.toString()和call()取得任何值的内置属性，把类型检测转换成字符串比较，最终达到检测目的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">value</span>)</span>&#123;    </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(value) == <span class=\"string\">'[object Array]'</span>;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(isArray(arr)); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>基于该思路同样也可以检测某个值是不是原生函数或正则表达式：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFunction</span>(<span class=\"params\">value</span>)</span>&#123;    </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(value) == <span class=\"string\">'[object Function]'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isRegExp</span>(<span class=\"params\">value</span>)</span>&#123;    </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(value) == <span class=\"string\">'[object RegExp]'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"自动判断\"><a href=\"#自动判断\" class=\"headerlink\" title=\"自动判断\"></a>自动判断</h3><p>此外ECMAScript5新增了Array.isArray()方法。这个方法能自动判断某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。IE9+、 Firefox 4+、Safari 5+、Opera10.5+和Chrome都实现了这个方法。但是在IE8之前的版本是不支持的。</p>\n<h3 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h3><p>1.JavaScript高级程序设计（第3版）<br>2.<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof\" target=\"_blank\" rel=\"noopener\">MDN JavaScript 参考文档</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"检测数组\"><a href=\"#检测数组\" class=\"headerlink\" title=\"检测数组\"></a>检测数组</h3><p>说到JavaScript里的数组检测，你也许会马上想到用instanceof判断。的确对于一个网页，或者一个全局作用域而言，使用instanceof操作符 就能得到满意的结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>","more":"<p>与它类似的还有通过原型链判断数组：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.constructor == <span class=\"built_in\">Array</span>) <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>用这两种方法来判断数组感觉很美好，但实际上是有漏洞的。</p>\n<h3 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h3><p>instanceof操作符与constructor属性的问题在于，它们都假定单一的全局执行环境。如果网页中多个框架，那实际上就存在两个以上不同的全局执行环境，从而就存在两个以上版本的Array构造函数。如果arr是另个框架定义的数组，那么上述两种方法就都会返回flase。</p>\n<h3 id=\"手动判断\"><a href=\"#手动判断\" class=\"headerlink\" title=\"手动判断\"></a>手动判断</h3><p>在任何值上调用Object原生的toString()方法，都会返回一个[object NativeConstructorName]格式的字符串。由于原生数组的构造函数名与全局作用域无关，因此使用toString()就能保证返回一致的值。通过Object.prototype.toString()和call()取得任何值的内置属性，把类型检测转换成字符串比较，最终达到检测目的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">value</span>)</span>&#123;    </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(value) == <span class=\"string\">'[object Array]'</span>;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(isArray(arr)); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>基于该思路同样也可以检测某个值是不是原生函数或正则表达式：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFunction</span>(<span class=\"params\">value</span>)</span>&#123;    </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(value) == <span class=\"string\">'[object Function]'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isRegExp</span>(<span class=\"params\">value</span>)</span>&#123;    </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(value) == <span class=\"string\">'[object RegExp]'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"自动判断\"><a href=\"#自动判断\" class=\"headerlink\" title=\"自动判断\"></a>自动判断</h3><p>此外ECMAScript5新增了Array.isArray()方法。这个方法能自动判断某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。IE9+、 Firefox 4+、Safari 5+、Opera10.5+和Chrome都实现了这个方法。但是在IE8之前的版本是不支持的。</p>\n<h3 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h3><p>1.JavaScript高级程序设计（第3版）<br>2.<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof\" target=\"_blank\" rel=\"noopener\">MDN JavaScript 参考文档</a></p>"},{"title":"postJavaScript Puzzlers 44道令人精分题","date":"2016-09-13T12:37:52.000Z","_content":"最近做了一个一个“44道JavaScript变态题”。都是比较容易答错的点。\n<!-- more -->\n原文地址：[javascript-puzzlers](http://javascript-puzzlers.herokuapp.com/)\n\n真的好变态！做完一遍下来你一定会怀疑人生！相信我！\n\n下面是各题总结：\n## 第1~10题\n### 第1题\n```\n[\"1\", \"2\", \"3\"].map(parseInt)\n```\n是不是觉得是[1,2,3]。不！你错了！答案是[1,NaN,NaN]。\n\n首先map接受两个参数：每一项运行的回调函数callback，该回调函数的this值。\n\n其中回调函数接受三个参数：数组项的值，该项在数组中的索引，数组对象本身。\n\n题中map只传入回调函数parseInt。\n\n而parseInt只接受两个参数：string，radix（基数,或称进制，即表示把string看成多少进制的值）。radix的合法区间是2-36，当不设置radix的值或者设置为0时，默认为10.\n所以本题即为：\n```\nparseInt('1', 0);\nparseInt('2', 1);\nparseInt('3', 2);\n```\n第一个为0被认为是10，而后两个参数不合法。所以答案为[1,NaN,NaN]。\n\n### 第2题\n```\n[typeof null, null instanceof Object]\n```\n答案为[\"object\", false]。\n\n这个没啥好说的 typeof null === \"object\" 这个js就是这么规定。\n\n而null属于原始数据类型，并没有原型对象.\n### 第3题\n```\n[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]\n```\n答案为 an error\n\n这里考的知识点是数组的reduce方法。\n数组的归并方法reduce接受两个参数：一个在每项都调用的回调函数和归并基础的初始值（可选）。\n\n其中回调函数接受四个参数：前一个值、当前值、项的索引和数组对象。\n\n所以第一项等同于 Math.pow(3, 2) ==> 9；Math.pow(9, 1) => 9。\n\n而在没有提供初始值的空数组上执行reduce方法会报TypeError错误\n### 第4题\n```\nvar val = 'smtg';\nconsole.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');\n```\n你以为答案会是“Value is Something”？天真！答案是“Something”。\n\n这里考的知识点是优先级。\n\n“+”操作符的优先级大于三元操作符，所以上面就变成了\n```\n('Value is ' + (val === 'smtg')) ? 'Something' : 'Nothing'\n```\n\n非空字符串对应布尔值为true，所以只输出“Something”！\n### 第5题\n```\nvar name = 'World!';\n(function () {\n    if (typeof name === 'undefined') {\n        var name = 'Jack';\n        console.log('Goodbye ' + name);\n    } else {\n        console.log('Hello ' + name);\n    }\n})();\n```\n答案为“Goodbye Jack”\n\n这里考的知识点是声明提升。\n\nvar声明提升，而初始化不会提升。\n所以就相当于：\n```\nvar name = 'World!';\n(function () {\n    var name;\n    if (typeof name === 'undefined') {\n        name = 'Jack';\n        console.log('Goodbye ' + name);\n    } else {\n        console.log('Hello ' + name);\n    }\n})();\n```\n### 第6题\n```\nvar END = Math.pow(2, 53);\nvar START = END - 100;\nvar count = 0;\nfor (var i = START; i <= END; i++) {\n    count++;\n}\nconsole.log(count);\n\n```\n做这题时，我也是想当然地认为答案是101；而正确答案是程序无限循环。\n\n这里考的知识点是js的数字精度。\n\nJavaScript提供的有效数字的精度为53个二进制位，也就是说，绝对值小于2的53次方的整数，即-(2^53-1)到2^53-1，都可以精确表示。\n\n题中Math.pow(2, 53)表示最大值，最大值加一还是最大值，所以循环不会停，自然也不会输出count的值\n### 第7题\n```\nvar ary = [0,1,2];\nary[10] = 10;\nary.filter(function(x) {\n    return x === undefined;\n});\n```\n答案为 [ ]，而不是[undefined * 7]\n\n这里考的知识点是数组的filter方法。\n\nfilter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。它接受两个参数：一个在每项都调用的回调函数和执行callback时用于this的值（可选）。\n\ncallback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。\n### 第8题\n```\nvar two   = 0.2\nvar one   = 0.1\nvar eight = 0.8\nvar six   = 0.6\n[two - one == one, eight - six == two]\n```\n答案是 [true , false]。\n\n考的知识点是 数字精度计算。\n\n至于什么时候精确什么时候不精确？I don't know.\n\n### 第9题\n```\nfunction showCase(value) {\n    switch(value) {\n    case 'A':\n        console.log('Case A');\n        break;\n    case 'B':\n        console.log('Case B');\n        break;\n    case undefined:\n        console.log('undefined');\n        break;\n    default:\n        console.log('Do not know!');\n    }\n}\nshowCase(new String('A'));\n```\n答案是 'Do not know!'\n\nnew String('A')返回的是String实例，是对象。和字符串'A'不相等。\n### 第10题\n```\nfunction showCase2(value) {\n    switch(value) {\n    case 'A':\n        console.log('Case A');\n        break;\n    case 'B':\n        console.log('Case B');\n        break;\n    case undefined:\n        console.log('undefined');\n        break;\n    default:\n        console.log('Do not know!');\n    }\n}\nshowCase2(String('A'));\n```\n答案是 'Case A'\n\n和上题一样只不过直接调用String()返回的是字符串。\n## 第11~20题\n### 第11题\n```\nfunction isOdd(num) {\n    return num % 2 == 1;\n}\nfunction isEven(num) {\n    return num % 2 == 0;\n}\nfunction isSane(num) {\n    return isEven(num) || isOdd(num);\n}\nvar values = [7, 4, '13', -9, Infinity];\nvalues.map(isSane);\n```\n答案是 [true, true, true, false, false]\n\n前两个没问题，'13'会转换成number类型再运算，余数的正负号随第一个操作数。所以-9 % 2 => -1。而 Infinity % 2 => NaN。\n### 第12题\n```\nparseInt(3, 8)\nparseInt(3, 2)\nparseInt(3, 0)\n```\n答案是 3，NaN，3\n\n参考第一题\n### 第13题\n```\nArray.isArray( Array.prototype )\n```\n答案是 true\n\nArray.prototype => [];\n### 第14题\n```\nvar a = [0];\nif ([0]) {\n  console.log(a == true);\n} else {\n  console.log(\"wut\");\n}\n```\n答案是 false\n\n在if( )判断语句里作为单独的布尔值，是true；\n\n而如果进行比较的话，就是false。\n\n### 第15题\n```\n[]==[]\n```\n答案是 false\n\n数组是引用类型，就算是表面相等的两个数组也不是同一个数组。\n### 第16题\n```\n'5' + 3\n'5' - 3\n```\n答案是 '53', 2\n\n这个很简单，“+” 用来表示两个数的和或者字符串拼接， “-”表示两数之差。\n### 第17题\n```\n1 + - + + + - + 1\n```\n答案是 2\n\n我觉得只要看两数字间“-”的个数，负负得正。\n### 第18题\n```\nvar ary = Array(3);\nary[0]=2\nary.map(function(elem) { return '1'; });\n```\n答案是 [\"1\", undefined × 2]\n\n和第7题类似，map方法和filter方法一样会跳过未被赋值的项。\n### 第19题\n```\nfunction sidEffecting(ary) {\n  ary[0] = ary[2];\n}\nfunction bar(a,b,c) {\n  c = 10\n  sidEffecting(arguments);\n  return a + b + c;\n}\nbar(1,1,1)\n```\n答案是 21\n\n在非严格模式下，修改arguments或修改参数时会互相影响。而在严格模式下arguments是静态副本，和参数不共享相同的值\n### 第20题\n```\nvar a = 111111111111111110000,\n    b = 1111;\na + b;\n```\n答案是 111111111111111110000\n\n大概是111111111111111110000大于js的最大值了，所以加不上？嗯 应该是。\n## 第21~30题\n### 第21题\n```\nvar x = [].reverse;\nx();\n```\n答案是 window\n\n它给的解释是\n\n> [ ].reverse will return this and when invoked without an explicit receiver object it will default to the default this AKA window\n\n也就是说，当没有明确传入this值时，会返回这个调用者。这里在全局调用，所以返回window。\n但我在各个浏览器试了，都没有返回window，而是报错说Array.prototype.reverse 的‘this’ 为空或未定义。\n### 第22题\n```\nNumber.MIN_VALUE > 0\n```\n答案是 true\n\n这里有个坑，Number.MIN_VALUE是大于零最小的数，而不是最小的负数，那个是-Number.MAX_VALUE。\n\n### 第23题\n```\n[1 < 2 < 3, 3 < 2 < 1]\n```\n答案是 [true, true]\n\n所谓的 \"1 < 2 < 3\" 其实先比较 \"1 < 2\" 为true，再比较\" true < 3\",这里true被转换成数字1， 1 < 3 ,所以为true，第二项类似。\n### 第24题\n```\n// the most classic wtf\n2 == [[[2]]]\n```\n答案是 true\n\n我估计是不管嵌套多少层数组，js都会把它转换成包含的第一个数字，例如 [[[21,2]]] => 21 ; [[[[[1],[2],[3]]]]] => 1.\n### 第25题\n```\n3.toString()\n3..toString()\n3...toString()\n```\n答案是 **error  “3”  error**\n\n首先“3.toString()”尽管对于number类型调用方法时会先进行包装，但是这里的点是小数点还是方法调用的点？js会把它认为是小数点，所以结果是“error”\n\n第二个“3..” 第一个点被解释为小数点，变成(3.).toString(),所以结果是“3”\n\n第三个中，第一个点是小数点，第二个点是方法调用的点，但是再后面接个点就成了非法的方法名，于是是“error”\n### 第26题\n```\n(function(){\n  var x = y = 1;\n})();\nconsole.log(y);\nconsole.log(x);\n```\n答案是 **1， error**\n\n原式换个形式：\n```\n(function(){\n  var x;\n  x = 1;\n  y = 1;\n})();\n```\nx为局部变量，在全局环境中无法被访问到，而y被隐式地定义成了全局变量，所以能在全局环境中访问。\n### 第27题\n```\nvar a = /123/,\n    b = /123/;\na == b\na === b\n```\n答案是 **false， false**\n\nJavaScript中的正则表达式是对象，所以尽管a和b看着一样，但是他俩不是同一个对象，不管 “==” 还是 “===” 都是false。\n### 第28题\n```\nvar a = [1, 2, 3],\n    b = [1, 2, 3],\n    c = [1, 2, 4]\na ==  b\na === b\na > c\na < c\n```\n答案是 **false,false,false,true**\n\n首先与上题类似，数组为对象，所以前两个为false\n\n而js里的数组比较大小，类似字符串比较，会从第一个元素开始比较，一个一个比。\n\n### 第29题\n```\nvar a = {}, b = Object.prototype;\n[a.prototype === b, Object.getPrototypeOf(a) === b]\n```\n答案是 **false， true**\n\n原型链的题。主要要搞清除__proto__和prototype的区别。实例对象的__proto__会指向其构造函数的prototype属性（即原型对象）。\n\n这里Object为构造函数，所以b其实为Object的原型对象，使用字面量创建对象和new Object创建对象是一样的，所以a.__proto__也就是Object.prototype。而Object.getPrototypeOf(a)方法是获得a的原型对象，与a.__proto__效果一样。所以第二个为true。\n\n而实例对象a并没有prototype属性，所以a.prototype其实为undefined。\n\n### 第30题\n```\nfunction f() {}\nvar a = f.prototype, b = Object.getPrototypeOf(f);\na === b\n```\n答案是 false\n\n参考上题\n## 第31~40题\n### 第31题\n```\nfunction foo() { }\nvar oldName = foo.name;\nfoo.name = \"bar\";\n[oldName, foo.name]\n```\n答案是 ** “foo”， “foo”**\n\nfunction对象本书的name的属性是只读的不允许更改。\n### 第32题\n```\n\"1 2 3\".replace(/\\d/g, parseInt)\n```\n答案是 **“1 NaN 3”**\n\n与第一题类似，parseInt()传入两个参数：该项的值与该项所在的索引。\n### 第33题\n```\nfunction f() {}\nvar parent = Object.getPrototypeOf(f);\nf.name // ?\nparent.name // ?\ntypeof eval(f.name) // ?\ntypeof eval(parent.name) //  ?\n```\n答案是 **\"f\", \"Empty\", \"function\", undefined**\n\nf.name值为\"f\"，而eval(\"f\")则会输出f函数，所以结果为\"function\".\n\n而parent实际上就是f.__proto__,而函数也是对象，它的原型就是一个名为Empty（空）的function。在全局作用域下调用Empty，显示未定义。\n### 第34题\n```\nvar lowerCaseOnly =  /^[a-z]+$/;\n[lowerCaseOnly.test(null), lowerCaseOnly.test()]\n```\n答案是 **true， true**\n\n这里 test 函数会将参数转为字符串. “null”, “undefined” 自然都是全小写。\n### 第35题\n```\n[,,,].join(\", \")\n```\n答案是 **“, , ”**\n\njs在使用字面量创建数组时，如果末尾有个逗号，会被忽略，所以该数组长度为3，并且时稀疏数组（[undefined × 3]），而对三个元素的数组使用join方法，只需添加两个逗号。\n### 第36题\n```\nvar a = {class: \"Animal\", name: 'Fido'};\na.class\n```\n答案是 **不确定**\n\nclass是保留字，不同浏览器处理方式不同。\n### 第37题\n```\nvar a = new Date(\"epoch\")\n```\n答案是 **“Invalid Date”**\n\n调用 Date 的构造函数传入一个字符串的话需要符合规范, 即满足 Date.parse 的条件.如果格式错误 构造函数返回的仍是一个Date的实例 Invalid Date.\n### 第38题\n```\nvar a = Function.length,\n    b = new Function().length\na === b\n```\n答案是 **false**\n\n首先函数原型对象Function.length定义为1，其次function(Function 的实例)的 length 属性就是函数签名的参数个数, 所以 b.length == 0\n### 第39题\n```\nvar a = Date(0);\nvar b = new Date(0);\nvar c = new Date();\n[a === b, b === c, a === c]\n```\n答案是 **false，false，false**\n\n关于Date类型：\n1.如果不传参数等价于当前时间\n2.如果是函数调用返回一个字符串\n\n所以a为当前时间的字符串，b为1970年的那个初始时间，而c为当前时间。\n\n\n### 第40题\n```\nvar min = Math.min(), max = Math.max()\nmin < max\n```\n答案是 **false**\n\n又是一道“不正常”的题\n\nMath.min不传参数返回“Infinity”，而Math.max不传参数返回“-Infinity”。\n## 第41~44题\n### 第41题\n```\nfunction captureOne(re, str) {\n  var match = re.exec(str);\n  return match && match[1];\n}\nvar numRe  = /num=(\\d+)/ig,\n    wordRe = /word=(\\w+)/i,\n    a1 = captureOne(numRe,  \"num=1\"),\n    a2 = captureOne(wordRe, \"word=1\"),\n    a3 = captureOne(numRe,  \"NUM=2\"),\n    a4 = captureOne(wordRe,  \"WORD=2\");\n[a1 === a2, a3 === a4]\n```\n答案是 **[true, false]**\n\n第一个正则有一个 g 选项 它会‘记忆’他所匹配的内容, 等匹配后他会从上次匹配的索引继续, 即使它们是在不同字符串中使用而第二个正则不会.\n\n所以a1 = a2 = “1”; 而a3 = “null”， a4 = “2”。\n### 第42题\n```\nvar a = new Date(\"2014-03-19\"),\n    b = new Date(2014, 03, 19);\n[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]\n```\n答案是 ** [false, false]**\n\n不懂。\n```\na.getDay() //3\nb.getDay() //6\na.getMonth() //2\nb.getMonth() //3\n```\n### 第43题\n```\nif ('http://giftwrapped.com/picture.jpg'.match('.gif')) {\n  'a gif file'\n} else {\n  'not a gif file'\n}\n```\n答案是 **“a gif file”**\n\n正则表达式中的点号没有被转义导致其被解释成匹配除换行符以外的任意字符。\n### 第44题\n```\nfunction foo(a) {\n    var a;\n    return a;\n}\nfunction bar(a) {\n    var a = 'bye';\n    return a;\n}\n[foo('hello'), bar('hello')]\n```\n答案是 **[“hello”， “bye”]**\n\n两个函数中，a作为参数其实已经被声明了。\n## 总结\n真的好难，如果是第一次做，真的有好多坑。\n\n回头总结，发现好多其实是基础知识，只是平时没注意，理解不够深。\n\n还是得好好看基础。。。。\n","source":"_posts/JavaScript-Puzzlers-44道让人精分的题.md","raw":"---\ntitle: postJavaScript Puzzlers 44道令人精分题\ndate: 2016-09-13 20:37:52\ncategories:\n\tJS\ntags:\n\t- 易错\n\t- 变态\n\t- 44道题\n---\n最近做了一个一个“44道JavaScript变态题”。都是比较容易答错的点。\n<!-- more -->\n原文地址：[javascript-puzzlers](http://javascript-puzzlers.herokuapp.com/)\n\n真的好变态！做完一遍下来你一定会怀疑人生！相信我！\n\n下面是各题总结：\n## 第1~10题\n### 第1题\n```\n[\"1\", \"2\", \"3\"].map(parseInt)\n```\n是不是觉得是[1,2,3]。不！你错了！答案是[1,NaN,NaN]。\n\n首先map接受两个参数：每一项运行的回调函数callback，该回调函数的this值。\n\n其中回调函数接受三个参数：数组项的值，该项在数组中的索引，数组对象本身。\n\n题中map只传入回调函数parseInt。\n\n而parseInt只接受两个参数：string，radix（基数,或称进制，即表示把string看成多少进制的值）。radix的合法区间是2-36，当不设置radix的值或者设置为0时，默认为10.\n所以本题即为：\n```\nparseInt('1', 0);\nparseInt('2', 1);\nparseInt('3', 2);\n```\n第一个为0被认为是10，而后两个参数不合法。所以答案为[1,NaN,NaN]。\n\n### 第2题\n```\n[typeof null, null instanceof Object]\n```\n答案为[\"object\", false]。\n\n这个没啥好说的 typeof null === \"object\" 这个js就是这么规定。\n\n而null属于原始数据类型，并没有原型对象.\n### 第3题\n```\n[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]\n```\n答案为 an error\n\n这里考的知识点是数组的reduce方法。\n数组的归并方法reduce接受两个参数：一个在每项都调用的回调函数和归并基础的初始值（可选）。\n\n其中回调函数接受四个参数：前一个值、当前值、项的索引和数组对象。\n\n所以第一项等同于 Math.pow(3, 2) ==> 9；Math.pow(9, 1) => 9。\n\n而在没有提供初始值的空数组上执行reduce方法会报TypeError错误\n### 第4题\n```\nvar val = 'smtg';\nconsole.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');\n```\n你以为答案会是“Value is Something”？天真！答案是“Something”。\n\n这里考的知识点是优先级。\n\n“+”操作符的优先级大于三元操作符，所以上面就变成了\n```\n('Value is ' + (val === 'smtg')) ? 'Something' : 'Nothing'\n```\n\n非空字符串对应布尔值为true，所以只输出“Something”！\n### 第5题\n```\nvar name = 'World!';\n(function () {\n    if (typeof name === 'undefined') {\n        var name = 'Jack';\n        console.log('Goodbye ' + name);\n    } else {\n        console.log('Hello ' + name);\n    }\n})();\n```\n答案为“Goodbye Jack”\n\n这里考的知识点是声明提升。\n\nvar声明提升，而初始化不会提升。\n所以就相当于：\n```\nvar name = 'World!';\n(function () {\n    var name;\n    if (typeof name === 'undefined') {\n        name = 'Jack';\n        console.log('Goodbye ' + name);\n    } else {\n        console.log('Hello ' + name);\n    }\n})();\n```\n### 第6题\n```\nvar END = Math.pow(2, 53);\nvar START = END - 100;\nvar count = 0;\nfor (var i = START; i <= END; i++) {\n    count++;\n}\nconsole.log(count);\n\n```\n做这题时，我也是想当然地认为答案是101；而正确答案是程序无限循环。\n\n这里考的知识点是js的数字精度。\n\nJavaScript提供的有效数字的精度为53个二进制位，也就是说，绝对值小于2的53次方的整数，即-(2^53-1)到2^53-1，都可以精确表示。\n\n题中Math.pow(2, 53)表示最大值，最大值加一还是最大值，所以循环不会停，自然也不会输出count的值\n### 第7题\n```\nvar ary = [0,1,2];\nary[10] = 10;\nary.filter(function(x) {\n    return x === undefined;\n});\n```\n答案为 [ ]，而不是[undefined * 7]\n\n这里考的知识点是数组的filter方法。\n\nfilter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。它接受两个参数：一个在每项都调用的回调函数和执行callback时用于this的值（可选）。\n\ncallback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。\n### 第8题\n```\nvar two   = 0.2\nvar one   = 0.1\nvar eight = 0.8\nvar six   = 0.6\n[two - one == one, eight - six == two]\n```\n答案是 [true , false]。\n\n考的知识点是 数字精度计算。\n\n至于什么时候精确什么时候不精确？I don't know.\n\n### 第9题\n```\nfunction showCase(value) {\n    switch(value) {\n    case 'A':\n        console.log('Case A');\n        break;\n    case 'B':\n        console.log('Case B');\n        break;\n    case undefined:\n        console.log('undefined');\n        break;\n    default:\n        console.log('Do not know!');\n    }\n}\nshowCase(new String('A'));\n```\n答案是 'Do not know!'\n\nnew String('A')返回的是String实例，是对象。和字符串'A'不相等。\n### 第10题\n```\nfunction showCase2(value) {\n    switch(value) {\n    case 'A':\n        console.log('Case A');\n        break;\n    case 'B':\n        console.log('Case B');\n        break;\n    case undefined:\n        console.log('undefined');\n        break;\n    default:\n        console.log('Do not know!');\n    }\n}\nshowCase2(String('A'));\n```\n答案是 'Case A'\n\n和上题一样只不过直接调用String()返回的是字符串。\n## 第11~20题\n### 第11题\n```\nfunction isOdd(num) {\n    return num % 2 == 1;\n}\nfunction isEven(num) {\n    return num % 2 == 0;\n}\nfunction isSane(num) {\n    return isEven(num) || isOdd(num);\n}\nvar values = [7, 4, '13', -9, Infinity];\nvalues.map(isSane);\n```\n答案是 [true, true, true, false, false]\n\n前两个没问题，'13'会转换成number类型再运算，余数的正负号随第一个操作数。所以-9 % 2 => -1。而 Infinity % 2 => NaN。\n### 第12题\n```\nparseInt(3, 8)\nparseInt(3, 2)\nparseInt(3, 0)\n```\n答案是 3，NaN，3\n\n参考第一题\n### 第13题\n```\nArray.isArray( Array.prototype )\n```\n答案是 true\n\nArray.prototype => [];\n### 第14题\n```\nvar a = [0];\nif ([0]) {\n  console.log(a == true);\n} else {\n  console.log(\"wut\");\n}\n```\n答案是 false\n\n在if( )判断语句里作为单独的布尔值，是true；\n\n而如果进行比较的话，就是false。\n\n### 第15题\n```\n[]==[]\n```\n答案是 false\n\n数组是引用类型，就算是表面相等的两个数组也不是同一个数组。\n### 第16题\n```\n'5' + 3\n'5' - 3\n```\n答案是 '53', 2\n\n这个很简单，“+” 用来表示两个数的和或者字符串拼接， “-”表示两数之差。\n### 第17题\n```\n1 + - + + + - + 1\n```\n答案是 2\n\n我觉得只要看两数字间“-”的个数，负负得正。\n### 第18题\n```\nvar ary = Array(3);\nary[0]=2\nary.map(function(elem) { return '1'; });\n```\n答案是 [\"1\", undefined × 2]\n\n和第7题类似，map方法和filter方法一样会跳过未被赋值的项。\n### 第19题\n```\nfunction sidEffecting(ary) {\n  ary[0] = ary[2];\n}\nfunction bar(a,b,c) {\n  c = 10\n  sidEffecting(arguments);\n  return a + b + c;\n}\nbar(1,1,1)\n```\n答案是 21\n\n在非严格模式下，修改arguments或修改参数时会互相影响。而在严格模式下arguments是静态副本，和参数不共享相同的值\n### 第20题\n```\nvar a = 111111111111111110000,\n    b = 1111;\na + b;\n```\n答案是 111111111111111110000\n\n大概是111111111111111110000大于js的最大值了，所以加不上？嗯 应该是。\n## 第21~30题\n### 第21题\n```\nvar x = [].reverse;\nx();\n```\n答案是 window\n\n它给的解释是\n\n> [ ].reverse will return this and when invoked without an explicit receiver object it will default to the default this AKA window\n\n也就是说，当没有明确传入this值时，会返回这个调用者。这里在全局调用，所以返回window。\n但我在各个浏览器试了，都没有返回window，而是报错说Array.prototype.reverse 的‘this’ 为空或未定义。\n### 第22题\n```\nNumber.MIN_VALUE > 0\n```\n答案是 true\n\n这里有个坑，Number.MIN_VALUE是大于零最小的数，而不是最小的负数，那个是-Number.MAX_VALUE。\n\n### 第23题\n```\n[1 < 2 < 3, 3 < 2 < 1]\n```\n答案是 [true, true]\n\n所谓的 \"1 < 2 < 3\" 其实先比较 \"1 < 2\" 为true，再比较\" true < 3\",这里true被转换成数字1， 1 < 3 ,所以为true，第二项类似。\n### 第24题\n```\n// the most classic wtf\n2 == [[[2]]]\n```\n答案是 true\n\n我估计是不管嵌套多少层数组，js都会把它转换成包含的第一个数字，例如 [[[21,2]]] => 21 ; [[[[[1],[2],[3]]]]] => 1.\n### 第25题\n```\n3.toString()\n3..toString()\n3...toString()\n```\n答案是 **error  “3”  error**\n\n首先“3.toString()”尽管对于number类型调用方法时会先进行包装，但是这里的点是小数点还是方法调用的点？js会把它认为是小数点，所以结果是“error”\n\n第二个“3..” 第一个点被解释为小数点，变成(3.).toString(),所以结果是“3”\n\n第三个中，第一个点是小数点，第二个点是方法调用的点，但是再后面接个点就成了非法的方法名，于是是“error”\n### 第26题\n```\n(function(){\n  var x = y = 1;\n})();\nconsole.log(y);\nconsole.log(x);\n```\n答案是 **1， error**\n\n原式换个形式：\n```\n(function(){\n  var x;\n  x = 1;\n  y = 1;\n})();\n```\nx为局部变量，在全局环境中无法被访问到，而y被隐式地定义成了全局变量，所以能在全局环境中访问。\n### 第27题\n```\nvar a = /123/,\n    b = /123/;\na == b\na === b\n```\n答案是 **false， false**\n\nJavaScript中的正则表达式是对象，所以尽管a和b看着一样，但是他俩不是同一个对象，不管 “==” 还是 “===” 都是false。\n### 第28题\n```\nvar a = [1, 2, 3],\n    b = [1, 2, 3],\n    c = [1, 2, 4]\na ==  b\na === b\na > c\na < c\n```\n答案是 **false,false,false,true**\n\n首先与上题类似，数组为对象，所以前两个为false\n\n而js里的数组比较大小，类似字符串比较，会从第一个元素开始比较，一个一个比。\n\n### 第29题\n```\nvar a = {}, b = Object.prototype;\n[a.prototype === b, Object.getPrototypeOf(a) === b]\n```\n答案是 **false， true**\n\n原型链的题。主要要搞清除__proto__和prototype的区别。实例对象的__proto__会指向其构造函数的prototype属性（即原型对象）。\n\n这里Object为构造函数，所以b其实为Object的原型对象，使用字面量创建对象和new Object创建对象是一样的，所以a.__proto__也就是Object.prototype。而Object.getPrototypeOf(a)方法是获得a的原型对象，与a.__proto__效果一样。所以第二个为true。\n\n而实例对象a并没有prototype属性，所以a.prototype其实为undefined。\n\n### 第30题\n```\nfunction f() {}\nvar a = f.prototype, b = Object.getPrototypeOf(f);\na === b\n```\n答案是 false\n\n参考上题\n## 第31~40题\n### 第31题\n```\nfunction foo() { }\nvar oldName = foo.name;\nfoo.name = \"bar\";\n[oldName, foo.name]\n```\n答案是 ** “foo”， “foo”**\n\nfunction对象本书的name的属性是只读的不允许更改。\n### 第32题\n```\n\"1 2 3\".replace(/\\d/g, parseInt)\n```\n答案是 **“1 NaN 3”**\n\n与第一题类似，parseInt()传入两个参数：该项的值与该项所在的索引。\n### 第33题\n```\nfunction f() {}\nvar parent = Object.getPrototypeOf(f);\nf.name // ?\nparent.name // ?\ntypeof eval(f.name) // ?\ntypeof eval(parent.name) //  ?\n```\n答案是 **\"f\", \"Empty\", \"function\", undefined**\n\nf.name值为\"f\"，而eval(\"f\")则会输出f函数，所以结果为\"function\".\n\n而parent实际上就是f.__proto__,而函数也是对象，它的原型就是一个名为Empty（空）的function。在全局作用域下调用Empty，显示未定义。\n### 第34题\n```\nvar lowerCaseOnly =  /^[a-z]+$/;\n[lowerCaseOnly.test(null), lowerCaseOnly.test()]\n```\n答案是 **true， true**\n\n这里 test 函数会将参数转为字符串. “null”, “undefined” 自然都是全小写。\n### 第35题\n```\n[,,,].join(\", \")\n```\n答案是 **“, , ”**\n\njs在使用字面量创建数组时，如果末尾有个逗号，会被忽略，所以该数组长度为3，并且时稀疏数组（[undefined × 3]），而对三个元素的数组使用join方法，只需添加两个逗号。\n### 第36题\n```\nvar a = {class: \"Animal\", name: 'Fido'};\na.class\n```\n答案是 **不确定**\n\nclass是保留字，不同浏览器处理方式不同。\n### 第37题\n```\nvar a = new Date(\"epoch\")\n```\n答案是 **“Invalid Date”**\n\n调用 Date 的构造函数传入一个字符串的话需要符合规范, 即满足 Date.parse 的条件.如果格式错误 构造函数返回的仍是一个Date的实例 Invalid Date.\n### 第38题\n```\nvar a = Function.length,\n    b = new Function().length\na === b\n```\n答案是 **false**\n\n首先函数原型对象Function.length定义为1，其次function(Function 的实例)的 length 属性就是函数签名的参数个数, 所以 b.length == 0\n### 第39题\n```\nvar a = Date(0);\nvar b = new Date(0);\nvar c = new Date();\n[a === b, b === c, a === c]\n```\n答案是 **false，false，false**\n\n关于Date类型：\n1.如果不传参数等价于当前时间\n2.如果是函数调用返回一个字符串\n\n所以a为当前时间的字符串，b为1970年的那个初始时间，而c为当前时间。\n\n\n### 第40题\n```\nvar min = Math.min(), max = Math.max()\nmin < max\n```\n答案是 **false**\n\n又是一道“不正常”的题\n\nMath.min不传参数返回“Infinity”，而Math.max不传参数返回“-Infinity”。\n## 第41~44题\n### 第41题\n```\nfunction captureOne(re, str) {\n  var match = re.exec(str);\n  return match && match[1];\n}\nvar numRe  = /num=(\\d+)/ig,\n    wordRe = /word=(\\w+)/i,\n    a1 = captureOne(numRe,  \"num=1\"),\n    a2 = captureOne(wordRe, \"word=1\"),\n    a3 = captureOne(numRe,  \"NUM=2\"),\n    a4 = captureOne(wordRe,  \"WORD=2\");\n[a1 === a2, a3 === a4]\n```\n答案是 **[true, false]**\n\n第一个正则有一个 g 选项 它会‘记忆’他所匹配的内容, 等匹配后他会从上次匹配的索引继续, 即使它们是在不同字符串中使用而第二个正则不会.\n\n所以a1 = a2 = “1”; 而a3 = “null”， a4 = “2”。\n### 第42题\n```\nvar a = new Date(\"2014-03-19\"),\n    b = new Date(2014, 03, 19);\n[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]\n```\n答案是 ** [false, false]**\n\n不懂。\n```\na.getDay() //3\nb.getDay() //6\na.getMonth() //2\nb.getMonth() //3\n```\n### 第43题\n```\nif ('http://giftwrapped.com/picture.jpg'.match('.gif')) {\n  'a gif file'\n} else {\n  'not a gif file'\n}\n```\n答案是 **“a gif file”**\n\n正则表达式中的点号没有被转义导致其被解释成匹配除换行符以外的任意字符。\n### 第44题\n```\nfunction foo(a) {\n    var a;\n    return a;\n}\nfunction bar(a) {\n    var a = 'bye';\n    return a;\n}\n[foo('hello'), bar('hello')]\n```\n答案是 **[“hello”， “bye”]**\n\n两个函数中，a作为参数其实已经被声明了。\n## 总结\n真的好难，如果是第一次做，真的有好多坑。\n\n回头总结，发现好多其实是基础知识，只是平时没注意，理解不够深。\n\n还是得好好看基础。。。。\n","slug":"JavaScript-Puzzlers-44道让人精分的题","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63wc000fw9uatdrq7gu6","content":"<p>最近做了一个一个“44道JavaScript变态题”。都是比较容易答错的点。<br><a id=\"more\"></a><br>原文地址：<a href=\"http://javascript-puzzlers.herokuapp.com/\" target=\"_blank\" rel=\"noopener\">javascript-puzzlers</a></p>\n<p>真的好变态！做完一遍下来你一定会怀疑人生！相信我！</p>\n<p>下面是各题总结：</p>\n<h2 id=\"第1-10题\"><a href=\"#第1-10题\" class=\"headerlink\" title=\"第1~10题\"></a>第1~10题</h2><h3 id=\"第1题\"><a href=\"#第1题\" class=\"headerlink\" title=\"第1题\"></a>第1题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt)</span><br></pre></td></tr></table></figure>\n<p>是不是觉得是[1,2,3]。不！你错了！答案是[1,NaN,NaN]。</p>\n<p>首先map接受两个参数：每一项运行的回调函数callback，该回调函数的this值。</p>\n<p>其中回调函数接受三个参数：数组项的值，该项在数组中的索引，数组对象本身。</p>\n<p>题中map只传入回调函数parseInt。</p>\n<p>而parseInt只接受两个参数：string，radix（基数,或称进制，即表示把string看成多少进制的值）。radix的合法区间是2-36，当不设置radix的值或者设置为0时，默认为10.<br>所以本题即为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(&apos;1&apos;, 0);</span><br><span class=\"line\">parseInt(&apos;2&apos;, 1);</span><br><span class=\"line\">parseInt(&apos;3&apos;, 2);</span><br></pre></td></tr></table></figure></p>\n<p>第一个为0被认为是10，而后两个参数不合法。所以答案为[1,NaN,NaN]。</p>\n<h3 id=\"第2题\"><a href=\"#第2题\" class=\"headerlink\" title=\"第2题\"></a>第2题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[typeof null, null instanceof Object]</span><br></pre></td></tr></table></figure>\n<p>答案为[“object”, false]。</p>\n<p>这个没啥好说的 typeof null === “object” 这个js就是这么规定。</p>\n<p>而null属于原始数据类型，并没有原型对象.</p>\n<h3 id=\"第3题\"><a href=\"#第3题\" class=\"headerlink\" title=\"第3题\"></a>第3题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]</span><br></pre></td></tr></table></figure>\n<p>答案为 an error</p>\n<p>这里考的知识点是数组的reduce方法。<br>数组的归并方法reduce接受两个参数：一个在每项都调用的回调函数和归并基础的初始值（可选）。</p>\n<p>其中回调函数接受四个参数：前一个值、当前值、项的索引和数组对象。</p>\n<p>所以第一项等同于 Math.pow(3, 2) ==&gt; 9；Math.pow(9, 1) =&gt; 9。</p>\n<p>而在没有提供初始值的空数组上执行reduce方法会报TypeError错误</p>\n<h3 id=\"第4题\"><a href=\"#第4题\" class=\"headerlink\" title=\"第4题\"></a>第4题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var val = &apos;smtg&apos;;</span><br><span class=\"line\">console.log(&apos;Value is &apos; + (val === &apos;smtg&apos;) ? &apos;Something&apos; : &apos;Nothing&apos;);</span><br></pre></td></tr></table></figure>\n<p>你以为答案会是“Value is Something”？天真！答案是“Something”。</p>\n<p>这里考的知识点是优先级。</p>\n<p>“+”操作符的优先级大于三元操作符，所以上面就变成了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&apos;Value is &apos; + (val === &apos;smtg&apos;)) ? &apos;Something&apos; : &apos;Nothing&apos;</span><br></pre></td></tr></table></figure></p>\n<p>非空字符串对应布尔值为true，所以只输出“Something”！</p>\n<h3 id=\"第5题\"><a href=\"#第5题\" class=\"headerlink\" title=\"第5题\"></a>第5题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &apos;World!&apos;;</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">    if (typeof name === &apos;undefined&apos;) &#123;</span><br><span class=\"line\">        var name = &apos;Jack&apos;;</span><br><span class=\"line\">        console.log(&apos;Goodbye &apos; + name);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        console.log(&apos;Hello &apos; + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>答案为“Goodbye Jack”</p>\n<p>这里考的知识点是声明提升。</p>\n<p>var声明提升，而初始化不会提升。<br>所以就相当于：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &apos;World!&apos;;</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">    var name;</span><br><span class=\"line\">    if (typeof name === &apos;undefined&apos;) &#123;</span><br><span class=\"line\">        name = &apos;Jack&apos;;</span><br><span class=\"line\">        console.log(&apos;Goodbye &apos; + name);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        console.log(&apos;Hello &apos; + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第6题\"><a href=\"#第6题\" class=\"headerlink\" title=\"第6题\"></a>第6题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var END = Math.pow(2, 53);</span><br><span class=\"line\">var START = END - 100;</span><br><span class=\"line\">var count = 0;</span><br><span class=\"line\">for (var i = START; i &lt;= END; i++) &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(count);</span><br></pre></td></tr></table></figure>\n<p>做这题时，我也是想当然地认为答案是101；而正确答案是程序无限循环。</p>\n<p>这里考的知识点是js的数字精度。</p>\n<p>JavaScript提供的有效数字的精度为53个二进制位，也就是说，绝对值小于2的53次方的整数，即-(2^53-1)到2^53-1，都可以精确表示。</p>\n<p>题中Math.pow(2, 53)表示最大值，最大值加一还是最大值，所以循环不会停，自然也不会输出count的值</p>\n<h3 id=\"第7题\"><a href=\"#第7题\" class=\"headerlink\" title=\"第7题\"></a>第7题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ary = [0,1,2];</span><br><span class=\"line\">ary[10] = 10;</span><br><span class=\"line\">ary.filter(function(x) &#123;</span><br><span class=\"line\">    return x === undefined;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>答案为 [ ]，而不是[undefined * 7]</p>\n<p>这里考的知识点是数组的filter方法。</p>\n<p>filter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。它接受两个参数：一个在每项都调用的回调函数和执行callback时用于this的值（可选）。</p>\n<p>callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。</p>\n<h3 id=\"第8题\"><a href=\"#第8题\" class=\"headerlink\" title=\"第8题\"></a>第8题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var two   = 0.2</span><br><span class=\"line\">var one   = 0.1</span><br><span class=\"line\">var eight = 0.8</span><br><span class=\"line\">var six   = 0.6</span><br><span class=\"line\">[two - one == one, eight - six == two]</span><br></pre></td></tr></table></figure>\n<p>答案是 [true , false]。</p>\n<p>考的知识点是 数字精度计算。</p>\n<p>至于什么时候精确什么时候不精确？I don’t know.</p>\n<h3 id=\"第9题\"><a href=\"#第9题\" class=\"headerlink\" title=\"第9题\"></a>第9题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function showCase(value) &#123;</span><br><span class=\"line\">    switch(value) &#123;</span><br><span class=\"line\">    case &apos;A&apos;:</span><br><span class=\"line\">        console.log(&apos;Case A&apos;);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case &apos;B&apos;:</span><br><span class=\"line\">        console.log(&apos;Case B&apos;);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case undefined:</span><br><span class=\"line\">        console.log(&apos;undefined&apos;);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    default:</span><br><span class=\"line\">        console.log(&apos;Do not know!&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">showCase(new String(&apos;A&apos;));</span><br></pre></td></tr></table></figure>\n<p>答案是 ‘Do not know!’</p>\n<p>new String(‘A’)返回的是String实例，是对象。和字符串’A’不相等。</p>\n<h3 id=\"第10题\"><a href=\"#第10题\" class=\"headerlink\" title=\"第10题\"></a>第10题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function showCase2(value) &#123;</span><br><span class=\"line\">    switch(value) &#123;</span><br><span class=\"line\">    case &apos;A&apos;:</span><br><span class=\"line\">        console.log(&apos;Case A&apos;);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case &apos;B&apos;:</span><br><span class=\"line\">        console.log(&apos;Case B&apos;);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case undefined:</span><br><span class=\"line\">        console.log(&apos;undefined&apos;);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    default:</span><br><span class=\"line\">        console.log(&apos;Do not know!&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">showCase2(String(&apos;A&apos;));</span><br></pre></td></tr></table></figure>\n<p>答案是 ‘Case A’</p>\n<p>和上题一样只不过直接调用String()返回的是字符串。</p>\n<h2 id=\"第11-20题\"><a href=\"#第11-20题\" class=\"headerlink\" title=\"第11~20题\"></a>第11~20题</h2><h3 id=\"第11题\"><a href=\"#第11题\" class=\"headerlink\" title=\"第11题\"></a>第11题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isOdd(num) &#123;</span><br><span class=\"line\">    return num % 2 == 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function isEven(num) &#123;</span><br><span class=\"line\">    return num % 2 == 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function isSane(num) &#123;</span><br><span class=\"line\">    return isEven(num) || isOdd(num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var values = [7, 4, &apos;13&apos;, -9, Infinity];</span><br><span class=\"line\">values.map(isSane);</span><br></pre></td></tr></table></figure>\n<p>答案是 [true, true, true, false, false]</p>\n<p>前两个没问题，’13’会转换成number类型再运算，余数的正负号随第一个操作数。所以-9 % 2 =&gt; -1。而 Infinity % 2 =&gt; NaN。</p>\n<h3 id=\"第12题\"><a href=\"#第12题\" class=\"headerlink\" title=\"第12题\"></a>第12题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(3, 8)</span><br><span class=\"line\">parseInt(3, 2)</span><br><span class=\"line\">parseInt(3, 0)</span><br></pre></td></tr></table></figure>\n<p>答案是 3，NaN，3</p>\n<p>参考第一题</p>\n<h3 id=\"第13题\"><a href=\"#第13题\" class=\"headerlink\" title=\"第13题\"></a>第13题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.isArray( Array.prototype )</span><br></pre></td></tr></table></figure>\n<p>答案是 true</p>\n<p>Array.prototype =&gt; [];</p>\n<h3 id=\"第14题\"><a href=\"#第14题\" class=\"headerlink\" title=\"第14题\"></a>第14题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = [0];</span><br><span class=\"line\">if ([0]) &#123;</span><br><span class=\"line\">  console.log(a == true);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  console.log(&quot;wut&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是 false</p>\n<p>在if( )判断语句里作为单独的布尔值，是true；</p>\n<p>而如果进行比较的话，就是false。</p>\n<h3 id=\"第15题\"><a href=\"#第15题\" class=\"headerlink\" title=\"第15题\"></a>第15题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]==[]</span><br></pre></td></tr></table></figure>\n<p>答案是 false</p>\n<p>数组是引用类型，就算是表面相等的两个数组也不是同一个数组。</p>\n<h3 id=\"第16题\"><a href=\"#第16题\" class=\"headerlink\" title=\"第16题\"></a>第16题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;5&apos; + 3</span><br><span class=\"line\">&apos;5&apos; - 3</span><br></pre></td></tr></table></figure>\n<p>答案是 ‘53’, 2</p>\n<p>这个很简单，“+” 用来表示两个数的和或者字符串拼接， “-”表示两数之差。</p>\n<h3 id=\"第17题\"><a href=\"#第17题\" class=\"headerlink\" title=\"第17题\"></a>第17题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 + - + + + - + 1</span><br></pre></td></tr></table></figure>\n<p>答案是 2</p>\n<p>我觉得只要看两数字间“-”的个数，负负得正。</p>\n<h3 id=\"第18题\"><a href=\"#第18题\" class=\"headerlink\" title=\"第18题\"></a>第18题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ary = Array(3);</span><br><span class=\"line\">ary[0]=2</span><br><span class=\"line\">ary.map(function(elem) &#123; return &apos;1&apos;; &#125;);</span><br></pre></td></tr></table></figure>\n<p>答案是 [“1”, undefined × 2]</p>\n<p>和第7题类似，map方法和filter方法一样会跳过未被赋值的项。</p>\n<h3 id=\"第19题\"><a href=\"#第19题\" class=\"headerlink\" title=\"第19题\"></a>第19题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sidEffecting(ary) &#123;</span><br><span class=\"line\">  ary[0] = ary[2];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function bar(a,b,c) &#123;</span><br><span class=\"line\">  c = 10</span><br><span class=\"line\">  sidEffecting(arguments);</span><br><span class=\"line\">  return a + b + c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar(1,1,1)</span><br></pre></td></tr></table></figure>\n<p>答案是 21</p>\n<p>在非严格模式下，修改arguments或修改参数时会互相影响。而在严格模式下arguments是静态副本，和参数不共享相同的值</p>\n<h3 id=\"第20题\"><a href=\"#第20题\" class=\"headerlink\" title=\"第20题\"></a>第20题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 111111111111111110000,</span><br><span class=\"line\">    b = 1111;</span><br><span class=\"line\">a + b;</span><br></pre></td></tr></table></figure>\n<p>答案是 111111111111111110000</p>\n<p>大概是111111111111111110000大于js的最大值了，所以加不上？嗯 应该是。</p>\n<h2 id=\"第21-30题\"><a href=\"#第21-30题\" class=\"headerlink\" title=\"第21~30题\"></a>第21~30题</h2><h3 id=\"第21题\"><a href=\"#第21题\" class=\"headerlink\" title=\"第21题\"></a>第21题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x = [].reverse;</span><br><span class=\"line\">x();</span><br></pre></td></tr></table></figure>\n<p>答案是 window</p>\n<p>它给的解释是</p>\n<blockquote>\n<p>[ ].reverse will return this and when invoked without an explicit receiver object it will default to the default this AKA window</p>\n</blockquote>\n<p>也就是说，当没有明确传入this值时，会返回这个调用者。这里在全局调用，所以返回window。<br>但我在各个浏览器试了，都没有返回window，而是报错说Array.prototype.reverse 的‘this’ 为空或未定义。</p>\n<h3 id=\"第22题\"><a href=\"#第22题\" class=\"headerlink\" title=\"第22题\"></a>第22题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number.MIN_VALUE &gt; 0</span><br></pre></td></tr></table></figure>\n<p>答案是 true</p>\n<p>这里有个坑，Number.MIN_VALUE是大于零最小的数，而不是最小的负数，那个是-Number.MAX_VALUE。</p>\n<h3 id=\"第23题\"><a href=\"#第23题\" class=\"headerlink\" title=\"第23题\"></a>第23题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1]</span><br></pre></td></tr></table></figure>\n<p>答案是 [true, true]</p>\n<p>所谓的 “1 &lt; 2 &lt; 3” 其实先比较 “1 &lt; 2” 为true，再比较” true &lt; 3”,这里true被转换成数字1， 1 &lt; 3 ,所以为true，第二项类似。</p>\n<h3 id=\"第24题\"><a href=\"#第24题\" class=\"headerlink\" title=\"第24题\"></a>第24题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// the most classic wtf</span><br><span class=\"line\">2 == [[[2]]]</span><br></pre></td></tr></table></figure>\n<p>答案是 true</p>\n<p>我估计是不管嵌套多少层数组，js都会把它转换成包含的第一个数字，例如 [[[21,2]]] =&gt; 21 ; [[[[[1],[2],[3]]]]] =&gt; 1.</p>\n<h3 id=\"第25题\"><a href=\"#第25题\" class=\"headerlink\" title=\"第25题\"></a>第25题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3.toString()</span><br><span class=\"line\">3..toString()</span><br><span class=\"line\">3...toString()</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>error  “3”  error</strong></p>\n<p>首先“3.toString()”尽管对于number类型调用方法时会先进行包装，但是这里的点是小数点还是方法调用的点？js会把它认为是小数点，所以结果是“error”</p>\n<p>第二个“3..” 第一个点被解释为小数点，变成(3.).toString(),所以结果是“3”</p>\n<p>第三个中，第一个点是小数点，第二个点是方法调用的点，但是再后面接个点就成了非法的方法名，于是是“error”</p>\n<h3 id=\"第26题\"><a href=\"#第26题\" class=\"headerlink\" title=\"第26题\"></a>第26题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function()&#123;</span><br><span class=\"line\">  var x = y = 1;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">console.log(y);</span><br><span class=\"line\">console.log(x);</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>1， error</strong></p>\n<p>原式换个形式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function()&#123;</span><br><span class=\"line\">  var x;</span><br><span class=\"line\">  x = 1;</span><br><span class=\"line\">  y = 1;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>x为局部变量，在全局环境中无法被访问到，而y被隐式地定义成了全局变量，所以能在全局环境中访问。</p>\n<h3 id=\"第27题\"><a href=\"#第27题\" class=\"headerlink\" title=\"第27题\"></a>第27题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = /123/,</span><br><span class=\"line\">    b = /123/;</span><br><span class=\"line\">a == b</span><br><span class=\"line\">a === b</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>false， false</strong></p>\n<p>JavaScript中的正则表达式是对象，所以尽管a和b看着一样，但是他俩不是同一个对象，不管 “==” 还是 “===” 都是false。</p>\n<h3 id=\"第28题\"><a href=\"#第28题\" class=\"headerlink\" title=\"第28题\"></a>第28题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = [1, 2, 3],</span><br><span class=\"line\">    b = [1, 2, 3],</span><br><span class=\"line\">    c = [1, 2, 4]</span><br><span class=\"line\">a ==  b</span><br><span class=\"line\">a === b</span><br><span class=\"line\">a &gt; c</span><br><span class=\"line\">a &lt; c</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>false,false,false,true</strong></p>\n<p>首先与上题类似，数组为对象，所以前两个为false</p>\n<p>而js里的数组比较大小，类似字符串比较，会从第一个元素开始比较，一个一个比。</p>\n<h3 id=\"第29题\"><a href=\"#第29题\" class=\"headerlink\" title=\"第29题\"></a>第29题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123;&#125;, b = Object.prototype;</span><br><span class=\"line\">[a.prototype === b, Object.getPrototypeOf(a) === b]</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>false， true</strong></p>\n<p>原型链的题。主要要搞清除<strong>proto</strong>和prototype的区别。实例对象的<strong>proto</strong>会指向其构造函数的prototype属性（即原型对象）。</p>\n<p>这里Object为构造函数，所以b其实为Object的原型对象，使用字面量创建对象和new Object创建对象是一样的，所以a.<strong>proto</strong>也就是Object.prototype。而Object.getPrototypeOf(a)方法是获得a的原型对象，与a.<strong>proto</strong>效果一样。所以第二个为true。</p>\n<p>而实例对象a并没有prototype属性，所以a.prototype其实为undefined。</p>\n<h3 id=\"第30题\"><a href=\"#第30题\" class=\"headerlink\" title=\"第30题\"></a>第30题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f() &#123;&#125;</span><br><span class=\"line\">var a = f.prototype, b = Object.getPrototypeOf(f);</span><br><span class=\"line\">a === b</span><br></pre></td></tr></table></figure>\n<p>答案是 false</p>\n<p>参考上题</p>\n<h2 id=\"第31-40题\"><a href=\"#第31-40题\" class=\"headerlink\" title=\"第31~40题\"></a>第31~40题</h2><h3 id=\"第31题\"><a href=\"#第31题\" class=\"headerlink\" title=\"第31题\"></a>第31题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123; &#125;</span><br><span class=\"line\">var oldName = foo.name;</span><br><span class=\"line\">foo.name = &quot;bar&quot;;</span><br><span class=\"line\">[oldName, foo.name]</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong> “foo”， “foo”</strong></p>\n<p>function对象本书的name的属性是只读的不允许更改。</p>\n<h3 id=\"第32题\"><a href=\"#第32题\" class=\"headerlink\" title=\"第32题\"></a>第32题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;1 2 3&quot;.replace(/\\d/g, parseInt)</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>“1 NaN 3”</strong></p>\n<p>与第一题类似，parseInt()传入两个参数：该项的值与该项所在的索引。</p>\n<h3 id=\"第33题\"><a href=\"#第33题\" class=\"headerlink\" title=\"第33题\"></a>第33题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f() &#123;&#125;</span><br><span class=\"line\">var parent = Object.getPrototypeOf(f);</span><br><span class=\"line\">f.name // ?</span><br><span class=\"line\">parent.name // ?</span><br><span class=\"line\">typeof eval(f.name) // ?</span><br><span class=\"line\">typeof eval(parent.name) //  ?</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>“f”, “Empty”, “function”, undefined</strong></p>\n<p>f.name值为”f”，而eval(“f”)则会输出f函数，所以结果为”function”.</p>\n<p>而parent实际上就是f.<strong>proto</strong>,而函数也是对象，它的原型就是一个名为Empty（空）的function。在全局作用域下调用Empty，显示未定义。</p>\n<h3 id=\"第34题\"><a href=\"#第34题\" class=\"headerlink\" title=\"第34题\"></a>第34题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lowerCaseOnly =  /^[a-z]+$/;</span><br><span class=\"line\">[lowerCaseOnly.test(null), lowerCaseOnly.test()]</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>true， true</strong></p>\n<p>这里 test 函数会将参数转为字符串. “null”, “undefined” 自然都是全小写。</p>\n<h3 id=\"第35题\"><a href=\"#第35题\" class=\"headerlink\" title=\"第35题\"></a>第35题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[,,,].join(&quot;, &quot;)</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>“, , ”</strong></p>\n<p>js在使用字面量创建数组时，如果末尾有个逗号，会被忽略，所以该数组长度为3，并且时稀疏数组（[undefined × 3]），而对三个元素的数组使用join方法，只需添加两个逗号。</p>\n<h3 id=\"第36题\"><a href=\"#第36题\" class=\"headerlink\" title=\"第36题\"></a>第36题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123;class: &quot;Animal&quot;, name: &apos;Fido&apos;&#125;;</span><br><span class=\"line\">a.class</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>不确定</strong></p>\n<p>class是保留字，不同浏览器处理方式不同。</p>\n<h3 id=\"第37题\"><a href=\"#第37题\" class=\"headerlink\" title=\"第37题\"></a>第37题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = new Date(&quot;epoch&quot;)</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>“Invalid Date”</strong></p>\n<p>调用 Date 的构造函数传入一个字符串的话需要符合规范, 即满足 Date.parse 的条件.如果格式错误 构造函数返回的仍是一个Date的实例 Invalid Date.</p>\n<h3 id=\"第38题\"><a href=\"#第38题\" class=\"headerlink\" title=\"第38题\"></a>第38题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = Function.length,</span><br><span class=\"line\">    b = new Function().length</span><br><span class=\"line\">a === b</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>false</strong></p>\n<p>首先函数原型对象Function.length定义为1，其次function(Function 的实例)的 length 属性就是函数签名的参数个数, 所以 b.length == 0</p>\n<h3 id=\"第39题\"><a href=\"#第39题\" class=\"headerlink\" title=\"第39题\"></a>第39题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = Date(0);</span><br><span class=\"line\">var b = new Date(0);</span><br><span class=\"line\">var c = new Date();</span><br><span class=\"line\">[a === b, b === c, a === c]</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>false，false，false</strong></p>\n<p>关于Date类型：<br>1.如果不传参数等价于当前时间<br>2.如果是函数调用返回一个字符串</p>\n<p>所以a为当前时间的字符串，b为1970年的那个初始时间，而c为当前时间。</p>\n<h3 id=\"第40题\"><a href=\"#第40题\" class=\"headerlink\" title=\"第40题\"></a>第40题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var min = Math.min(), max = Math.max()</span><br><span class=\"line\">min &lt; max</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>false</strong></p>\n<p>又是一道“不正常”的题</p>\n<p>Math.min不传参数返回“Infinity”，而Math.max不传参数返回“-Infinity”。</p>\n<h2 id=\"第41-44题\"><a href=\"#第41-44题\" class=\"headerlink\" title=\"第41~44题\"></a>第41~44题</h2><h3 id=\"第41题\"><a href=\"#第41题\" class=\"headerlink\" title=\"第41题\"></a>第41题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function captureOne(re, str) &#123;</span><br><span class=\"line\">  var match = re.exec(str);</span><br><span class=\"line\">  return match &amp;&amp; match[1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var numRe  = /num=(\\d+)/ig,</span><br><span class=\"line\">    wordRe = /word=(\\w+)/i,</span><br><span class=\"line\">    a1 = captureOne(numRe,  &quot;num=1&quot;),</span><br><span class=\"line\">    a2 = captureOne(wordRe, &quot;word=1&quot;),</span><br><span class=\"line\">    a3 = captureOne(numRe,  &quot;NUM=2&quot;),</span><br><span class=\"line\">    a4 = captureOne(wordRe,  &quot;WORD=2&quot;);</span><br><span class=\"line\">[a1 === a2, a3 === a4]</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>[true, false]</strong></p>\n<p>第一个正则有一个 g 选项 它会‘记忆’他所匹配的内容, 等匹配后他会从上次匹配的索引继续, 即使它们是在不同字符串中使用而第二个正则不会.</p>\n<p>所以a1 = a2 = “1”; 而a3 = “null”， a4 = “2”。</p>\n<h3 id=\"第42题\"><a href=\"#第42题\" class=\"headerlink\" title=\"第42题\"></a>第42题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = new Date(&quot;2014-03-19&quot;),</span><br><span class=\"line\">    b = new Date(2014, 03, 19);</span><br><span class=\"line\">[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong> [false, false]</strong></p>\n<p>不懂。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.getDay() //3</span><br><span class=\"line\">b.getDay() //6</span><br><span class=\"line\">a.getMonth() //2</span><br><span class=\"line\">b.getMonth() //3</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第43题\"><a href=\"#第43题\" class=\"headerlink\" title=\"第43题\"></a>第43题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (&apos;http://giftwrapped.com/picture.jpg&apos;.match(&apos;.gif&apos;)) &#123;</span><br><span class=\"line\">  &apos;a gif file&apos;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  &apos;not a gif file&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>“a gif file”</strong></p>\n<p>正则表达式中的点号没有被转义导致其被解释成匹配除换行符以外的任意字符。</p>\n<h3 id=\"第44题\"><a href=\"#第44题\" class=\"headerlink\" title=\"第44题\"></a>第44题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(a) &#123;</span><br><span class=\"line\">    var a;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function bar(a) &#123;</span><br><span class=\"line\">    var a = &apos;bye&apos;;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[foo(&apos;hello&apos;), bar(&apos;hello&apos;)]</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>[“hello”， “bye”]</strong></p>\n<p>两个函数中，a作为参数其实已经被声明了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>真的好难，如果是第一次做，真的有好多坑。</p>\n<p>回头总结，发现好多其实是基础知识，只是平时没注意，理解不够深。</p>\n<p>还是得好好看基础。。。。</p>\n","site":{"data":{}},"excerpt":"<p>最近做了一个一个“44道JavaScript变态题”。都是比较容易答错的点。<br>","more":"<br>原文地址：<a href=\"http://javascript-puzzlers.herokuapp.com/\" target=\"_blank\" rel=\"noopener\">javascript-puzzlers</a></p>\n<p>真的好变态！做完一遍下来你一定会怀疑人生！相信我！</p>\n<p>下面是各题总结：</p>\n<h2 id=\"第1-10题\"><a href=\"#第1-10题\" class=\"headerlink\" title=\"第1~10题\"></a>第1~10题</h2><h3 id=\"第1题\"><a href=\"#第1题\" class=\"headerlink\" title=\"第1题\"></a>第1题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt)</span><br></pre></td></tr></table></figure>\n<p>是不是觉得是[1,2,3]。不！你错了！答案是[1,NaN,NaN]。</p>\n<p>首先map接受两个参数：每一项运行的回调函数callback，该回调函数的this值。</p>\n<p>其中回调函数接受三个参数：数组项的值，该项在数组中的索引，数组对象本身。</p>\n<p>题中map只传入回调函数parseInt。</p>\n<p>而parseInt只接受两个参数：string，radix（基数,或称进制，即表示把string看成多少进制的值）。radix的合法区间是2-36，当不设置radix的值或者设置为0时，默认为10.<br>所以本题即为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(&apos;1&apos;, 0);</span><br><span class=\"line\">parseInt(&apos;2&apos;, 1);</span><br><span class=\"line\">parseInt(&apos;3&apos;, 2);</span><br></pre></td></tr></table></figure></p>\n<p>第一个为0被认为是10，而后两个参数不合法。所以答案为[1,NaN,NaN]。</p>\n<h3 id=\"第2题\"><a href=\"#第2题\" class=\"headerlink\" title=\"第2题\"></a>第2题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[typeof null, null instanceof Object]</span><br></pre></td></tr></table></figure>\n<p>答案为[“object”, false]。</p>\n<p>这个没啥好说的 typeof null === “object” 这个js就是这么规定。</p>\n<p>而null属于原始数据类型，并没有原型对象.</p>\n<h3 id=\"第3题\"><a href=\"#第3题\" class=\"headerlink\" title=\"第3题\"></a>第3题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]</span><br></pre></td></tr></table></figure>\n<p>答案为 an error</p>\n<p>这里考的知识点是数组的reduce方法。<br>数组的归并方法reduce接受两个参数：一个在每项都调用的回调函数和归并基础的初始值（可选）。</p>\n<p>其中回调函数接受四个参数：前一个值、当前值、项的索引和数组对象。</p>\n<p>所以第一项等同于 Math.pow(3, 2) ==&gt; 9；Math.pow(9, 1) =&gt; 9。</p>\n<p>而在没有提供初始值的空数组上执行reduce方法会报TypeError错误</p>\n<h3 id=\"第4题\"><a href=\"#第4题\" class=\"headerlink\" title=\"第4题\"></a>第4题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var val = &apos;smtg&apos;;</span><br><span class=\"line\">console.log(&apos;Value is &apos; + (val === &apos;smtg&apos;) ? &apos;Something&apos; : &apos;Nothing&apos;);</span><br></pre></td></tr></table></figure>\n<p>你以为答案会是“Value is Something”？天真！答案是“Something”。</p>\n<p>这里考的知识点是优先级。</p>\n<p>“+”操作符的优先级大于三元操作符，所以上面就变成了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&apos;Value is &apos; + (val === &apos;smtg&apos;)) ? &apos;Something&apos; : &apos;Nothing&apos;</span><br></pre></td></tr></table></figure></p>\n<p>非空字符串对应布尔值为true，所以只输出“Something”！</p>\n<h3 id=\"第5题\"><a href=\"#第5题\" class=\"headerlink\" title=\"第5题\"></a>第5题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &apos;World!&apos;;</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">    if (typeof name === &apos;undefined&apos;) &#123;</span><br><span class=\"line\">        var name = &apos;Jack&apos;;</span><br><span class=\"line\">        console.log(&apos;Goodbye &apos; + name);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        console.log(&apos;Hello &apos; + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>答案为“Goodbye Jack”</p>\n<p>这里考的知识点是声明提升。</p>\n<p>var声明提升，而初始化不会提升。<br>所以就相当于：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &apos;World!&apos;;</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">    var name;</span><br><span class=\"line\">    if (typeof name === &apos;undefined&apos;) &#123;</span><br><span class=\"line\">        name = &apos;Jack&apos;;</span><br><span class=\"line\">        console.log(&apos;Goodbye &apos; + name);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        console.log(&apos;Hello &apos; + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第6题\"><a href=\"#第6题\" class=\"headerlink\" title=\"第6题\"></a>第6题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var END = Math.pow(2, 53);</span><br><span class=\"line\">var START = END - 100;</span><br><span class=\"line\">var count = 0;</span><br><span class=\"line\">for (var i = START; i &lt;= END; i++) &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(count);</span><br></pre></td></tr></table></figure>\n<p>做这题时，我也是想当然地认为答案是101；而正确答案是程序无限循环。</p>\n<p>这里考的知识点是js的数字精度。</p>\n<p>JavaScript提供的有效数字的精度为53个二进制位，也就是说，绝对值小于2的53次方的整数，即-(2^53-1)到2^53-1，都可以精确表示。</p>\n<p>题中Math.pow(2, 53)表示最大值，最大值加一还是最大值，所以循环不会停，自然也不会输出count的值</p>\n<h3 id=\"第7题\"><a href=\"#第7题\" class=\"headerlink\" title=\"第7题\"></a>第7题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ary = [0,1,2];</span><br><span class=\"line\">ary[10] = 10;</span><br><span class=\"line\">ary.filter(function(x) &#123;</span><br><span class=\"line\">    return x === undefined;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>答案为 [ ]，而不是[undefined * 7]</p>\n<p>这里考的知识点是数组的filter方法。</p>\n<p>filter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。它接受两个参数：一个在每项都调用的回调函数和执行callback时用于this的值（可选）。</p>\n<p>callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。</p>\n<h3 id=\"第8题\"><a href=\"#第8题\" class=\"headerlink\" title=\"第8题\"></a>第8题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var two   = 0.2</span><br><span class=\"line\">var one   = 0.1</span><br><span class=\"line\">var eight = 0.8</span><br><span class=\"line\">var six   = 0.6</span><br><span class=\"line\">[two - one == one, eight - six == two]</span><br></pre></td></tr></table></figure>\n<p>答案是 [true , false]。</p>\n<p>考的知识点是 数字精度计算。</p>\n<p>至于什么时候精确什么时候不精确？I don’t know.</p>\n<h3 id=\"第9题\"><a href=\"#第9题\" class=\"headerlink\" title=\"第9题\"></a>第9题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function showCase(value) &#123;</span><br><span class=\"line\">    switch(value) &#123;</span><br><span class=\"line\">    case &apos;A&apos;:</span><br><span class=\"line\">        console.log(&apos;Case A&apos;);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case &apos;B&apos;:</span><br><span class=\"line\">        console.log(&apos;Case B&apos;);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case undefined:</span><br><span class=\"line\">        console.log(&apos;undefined&apos;);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    default:</span><br><span class=\"line\">        console.log(&apos;Do not know!&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">showCase(new String(&apos;A&apos;));</span><br></pre></td></tr></table></figure>\n<p>答案是 ‘Do not know!’</p>\n<p>new String(‘A’)返回的是String实例，是对象。和字符串’A’不相等。</p>\n<h3 id=\"第10题\"><a href=\"#第10题\" class=\"headerlink\" title=\"第10题\"></a>第10题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function showCase2(value) &#123;</span><br><span class=\"line\">    switch(value) &#123;</span><br><span class=\"line\">    case &apos;A&apos;:</span><br><span class=\"line\">        console.log(&apos;Case A&apos;);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case &apos;B&apos;:</span><br><span class=\"line\">        console.log(&apos;Case B&apos;);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case undefined:</span><br><span class=\"line\">        console.log(&apos;undefined&apos;);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    default:</span><br><span class=\"line\">        console.log(&apos;Do not know!&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">showCase2(String(&apos;A&apos;));</span><br></pre></td></tr></table></figure>\n<p>答案是 ‘Case A’</p>\n<p>和上题一样只不过直接调用String()返回的是字符串。</p>\n<h2 id=\"第11-20题\"><a href=\"#第11-20题\" class=\"headerlink\" title=\"第11~20题\"></a>第11~20题</h2><h3 id=\"第11题\"><a href=\"#第11题\" class=\"headerlink\" title=\"第11题\"></a>第11题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isOdd(num) &#123;</span><br><span class=\"line\">    return num % 2 == 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function isEven(num) &#123;</span><br><span class=\"line\">    return num % 2 == 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function isSane(num) &#123;</span><br><span class=\"line\">    return isEven(num) || isOdd(num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var values = [7, 4, &apos;13&apos;, -9, Infinity];</span><br><span class=\"line\">values.map(isSane);</span><br></pre></td></tr></table></figure>\n<p>答案是 [true, true, true, false, false]</p>\n<p>前两个没问题，’13’会转换成number类型再运算，余数的正负号随第一个操作数。所以-9 % 2 =&gt; -1。而 Infinity % 2 =&gt; NaN。</p>\n<h3 id=\"第12题\"><a href=\"#第12题\" class=\"headerlink\" title=\"第12题\"></a>第12题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(3, 8)</span><br><span class=\"line\">parseInt(3, 2)</span><br><span class=\"line\">parseInt(3, 0)</span><br></pre></td></tr></table></figure>\n<p>答案是 3，NaN，3</p>\n<p>参考第一题</p>\n<h3 id=\"第13题\"><a href=\"#第13题\" class=\"headerlink\" title=\"第13题\"></a>第13题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.isArray( Array.prototype )</span><br></pre></td></tr></table></figure>\n<p>答案是 true</p>\n<p>Array.prototype =&gt; [];</p>\n<h3 id=\"第14题\"><a href=\"#第14题\" class=\"headerlink\" title=\"第14题\"></a>第14题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = [0];</span><br><span class=\"line\">if ([0]) &#123;</span><br><span class=\"line\">  console.log(a == true);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  console.log(&quot;wut&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是 false</p>\n<p>在if( )判断语句里作为单独的布尔值，是true；</p>\n<p>而如果进行比较的话，就是false。</p>\n<h3 id=\"第15题\"><a href=\"#第15题\" class=\"headerlink\" title=\"第15题\"></a>第15题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]==[]</span><br></pre></td></tr></table></figure>\n<p>答案是 false</p>\n<p>数组是引用类型，就算是表面相等的两个数组也不是同一个数组。</p>\n<h3 id=\"第16题\"><a href=\"#第16题\" class=\"headerlink\" title=\"第16题\"></a>第16题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;5&apos; + 3</span><br><span class=\"line\">&apos;5&apos; - 3</span><br></pre></td></tr></table></figure>\n<p>答案是 ‘53’, 2</p>\n<p>这个很简单，“+” 用来表示两个数的和或者字符串拼接， “-”表示两数之差。</p>\n<h3 id=\"第17题\"><a href=\"#第17题\" class=\"headerlink\" title=\"第17题\"></a>第17题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 + - + + + - + 1</span><br></pre></td></tr></table></figure>\n<p>答案是 2</p>\n<p>我觉得只要看两数字间“-”的个数，负负得正。</p>\n<h3 id=\"第18题\"><a href=\"#第18题\" class=\"headerlink\" title=\"第18题\"></a>第18题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ary = Array(3);</span><br><span class=\"line\">ary[0]=2</span><br><span class=\"line\">ary.map(function(elem) &#123; return &apos;1&apos;; &#125;);</span><br></pre></td></tr></table></figure>\n<p>答案是 [“1”, undefined × 2]</p>\n<p>和第7题类似，map方法和filter方法一样会跳过未被赋值的项。</p>\n<h3 id=\"第19题\"><a href=\"#第19题\" class=\"headerlink\" title=\"第19题\"></a>第19题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sidEffecting(ary) &#123;</span><br><span class=\"line\">  ary[0] = ary[2];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function bar(a,b,c) &#123;</span><br><span class=\"line\">  c = 10</span><br><span class=\"line\">  sidEffecting(arguments);</span><br><span class=\"line\">  return a + b + c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar(1,1,1)</span><br></pre></td></tr></table></figure>\n<p>答案是 21</p>\n<p>在非严格模式下，修改arguments或修改参数时会互相影响。而在严格模式下arguments是静态副本，和参数不共享相同的值</p>\n<h3 id=\"第20题\"><a href=\"#第20题\" class=\"headerlink\" title=\"第20题\"></a>第20题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 111111111111111110000,</span><br><span class=\"line\">    b = 1111;</span><br><span class=\"line\">a + b;</span><br></pre></td></tr></table></figure>\n<p>答案是 111111111111111110000</p>\n<p>大概是111111111111111110000大于js的最大值了，所以加不上？嗯 应该是。</p>\n<h2 id=\"第21-30题\"><a href=\"#第21-30题\" class=\"headerlink\" title=\"第21~30题\"></a>第21~30题</h2><h3 id=\"第21题\"><a href=\"#第21题\" class=\"headerlink\" title=\"第21题\"></a>第21题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x = [].reverse;</span><br><span class=\"line\">x();</span><br></pre></td></tr></table></figure>\n<p>答案是 window</p>\n<p>它给的解释是</p>\n<blockquote>\n<p>[ ].reverse will return this and when invoked without an explicit receiver object it will default to the default this AKA window</p>\n</blockquote>\n<p>也就是说，当没有明确传入this值时，会返回这个调用者。这里在全局调用，所以返回window。<br>但我在各个浏览器试了，都没有返回window，而是报错说Array.prototype.reverse 的‘this’ 为空或未定义。</p>\n<h3 id=\"第22题\"><a href=\"#第22题\" class=\"headerlink\" title=\"第22题\"></a>第22题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number.MIN_VALUE &gt; 0</span><br></pre></td></tr></table></figure>\n<p>答案是 true</p>\n<p>这里有个坑，Number.MIN_VALUE是大于零最小的数，而不是最小的负数，那个是-Number.MAX_VALUE。</p>\n<h3 id=\"第23题\"><a href=\"#第23题\" class=\"headerlink\" title=\"第23题\"></a>第23题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1]</span><br></pre></td></tr></table></figure>\n<p>答案是 [true, true]</p>\n<p>所谓的 “1 &lt; 2 &lt; 3” 其实先比较 “1 &lt; 2” 为true，再比较” true &lt; 3”,这里true被转换成数字1， 1 &lt; 3 ,所以为true，第二项类似。</p>\n<h3 id=\"第24题\"><a href=\"#第24题\" class=\"headerlink\" title=\"第24题\"></a>第24题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// the most classic wtf</span><br><span class=\"line\">2 == [[[2]]]</span><br></pre></td></tr></table></figure>\n<p>答案是 true</p>\n<p>我估计是不管嵌套多少层数组，js都会把它转换成包含的第一个数字，例如 [[[21,2]]] =&gt; 21 ; [[[[[1],[2],[3]]]]] =&gt; 1.</p>\n<h3 id=\"第25题\"><a href=\"#第25题\" class=\"headerlink\" title=\"第25题\"></a>第25题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3.toString()</span><br><span class=\"line\">3..toString()</span><br><span class=\"line\">3...toString()</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>error  “3”  error</strong></p>\n<p>首先“3.toString()”尽管对于number类型调用方法时会先进行包装，但是这里的点是小数点还是方法调用的点？js会把它认为是小数点，所以结果是“error”</p>\n<p>第二个“3..” 第一个点被解释为小数点，变成(3.).toString(),所以结果是“3”</p>\n<p>第三个中，第一个点是小数点，第二个点是方法调用的点，但是再后面接个点就成了非法的方法名，于是是“error”</p>\n<h3 id=\"第26题\"><a href=\"#第26题\" class=\"headerlink\" title=\"第26题\"></a>第26题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function()&#123;</span><br><span class=\"line\">  var x = y = 1;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">console.log(y);</span><br><span class=\"line\">console.log(x);</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>1， error</strong></p>\n<p>原式换个形式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function()&#123;</span><br><span class=\"line\">  var x;</span><br><span class=\"line\">  x = 1;</span><br><span class=\"line\">  y = 1;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>x为局部变量，在全局环境中无法被访问到，而y被隐式地定义成了全局变量，所以能在全局环境中访问。</p>\n<h3 id=\"第27题\"><a href=\"#第27题\" class=\"headerlink\" title=\"第27题\"></a>第27题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = /123/,</span><br><span class=\"line\">    b = /123/;</span><br><span class=\"line\">a == b</span><br><span class=\"line\">a === b</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>false， false</strong></p>\n<p>JavaScript中的正则表达式是对象，所以尽管a和b看着一样，但是他俩不是同一个对象，不管 “==” 还是 “===” 都是false。</p>\n<h3 id=\"第28题\"><a href=\"#第28题\" class=\"headerlink\" title=\"第28题\"></a>第28题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = [1, 2, 3],</span><br><span class=\"line\">    b = [1, 2, 3],</span><br><span class=\"line\">    c = [1, 2, 4]</span><br><span class=\"line\">a ==  b</span><br><span class=\"line\">a === b</span><br><span class=\"line\">a &gt; c</span><br><span class=\"line\">a &lt; c</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>false,false,false,true</strong></p>\n<p>首先与上题类似，数组为对象，所以前两个为false</p>\n<p>而js里的数组比较大小，类似字符串比较，会从第一个元素开始比较，一个一个比。</p>\n<h3 id=\"第29题\"><a href=\"#第29题\" class=\"headerlink\" title=\"第29题\"></a>第29题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123;&#125;, b = Object.prototype;</span><br><span class=\"line\">[a.prototype === b, Object.getPrototypeOf(a) === b]</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>false， true</strong></p>\n<p>原型链的题。主要要搞清除<strong>proto</strong>和prototype的区别。实例对象的<strong>proto</strong>会指向其构造函数的prototype属性（即原型对象）。</p>\n<p>这里Object为构造函数，所以b其实为Object的原型对象，使用字面量创建对象和new Object创建对象是一样的，所以a.<strong>proto</strong>也就是Object.prototype。而Object.getPrototypeOf(a)方法是获得a的原型对象，与a.<strong>proto</strong>效果一样。所以第二个为true。</p>\n<p>而实例对象a并没有prototype属性，所以a.prototype其实为undefined。</p>\n<h3 id=\"第30题\"><a href=\"#第30题\" class=\"headerlink\" title=\"第30题\"></a>第30题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f() &#123;&#125;</span><br><span class=\"line\">var a = f.prototype, b = Object.getPrototypeOf(f);</span><br><span class=\"line\">a === b</span><br></pre></td></tr></table></figure>\n<p>答案是 false</p>\n<p>参考上题</p>\n<h2 id=\"第31-40题\"><a href=\"#第31-40题\" class=\"headerlink\" title=\"第31~40题\"></a>第31~40题</h2><h3 id=\"第31题\"><a href=\"#第31题\" class=\"headerlink\" title=\"第31题\"></a>第31题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123; &#125;</span><br><span class=\"line\">var oldName = foo.name;</span><br><span class=\"line\">foo.name = &quot;bar&quot;;</span><br><span class=\"line\">[oldName, foo.name]</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong> “foo”， “foo”</strong></p>\n<p>function对象本书的name的属性是只读的不允许更改。</p>\n<h3 id=\"第32题\"><a href=\"#第32题\" class=\"headerlink\" title=\"第32题\"></a>第32题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;1 2 3&quot;.replace(/\\d/g, parseInt)</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>“1 NaN 3”</strong></p>\n<p>与第一题类似，parseInt()传入两个参数：该项的值与该项所在的索引。</p>\n<h3 id=\"第33题\"><a href=\"#第33题\" class=\"headerlink\" title=\"第33题\"></a>第33题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f() &#123;&#125;</span><br><span class=\"line\">var parent = Object.getPrototypeOf(f);</span><br><span class=\"line\">f.name // ?</span><br><span class=\"line\">parent.name // ?</span><br><span class=\"line\">typeof eval(f.name) // ?</span><br><span class=\"line\">typeof eval(parent.name) //  ?</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>“f”, “Empty”, “function”, undefined</strong></p>\n<p>f.name值为”f”，而eval(“f”)则会输出f函数，所以结果为”function”.</p>\n<p>而parent实际上就是f.<strong>proto</strong>,而函数也是对象，它的原型就是一个名为Empty（空）的function。在全局作用域下调用Empty，显示未定义。</p>\n<h3 id=\"第34题\"><a href=\"#第34题\" class=\"headerlink\" title=\"第34题\"></a>第34题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lowerCaseOnly =  /^[a-z]+$/;</span><br><span class=\"line\">[lowerCaseOnly.test(null), lowerCaseOnly.test()]</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>true， true</strong></p>\n<p>这里 test 函数会将参数转为字符串. “null”, “undefined” 自然都是全小写。</p>\n<h3 id=\"第35题\"><a href=\"#第35题\" class=\"headerlink\" title=\"第35题\"></a>第35题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[,,,].join(&quot;, &quot;)</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>“, , ”</strong></p>\n<p>js在使用字面量创建数组时，如果末尾有个逗号，会被忽略，所以该数组长度为3，并且时稀疏数组（[undefined × 3]），而对三个元素的数组使用join方法，只需添加两个逗号。</p>\n<h3 id=\"第36题\"><a href=\"#第36题\" class=\"headerlink\" title=\"第36题\"></a>第36题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123;class: &quot;Animal&quot;, name: &apos;Fido&apos;&#125;;</span><br><span class=\"line\">a.class</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>不确定</strong></p>\n<p>class是保留字，不同浏览器处理方式不同。</p>\n<h3 id=\"第37题\"><a href=\"#第37题\" class=\"headerlink\" title=\"第37题\"></a>第37题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = new Date(&quot;epoch&quot;)</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>“Invalid Date”</strong></p>\n<p>调用 Date 的构造函数传入一个字符串的话需要符合规范, 即满足 Date.parse 的条件.如果格式错误 构造函数返回的仍是一个Date的实例 Invalid Date.</p>\n<h3 id=\"第38题\"><a href=\"#第38题\" class=\"headerlink\" title=\"第38题\"></a>第38题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = Function.length,</span><br><span class=\"line\">    b = new Function().length</span><br><span class=\"line\">a === b</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>false</strong></p>\n<p>首先函数原型对象Function.length定义为1，其次function(Function 的实例)的 length 属性就是函数签名的参数个数, 所以 b.length == 0</p>\n<h3 id=\"第39题\"><a href=\"#第39题\" class=\"headerlink\" title=\"第39题\"></a>第39题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = Date(0);</span><br><span class=\"line\">var b = new Date(0);</span><br><span class=\"line\">var c = new Date();</span><br><span class=\"line\">[a === b, b === c, a === c]</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>false，false，false</strong></p>\n<p>关于Date类型：<br>1.如果不传参数等价于当前时间<br>2.如果是函数调用返回一个字符串</p>\n<p>所以a为当前时间的字符串，b为1970年的那个初始时间，而c为当前时间。</p>\n<h3 id=\"第40题\"><a href=\"#第40题\" class=\"headerlink\" title=\"第40题\"></a>第40题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var min = Math.min(), max = Math.max()</span><br><span class=\"line\">min &lt; max</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>false</strong></p>\n<p>又是一道“不正常”的题</p>\n<p>Math.min不传参数返回“Infinity”，而Math.max不传参数返回“-Infinity”。</p>\n<h2 id=\"第41-44题\"><a href=\"#第41-44题\" class=\"headerlink\" title=\"第41~44题\"></a>第41~44题</h2><h3 id=\"第41题\"><a href=\"#第41题\" class=\"headerlink\" title=\"第41题\"></a>第41题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function captureOne(re, str) &#123;</span><br><span class=\"line\">  var match = re.exec(str);</span><br><span class=\"line\">  return match &amp;&amp; match[1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var numRe  = /num=(\\d+)/ig,</span><br><span class=\"line\">    wordRe = /word=(\\w+)/i,</span><br><span class=\"line\">    a1 = captureOne(numRe,  &quot;num=1&quot;),</span><br><span class=\"line\">    a2 = captureOne(wordRe, &quot;word=1&quot;),</span><br><span class=\"line\">    a3 = captureOne(numRe,  &quot;NUM=2&quot;),</span><br><span class=\"line\">    a4 = captureOne(wordRe,  &quot;WORD=2&quot;);</span><br><span class=\"line\">[a1 === a2, a3 === a4]</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>[true, false]</strong></p>\n<p>第一个正则有一个 g 选项 它会‘记忆’他所匹配的内容, 等匹配后他会从上次匹配的索引继续, 即使它们是在不同字符串中使用而第二个正则不会.</p>\n<p>所以a1 = a2 = “1”; 而a3 = “null”， a4 = “2”。</p>\n<h3 id=\"第42题\"><a href=\"#第42题\" class=\"headerlink\" title=\"第42题\"></a>第42题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = new Date(&quot;2014-03-19&quot;),</span><br><span class=\"line\">    b = new Date(2014, 03, 19);</span><br><span class=\"line\">[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong> [false, false]</strong></p>\n<p>不懂。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.getDay() //3</span><br><span class=\"line\">b.getDay() //6</span><br><span class=\"line\">a.getMonth() //2</span><br><span class=\"line\">b.getMonth() //3</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第43题\"><a href=\"#第43题\" class=\"headerlink\" title=\"第43题\"></a>第43题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (&apos;http://giftwrapped.com/picture.jpg&apos;.match(&apos;.gif&apos;)) &#123;</span><br><span class=\"line\">  &apos;a gif file&apos;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  &apos;not a gif file&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>“a gif file”</strong></p>\n<p>正则表达式中的点号没有被转义导致其被解释成匹配除换行符以外的任意字符。</p>\n<h3 id=\"第44题\"><a href=\"#第44题\" class=\"headerlink\" title=\"第44题\"></a>第44题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(a) &#123;</span><br><span class=\"line\">    var a;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function bar(a) &#123;</span><br><span class=\"line\">    var a = &apos;bye&apos;;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[foo(&apos;hello&apos;), bar(&apos;hello&apos;)]</span><br></pre></td></tr></table></figure>\n<p>答案是 <strong>[“hello”， “bye”]</strong></p>\n<p>两个函数中，a作为参数其实已经被声明了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>真的好难，如果是第一次做，真的有好多坑。</p>\n<p>回头总结，发现好多其实是基础知识，只是平时没注意，理解不够深。</p>\n<p>还是得好好看基础。。。。</p>"},{"title":"JavaScript 关于this","date":"2016-07-23T07:15:29.000Z","_content":"## 关于this\n为什么要用this？当然是因为使用它更方便，更优雅啊。不然谁吃饱了撑着花这么多时间去理解这么复杂的玩意！this提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将API设计的更加简洁并且易于复用。\n<!-- more -->\n学习this首先要明白this既不指向函数自身也不指向函数的词法作用域。而且this的绑定实际上是在函数被调用时发生的，它的指向完全取决于函数在哪里被调用。\n## 绑定规则\n如何判断一个运行中函数的this绑定，就需要先找到这个函数的具体调用位置，然后根据绑定规则来判断this的绑定对象。绑定规则有默认绑定、隐式绑定、显示绑定和new绑定。\n\n### 默认绑定\n纯粹的函数调用，直接使用不带任何修饰的函数引用进行调用。此时this就指向全局对象。\n例如：\n```javascript\nfunction foo(){\n    console.log(this.a);\n}\nvar a = 2;\nfoo();  // 2\n```\n函数foo()调用时应用了this的默认绑定，因此this绑定的全局对象。\n> 注意： 如果使用严格模式，则不能将全局对象用于默认绑定，因此this会绑定到undefined。\n\n### 隐式绑定\n当函数作为某个对象的方法被调用时，此时this被绑定到这个上下文对象上。\n例如：\n```javascript\nfunction foo(){\n    console.log(this.a);\n}\nvar obj = {\n    a: 2,\n    foo: foo\n};\nobj.foo();  // 2\n```\n当foo()被调用时，它前面加上了对obj的引用。即实际上是调用了obj对象的foo()方法。此时this被绑定到obj，因此this.a和obj.a是一样的。\n\n如果被隐式绑定的函数丢失了绑定对象，就会应用默认绑定，从而把this绑定到全局对象或者undefin上，取决于是否为严格模式。\n例如上述例子：\n```javascript\nvar bar = obj.foo;\nvar a = \"global\";\nbar();  // \"global\"\n```\n这里的bar实际上引用的是foo函数本身，所以此时bar()其实是不带任何修饰的函数调用，因此应用了默认绑定。同理回调函数也是会丢失this绑定。\n### 显式绑定\n在隐式绑定中，我们必须设置一个对象的内部方法指向所要执行的函数，并通过这个方法间接引用该函数，从而把this隐式绑定到这个对象上。\n而在显示绑定中，我们只需要通过apply()和call()方法直接在某个对象上强制调用所要执行的函数。\n这两个方法的第一个参数是一个对象(参数为空时，默认调用全局对象)，是为this准备的，接着在调用函数时将其绑定给this。由于可以直接制定this的绑定对象，故称之为显式绑定。\n例如：\n```javascript\nfunction foo(){\n    console.log(this.a);\n}\nvar obj = {\n    a: 2\n};\nfoo.call(obj);  // 2\n```\n通过foo.call(...),在调用foo函数时强制把它的this绑定到obj上。\n\n### new绑定\n使用new来调用函数，即构造函数调用，创建一个新对象，此时，this就指向这个新对象。\n例如：\n```javascript\nfunction foo(a){\n    this.a = a;\n}\nvar bar = new foo(2);\nconsole.log(bar.a);  // 2\n```\n### 判断this绑定对象\n综上所述，如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置。找到后按顺序通过下面四条规则来判定this的绑定对象。\n\n 1. 是否由new调用？绑定到新创建的对象上。\n 2. 是否由apply或者call调用？绑定到指定对象是。\n 3. 是否作为上下文对象方法调用？绑定到那个上下文对象。\n 4. 默认：在严格模式下绑定undefined，否则绑定的全局对象。\n\n## 箭头函数\nES6中介绍了一种无法使用以上规则的特殊函数类型：箭头函数。\n箭头函数并不是用function关键字定义的，而是使用操作符“=>”定义的，其this指向根据当前词法作用域来决定的。\n例如：\n```javascript\nfunction foo(){\n    return (a) => {\n        console.log(this.a);\n    };\n}\nvar obj1 = {\n    a: 2\n};\nvar obj2 = {\n    a: 3\n};\nvar bar = foo.call(obj1);\nbar.call(obj2);  // 2\n```\nfoo()内部创建的箭头函数会捕获调用foo()时的this，由于foo()的this绑定到obj1，所以箭头函数的this也会绑定到obj1。此外，箭头函数的绑定无法被修改。(new也不行)\n\n## 资料参考\n1.你不知道的JavaScript（上卷）\n","source":"_posts/JavaScript-关于this.md","raw":"---\ntitle: JavaScript 关于this\ndate: 2016-07-23 15:15:29\ncategories:\n\tJS\ntags:\n\t- this\n---\n## 关于this\n为什么要用this？当然是因为使用它更方便，更优雅啊。不然谁吃饱了撑着花这么多时间去理解这么复杂的玩意！this提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将API设计的更加简洁并且易于复用。\n<!-- more -->\n学习this首先要明白this既不指向函数自身也不指向函数的词法作用域。而且this的绑定实际上是在函数被调用时发生的，它的指向完全取决于函数在哪里被调用。\n## 绑定规则\n如何判断一个运行中函数的this绑定，就需要先找到这个函数的具体调用位置，然后根据绑定规则来判断this的绑定对象。绑定规则有默认绑定、隐式绑定、显示绑定和new绑定。\n\n### 默认绑定\n纯粹的函数调用，直接使用不带任何修饰的函数引用进行调用。此时this就指向全局对象。\n例如：\n```javascript\nfunction foo(){\n    console.log(this.a);\n}\nvar a = 2;\nfoo();  // 2\n```\n函数foo()调用时应用了this的默认绑定，因此this绑定的全局对象。\n> 注意： 如果使用严格模式，则不能将全局对象用于默认绑定，因此this会绑定到undefined。\n\n### 隐式绑定\n当函数作为某个对象的方法被调用时，此时this被绑定到这个上下文对象上。\n例如：\n```javascript\nfunction foo(){\n    console.log(this.a);\n}\nvar obj = {\n    a: 2,\n    foo: foo\n};\nobj.foo();  // 2\n```\n当foo()被调用时，它前面加上了对obj的引用。即实际上是调用了obj对象的foo()方法。此时this被绑定到obj，因此this.a和obj.a是一样的。\n\n如果被隐式绑定的函数丢失了绑定对象，就会应用默认绑定，从而把this绑定到全局对象或者undefin上，取决于是否为严格模式。\n例如上述例子：\n```javascript\nvar bar = obj.foo;\nvar a = \"global\";\nbar();  // \"global\"\n```\n这里的bar实际上引用的是foo函数本身，所以此时bar()其实是不带任何修饰的函数调用，因此应用了默认绑定。同理回调函数也是会丢失this绑定。\n### 显式绑定\n在隐式绑定中，我们必须设置一个对象的内部方法指向所要执行的函数，并通过这个方法间接引用该函数，从而把this隐式绑定到这个对象上。\n而在显示绑定中，我们只需要通过apply()和call()方法直接在某个对象上强制调用所要执行的函数。\n这两个方法的第一个参数是一个对象(参数为空时，默认调用全局对象)，是为this准备的，接着在调用函数时将其绑定给this。由于可以直接制定this的绑定对象，故称之为显式绑定。\n例如：\n```javascript\nfunction foo(){\n    console.log(this.a);\n}\nvar obj = {\n    a: 2\n};\nfoo.call(obj);  // 2\n```\n通过foo.call(...),在调用foo函数时强制把它的this绑定到obj上。\n\n### new绑定\n使用new来调用函数，即构造函数调用，创建一个新对象，此时，this就指向这个新对象。\n例如：\n```javascript\nfunction foo(a){\n    this.a = a;\n}\nvar bar = new foo(2);\nconsole.log(bar.a);  // 2\n```\n### 判断this绑定对象\n综上所述，如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置。找到后按顺序通过下面四条规则来判定this的绑定对象。\n\n 1. 是否由new调用？绑定到新创建的对象上。\n 2. 是否由apply或者call调用？绑定到指定对象是。\n 3. 是否作为上下文对象方法调用？绑定到那个上下文对象。\n 4. 默认：在严格模式下绑定undefined，否则绑定的全局对象。\n\n## 箭头函数\nES6中介绍了一种无法使用以上规则的特殊函数类型：箭头函数。\n箭头函数并不是用function关键字定义的，而是使用操作符“=>”定义的，其this指向根据当前词法作用域来决定的。\n例如：\n```javascript\nfunction foo(){\n    return (a) => {\n        console.log(this.a);\n    };\n}\nvar obj1 = {\n    a: 2\n};\nvar obj2 = {\n    a: 3\n};\nvar bar = foo.call(obj1);\nbar.call(obj2);  // 2\n```\nfoo()内部创建的箭头函数会捕获调用foo()时的this，由于foo()的this绑定到obj1，所以箭头函数的this也会绑定到obj1。此外，箭头函数的绑定无法被修改。(new也不行)\n\n## 资料参考\n1.你不知道的JavaScript（上卷）\n","slug":"JavaScript-关于this","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63wd000gw9ua50bciijn","content":"<h2 id=\"关于this\"><a href=\"#关于this\" class=\"headerlink\" title=\"关于this\"></a>关于this</h2><p>为什么要用this？当然是因为使用它更方便，更优雅啊。不然谁吃饱了撑着花这么多时间去理解这么复杂的玩意！this提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将API设计的更加简洁并且易于复用。<br><a id=\"more\"></a><br>学习this首先要明白this既不指向函数自身也不指向函数的词法作用域。而且this的绑定实际上是在函数被调用时发生的，它的指向完全取决于函数在哪里被调用。</p>\n<h2 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a>绑定规则</h2><p>如何判断一个运行中函数的this绑定，就需要先找到这个函数的具体调用位置，然后根据绑定规则来判断this的绑定对象。绑定规则有默认绑定、隐式绑定、显示绑定和new绑定。</p>\n<h3 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h3><p>纯粹的函数调用，直接使用不带任何修饰的函数引用进行调用。此时this就指向全局对象。<br>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo();  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>函数foo()调用时应用了this的默认绑定，因此this绑定的全局对象。</p>\n<blockquote>\n<p>注意： 如果使用严格模式，则不能将全局对象用于默认绑定，因此this会绑定到undefined。</p>\n</blockquote>\n<h3 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h3><p>当函数作为某个对象的方法被调用时，此时this被绑定到这个上下文对象上。<br>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo();  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>当foo()被调用时，它前面加上了对obj的引用。即实际上是调用了obj对象的foo()方法。此时this被绑定到obj，因此this.a和obj.a是一样的。</p>\n<p>如果被隐式绑定的函数丢失了绑定对象，就会应用默认绑定，从而把this绑定到全局对象或者undefin上，取决于是否为严格模式。<br>例如上述例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"global\"</span>;</span><br><span class=\"line\">bar();  <span class=\"comment\">// \"global\"</span></span><br></pre></td></tr></table></figure></p>\n<p>这里的bar实际上引用的是foo函数本身，所以此时bar()其实是不带任何修饰的函数调用，因此应用了默认绑定。同理回调函数也是会丢失this绑定。</p>\n<h3 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h3><p>在隐式绑定中，我们必须设置一个对象的内部方法指向所要执行的函数，并通过这个方法间接引用该函数，从而把this隐式绑定到这个对象上。<br>而在显示绑定中，我们只需要通过apply()和call()方法直接在某个对象上强制调用所要执行的函数。<br>这两个方法的第一个参数是一个对象(参数为空时，默认调用全局对象)，是为this准备的，接着在调用函数时将其绑定给this。由于可以直接制定this的绑定对象，故称之为显式绑定。<br>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call(obj);  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>通过foo.call(…),在调用foo函数时强制把它的this绑定到obj上。</p>\n<h3 id=\"new绑定\"><a href=\"#new绑定\" class=\"headerlink\" title=\"new绑定\"></a>new绑定</h3><p>使用new来调用函数，即构造函数调用，创建一个新对象，此时，this就指向这个新对象。<br>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar.a);  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"判断this绑定对象\"><a href=\"#判断this绑定对象\" class=\"headerlink\" title=\"判断this绑定对象\"></a>判断this绑定对象</h3><p>综上所述，如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置。找到后按顺序通过下面四条规则来判定this的绑定对象。</p>\n<ol>\n<li>是否由new调用？绑定到新创建的对象上。</li>\n<li>是否由apply或者call调用？绑定到指定对象是。</li>\n<li>是否作为上下文对象方法调用？绑定到那个上下文对象。</li>\n<li>默认：在严格模式下绑定undefined，否则绑定的全局对象。</li>\n</ol>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>ES6中介绍了一种无法使用以上规则的特殊函数类型：箭头函数。<br>箭头函数并不是用function关键字定义的，而是使用操作符“=&gt;”定义的，其this指向根据当前词法作用域来决定的。<br>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.call(obj1);</span><br><span class=\"line\">bar.call(obj2);  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>foo()内部创建的箭头函数会捕获调用foo()时的this，由于foo()的this绑定到obj1，所以箭头函数的this也会绑定到obj1。此外，箭头函数的绑定无法被修改。(new也不行)</p>\n<h2 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h2><p>1.你不知道的JavaScript（上卷）</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"关于this\"><a href=\"#关于this\" class=\"headerlink\" title=\"关于this\"></a>关于this</h2><p>为什么要用this？当然是因为使用它更方便，更优雅啊。不然谁吃饱了撑着花这么多时间去理解这么复杂的玩意！this提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将API设计的更加简洁并且易于复用。<br>","more":"<br>学习this首先要明白this既不指向函数自身也不指向函数的词法作用域。而且this的绑定实际上是在函数被调用时发生的，它的指向完全取决于函数在哪里被调用。</p>\n<h2 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a>绑定规则</h2><p>如何判断一个运行中函数的this绑定，就需要先找到这个函数的具体调用位置，然后根据绑定规则来判断this的绑定对象。绑定规则有默认绑定、隐式绑定、显示绑定和new绑定。</p>\n<h3 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h3><p>纯粹的函数调用，直接使用不带任何修饰的函数引用进行调用。此时this就指向全局对象。<br>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo();  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>函数foo()调用时应用了this的默认绑定，因此this绑定的全局对象。</p>\n<blockquote>\n<p>注意： 如果使用严格模式，则不能将全局对象用于默认绑定，因此this会绑定到undefined。</p>\n</blockquote>\n<h3 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h3><p>当函数作为某个对象的方法被调用时，此时this被绑定到这个上下文对象上。<br>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo();  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>当foo()被调用时，它前面加上了对obj的引用。即实际上是调用了obj对象的foo()方法。此时this被绑定到obj，因此this.a和obj.a是一样的。</p>\n<p>如果被隐式绑定的函数丢失了绑定对象，就会应用默认绑定，从而把this绑定到全局对象或者undefin上，取决于是否为严格模式。<br>例如上述例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"global\"</span>;</span><br><span class=\"line\">bar();  <span class=\"comment\">// \"global\"</span></span><br></pre></td></tr></table></figure></p>\n<p>这里的bar实际上引用的是foo函数本身，所以此时bar()其实是不带任何修饰的函数调用，因此应用了默认绑定。同理回调函数也是会丢失this绑定。</p>\n<h3 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h3><p>在隐式绑定中，我们必须设置一个对象的内部方法指向所要执行的函数，并通过这个方法间接引用该函数，从而把this隐式绑定到这个对象上。<br>而在显示绑定中，我们只需要通过apply()和call()方法直接在某个对象上强制调用所要执行的函数。<br>这两个方法的第一个参数是一个对象(参数为空时，默认调用全局对象)，是为this准备的，接着在调用函数时将其绑定给this。由于可以直接制定this的绑定对象，故称之为显式绑定。<br>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call(obj);  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>通过foo.call(…),在调用foo函数时强制把它的this绑定到obj上。</p>\n<h3 id=\"new绑定\"><a href=\"#new绑定\" class=\"headerlink\" title=\"new绑定\"></a>new绑定</h3><p>使用new来调用函数，即构造函数调用，创建一个新对象，此时，this就指向这个新对象。<br>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar.a);  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"判断this绑定对象\"><a href=\"#判断this绑定对象\" class=\"headerlink\" title=\"判断this绑定对象\"></a>判断this绑定对象</h3><p>综上所述，如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置。找到后按顺序通过下面四条规则来判定this的绑定对象。</p>\n<ol>\n<li>是否由new调用？绑定到新创建的对象上。</li>\n<li>是否由apply或者call调用？绑定到指定对象是。</li>\n<li>是否作为上下文对象方法调用？绑定到那个上下文对象。</li>\n<li>默认：在严格模式下绑定undefined，否则绑定的全局对象。</li>\n</ol>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>ES6中介绍了一种无法使用以上规则的特殊函数类型：箭头函数。<br>箭头函数并不是用function关键字定义的，而是使用操作符“=&gt;”定义的，其this指向根据当前词法作用域来决定的。<br>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.call(obj1);</span><br><span class=\"line\">bar.call(obj2);  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>foo()内部创建的箭头函数会捕获调用foo()时的this，由于foo()的this绑定到obj1，所以箭头函数的this也会绑定到obj1。此外，箭头函数的绑定无法被修改。(new也不行)</p>\n<h2 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h2><p>1.你不知道的JavaScript（上卷）</p>"},{"title":"JavaScript 正则表达式","date":"2016-08-20T09:10:46.000Z","_content":"说起正则表达式还真是个反人类的东西，初次见它的时候，我还怀疑这个真不是乱码吗。。。。\n<!-- more -->\n学习前端以来，前前后后过了两遍的正则表达式，但都是学了就学了，头两天还能记得，但长时间不去使用，就又给忘了，一直没能记住，导致现在要进行第三遍。这次通过写博客的方式记下来，时不时翻开看看，想来总能降伏它了。就算不能掌握，记录下来这些语法，以后好查阅。\n\n## 概念\nRegular Expression,正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。\n说白了，就是按照某种规则去匹配符合条件的字符串。\n\n\n## 正则语法\n学习语法这里着重推荐一个网址：https://regexper.com/\n将正则表达式通过图形的方式表现出来，形象易于理解，真乃学习正则利器。\n### 元字符\n正则表达式由两种基本字符类型组成：\n>* 原义文本字符：就是代表它本身含义的字符，比如a就是字母a，2就是数字2；\n>* 元字符：就是正则中有特殊含义的非字母字符。\n\n原义文本字符没什么好讲，重点是元字符。\n常用的元字符：\n\n| 代码      | 含义   |\n| --------  | :-----  |\n| .         | 匹配除换行符以外的任意字符 |\n| \\w        | 匹配字母或数字或下划线或汉字 |\n| \\s        | 匹配任意的空白符    |\n| \\d        | 匹配数字    |\n| \\b        | 匹配单词的开始或结束    |\n| ^         | 匹配字符串的开始 |\n| $         | 匹配字符串的结束 |\n\n### 字符类\n当需要匹配某类字符的时候的时候就需要字符类。\n用元字符[]来构建一个简单的类。\n通过字符类可以轻松指定一个字符范围，比如[0-5]代表0到5中任意某个数字。\n\n其中，当字符类中出现^符号表示反向类，即不属于某类的内容的意思。比如[^0-5]表示匹配不是0到5的数字\n### 预定义类\n正则表达式提供了预定义类来匹配常见的字符类\n\n| 代码      | 等价类   | 含义 |\n| --------  | :-----  | :-----|\n|.|[^\\r\\n]|除回车符和换行符以外的所有字符|\n| \\d        | [0-9] |数字字符|\n|\\D|[^0-9]|非数字字符|\n|\\s|[\\t\\n\\x0B\\f\\r]|空白符|\n|\\S|[^\\t\\n\\x0B\\f\\r]|非空白符|\n|\\w|[a-zA-Z_0-9]|单词字符（字母、数字下划线）|\n|\\W|[^a-zA-Z_0-9]|非单词字符|\n\n### 重复（量词）\n当需要多次匹配相同规则的时候，正则也给我们提供了重复的方式。\n\n| 代码      | 含义   |\n| --------  | :-----  |\n| *         | 重复零次或更多次 |\n| +         | 重复一次或更多次 |\n| ？        | 重复零次或一次    |\n| {n}       | 重复n次   |\n| {n,}      | 重复n次或更多次    |\n| {n,m}     | 重复n到m次 |\n| {0,n}     | 最多重复n次 |\n\n### 贪婪与懒惰\n当正则表达式中包含能接受重复的限定符时，通常的行为是匹配尽可能多的字符。这就是贪婪模式。\n\n而当我们需要懒惰模式（非贪婪模式），即让正则表达式尽可能少的匹配时，只要在重复后面加上问好?即可。\n比如：\n\n| 代码      | 含义   |\n| --------  | :-----  |\n| *?         | 重复任意次，但尽可能少重复 |\n| +?        | 重复1次或更多次，但尽可能少重复 |\n| ??        | 重复0次或1次，但尽可能少重复    |\n| {n,} ?     | 重复n次以上，但尽可能少重复    |\n| {n,m} ?    | \t重复n到m次，但尽可能少重复 |\n\n### 分组\n使用（）可以当到分组的功能，通过量词重复分组。\n默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。\n\n如果是想使用（）进行分组而不捕获，只需要在分组内加上“? :”。\n\n## RegExp对象\nJavaScript通过内置对象RegExp来支持正则表达式。创建方式有字面量和构造函数。\n### 通过字面量创建\n```\nvar reg = /pattern /flags ;\n```\n其中模块（pattern）是任何简单或复杂的正则表达式。每个正则表达式都可带一个或多个标志（flags）用来表明正则表达式的行为。其中包括g(全局模式)，i（不区分大小写模式）和m（多行模式）三个标志。\n比如\n```\n//匹配所有以“.at”结尾的三个字符的组合，不区分大小写\nvar reg = /\\.at /gi\n```\n### 通过构造函数创建\n```\nvar reg = new RegExp(\"pattern\",\"flags\")\n```\n它接收两个参数：一个是要匹配的字符串模式，另一种是可选的标志字符串。\n注意：由于RegExp构造函数的 模式参数是字符串，所以在某些情况下要对字符进行双重转义。\n比如：\n```\n//匹配所有以“.at”结尾的三个字符的组合，不区分大小写\nvar reg =new RegExp(\"\\\\.at\",\"gi\")\n```\n","source":"_posts/JavaScript-正则表达式.md","raw":"---\ntitle: JavaScript 正则表达式\ndate: 2016-08-20 17:10:46\ncategories:\n\tJS\ntags:\n\t正则表达式\n---\n说起正则表达式还真是个反人类的东西，初次见它的时候，我还怀疑这个真不是乱码吗。。。。\n<!-- more -->\n学习前端以来，前前后后过了两遍的正则表达式，但都是学了就学了，头两天还能记得，但长时间不去使用，就又给忘了，一直没能记住，导致现在要进行第三遍。这次通过写博客的方式记下来，时不时翻开看看，想来总能降伏它了。就算不能掌握，记录下来这些语法，以后好查阅。\n\n## 概念\nRegular Expression,正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。\n说白了，就是按照某种规则去匹配符合条件的字符串。\n\n\n## 正则语法\n学习语法这里着重推荐一个网址：https://regexper.com/\n将正则表达式通过图形的方式表现出来，形象易于理解，真乃学习正则利器。\n### 元字符\n正则表达式由两种基本字符类型组成：\n>* 原义文本字符：就是代表它本身含义的字符，比如a就是字母a，2就是数字2；\n>* 元字符：就是正则中有特殊含义的非字母字符。\n\n原义文本字符没什么好讲，重点是元字符。\n常用的元字符：\n\n| 代码      | 含义   |\n| --------  | :-----  |\n| .         | 匹配除换行符以外的任意字符 |\n| \\w        | 匹配字母或数字或下划线或汉字 |\n| \\s        | 匹配任意的空白符    |\n| \\d        | 匹配数字    |\n| \\b        | 匹配单词的开始或结束    |\n| ^         | 匹配字符串的开始 |\n| $         | 匹配字符串的结束 |\n\n### 字符类\n当需要匹配某类字符的时候的时候就需要字符类。\n用元字符[]来构建一个简单的类。\n通过字符类可以轻松指定一个字符范围，比如[0-5]代表0到5中任意某个数字。\n\n其中，当字符类中出现^符号表示反向类，即不属于某类的内容的意思。比如[^0-5]表示匹配不是0到5的数字\n### 预定义类\n正则表达式提供了预定义类来匹配常见的字符类\n\n| 代码      | 等价类   | 含义 |\n| --------  | :-----  | :-----|\n|.|[^\\r\\n]|除回车符和换行符以外的所有字符|\n| \\d        | [0-9] |数字字符|\n|\\D|[^0-9]|非数字字符|\n|\\s|[\\t\\n\\x0B\\f\\r]|空白符|\n|\\S|[^\\t\\n\\x0B\\f\\r]|非空白符|\n|\\w|[a-zA-Z_0-9]|单词字符（字母、数字下划线）|\n|\\W|[^a-zA-Z_0-9]|非单词字符|\n\n### 重复（量词）\n当需要多次匹配相同规则的时候，正则也给我们提供了重复的方式。\n\n| 代码      | 含义   |\n| --------  | :-----  |\n| *         | 重复零次或更多次 |\n| +         | 重复一次或更多次 |\n| ？        | 重复零次或一次    |\n| {n}       | 重复n次   |\n| {n,}      | 重复n次或更多次    |\n| {n,m}     | 重复n到m次 |\n| {0,n}     | 最多重复n次 |\n\n### 贪婪与懒惰\n当正则表达式中包含能接受重复的限定符时，通常的行为是匹配尽可能多的字符。这就是贪婪模式。\n\n而当我们需要懒惰模式（非贪婪模式），即让正则表达式尽可能少的匹配时，只要在重复后面加上问好?即可。\n比如：\n\n| 代码      | 含义   |\n| --------  | :-----  |\n| *?         | 重复任意次，但尽可能少重复 |\n| +?        | 重复1次或更多次，但尽可能少重复 |\n| ??        | 重复0次或1次，但尽可能少重复    |\n| {n,} ?     | 重复n次以上，但尽可能少重复    |\n| {n,m} ?    | \t重复n到m次，但尽可能少重复 |\n\n### 分组\n使用（）可以当到分组的功能，通过量词重复分组。\n默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。\n\n如果是想使用（）进行分组而不捕获，只需要在分组内加上“? :”。\n\n## RegExp对象\nJavaScript通过内置对象RegExp来支持正则表达式。创建方式有字面量和构造函数。\n### 通过字面量创建\n```\nvar reg = /pattern /flags ;\n```\n其中模块（pattern）是任何简单或复杂的正则表达式。每个正则表达式都可带一个或多个标志（flags）用来表明正则表达式的行为。其中包括g(全局模式)，i（不区分大小写模式）和m（多行模式）三个标志。\n比如\n```\n//匹配所有以“.at”结尾的三个字符的组合，不区分大小写\nvar reg = /\\.at /gi\n```\n### 通过构造函数创建\n```\nvar reg = new RegExp(\"pattern\",\"flags\")\n```\n它接收两个参数：一个是要匹配的字符串模式，另一种是可选的标志字符串。\n注意：由于RegExp构造函数的 模式参数是字符串，所以在某些情况下要对字符进行双重转义。\n比如：\n```\n//匹配所有以“.at”结尾的三个字符的组合，不区分大小写\nvar reg =new RegExp(\"\\\\.at\",\"gi\")\n```\n","slug":"JavaScript-正则表达式","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63wf000kw9uaccjixup3","content":"<p>说起正则表达式还真是个反人类的东西，初次见它的时候，我还怀疑这个真不是乱码吗。。。。<br><a id=\"more\"></a><br>学习前端以来，前前后后过了两遍的正则表达式，但都是学了就学了，头两天还能记得，但长时间不去使用，就又给忘了，一直没能记住，导致现在要进行第三遍。这次通过写博客的方式记下来，时不时翻开看看，想来总能降伏它了。就算不能掌握，记录下来这些语法，以后好查阅。</p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>Regular Expression,正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。<br>说白了，就是按照某种规则去匹配符合条件的字符串。</p>\n<h2 id=\"正则语法\"><a href=\"#正则语法\" class=\"headerlink\" title=\"正则语法\"></a>正则语法</h2><p>学习语法这里着重推荐一个网址：<a href=\"https://regexper.com/\" target=\"_blank\" rel=\"noopener\">https://regexper.com/</a><br>将正则表达式通过图形的方式表现出来，形象易于理解，真乃学习正则利器。</p>\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><p>正则表达式由两种基本字符类型组成：</p>\n<blockquote>\n<ul>\n<li>原义文本字符：就是代表它本身含义的字符，比如a就是字母a，2就是数字2；</li>\n<li>元字符：就是正则中有特殊含义的非字母字符。</li>\n</ul>\n</blockquote>\n<p>原义文本字符没什么好讲，重点是元字符。<br>常用的元字符：</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td style=\"text-align:left\">匹配除换行符以外的任意字符</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td style=\"text-align:left\">匹配字母或数字或下划线或汉字</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td style=\"text-align:left\">匹配任意的空白符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td style=\"text-align:left\">匹配数字</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td style=\"text-align:left\">匹配单词的开始或结束</td>\n</tr>\n<tr>\n<td>^</td>\n<td style=\"text-align:left\">匹配字符串的开始</td>\n</tr>\n<tr>\n<td>$</td>\n<td style=\"text-align:left\">匹配字符串的结束</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h3><p>当需要匹配某类字符的时候的时候就需要字符类。<br>用元字符[]来构建一个简单的类。<br>通过字符类可以轻松指定一个字符范围，比如[0-5]代表0到5中任意某个数字。</p>\n<p>其中，当字符类中出现^符号表示反向类，即不属于某类的内容的意思。比如[^0-5]表示匹配不是0到5的数字</p>\n<h3 id=\"预定义类\"><a href=\"#预定义类\" class=\"headerlink\" title=\"预定义类\"></a>预定义类</h3><p>正则表达式提供了预定义类来匹配常见的字符类</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th style=\"text-align:left\">等价类</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td style=\"text-align:left\">[^\\r\\n]</td>\n<td style=\"text-align:left\">除回车符和换行符以外的所有字符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td style=\"text-align:left\">[0-9]</td>\n<td style=\"text-align:left\">数字字符</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td style=\"text-align:left\">[^0-9]</td>\n<td style=\"text-align:left\">非数字字符</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td style=\"text-align:left\">[\\t\\n\\x0B\\f\\r]</td>\n<td style=\"text-align:left\">空白符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td style=\"text-align:left\">[^\\t\\n\\x0B\\f\\r]</td>\n<td style=\"text-align:left\">非空白符</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td style=\"text-align:left\">[a-zA-Z_0-9]</td>\n<td style=\"text-align:left\">单词字符（字母、数字下划线）</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td style=\"text-align:left\">[^a-zA-Z_0-9]</td>\n<td style=\"text-align:left\">非单词字符</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"重复（量词）\"><a href=\"#重复（量词）\" class=\"headerlink\" title=\"重复（量词）\"></a>重复（量词）</h3><p>当需要多次匹配相同规则的时候，正则也给我们提供了重复的方式。</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td style=\"text-align:left\">重复零次或更多次</td>\n</tr>\n<tr>\n<td>+</td>\n<td style=\"text-align:left\">重复一次或更多次</td>\n</tr>\n<tr>\n<td>？</td>\n<td style=\"text-align:left\">重复零次或一次</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td style=\"text-align:left\">重复n次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td style=\"text-align:left\">重复n次或更多次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td style=\"text-align:left\">重复n到m次</td>\n</tr>\n<tr>\n<td>{0,n}</td>\n<td style=\"text-align:left\">最多重复n次</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"贪婪与懒惰\"><a href=\"#贪婪与懒惰\" class=\"headerlink\" title=\"贪婪与懒惰\"></a>贪婪与懒惰</h3><p>当正则表达式中包含能接受重复的限定符时，通常的行为是匹配尽可能多的字符。这就是贪婪模式。</p>\n<p>而当我们需要懒惰模式（非贪婪模式），即让正则表达式尽可能少的匹配时，只要在重复后面加上问好?即可。<br>比如：</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*?</td>\n<td style=\"text-align:left\">重复任意次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>+?</td>\n<td style=\"text-align:left\">重复1次或更多次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>??</td>\n<td style=\"text-align:left\">重复0次或1次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,} ?</td>\n<td style=\"text-align:left\">重复n次以上，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,m} ?</td>\n<td style=\"text-align:left\">重复n到m次，但尽可能少重复</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><p>使用（）可以当到分组的功能，通过量词重复分组。<br>默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p>\n<p>如果是想使用（）进行分组而不捕获，只需要在分组内加上“? :”。</p>\n<h2 id=\"RegExp对象\"><a href=\"#RegExp对象\" class=\"headerlink\" title=\"RegExp对象\"></a>RegExp对象</h2><p>JavaScript通过内置对象RegExp来支持正则表达式。创建方式有字面量和构造函数。</p>\n<h3 id=\"通过字面量创建\"><a href=\"#通过字面量创建\" class=\"headerlink\" title=\"通过字面量创建\"></a>通过字面量创建</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reg = /pattern /flags ;</span><br></pre></td></tr></table></figure>\n<p>其中模块（pattern）是任何简单或复杂的正则表达式。每个正则表达式都可带一个或多个标志（flags）用来表明正则表达式的行为。其中包括g(全局模式)，i（不区分大小写模式）和m（多行模式）三个标志。<br>比如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//匹配所有以“.at”结尾的三个字符的组合，不区分大小写</span><br><span class=\"line\">var reg = /\\.at /gi</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"通过构造函数创建\"><a href=\"#通过构造函数创建\" class=\"headerlink\" title=\"通过构造函数创建\"></a>通过构造函数创建</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reg = new RegExp(&quot;pattern&quot;,&quot;flags&quot;)</span><br></pre></td></tr></table></figure>\n<p>它接收两个参数：一个是要匹配的字符串模式，另一种是可选的标志字符串。<br>注意：由于RegExp构造函数的 模式参数是字符串，所以在某些情况下要对字符进行双重转义。<br>比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//匹配所有以“.at”结尾的三个字符的组合，不区分大小写</span><br><span class=\"line\">var reg =new RegExp(&quot;\\\\.at&quot;,&quot;gi&quot;)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>说起正则表达式还真是个反人类的东西，初次见它的时候，我还怀疑这个真不是乱码吗。。。。<br>","more":"<br>学习前端以来，前前后后过了两遍的正则表达式，但都是学了就学了，头两天还能记得，但长时间不去使用，就又给忘了，一直没能记住，导致现在要进行第三遍。这次通过写博客的方式记下来，时不时翻开看看，想来总能降伏它了。就算不能掌握，记录下来这些语法，以后好查阅。</p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>Regular Expression,正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。<br>说白了，就是按照某种规则去匹配符合条件的字符串。</p>\n<h2 id=\"正则语法\"><a href=\"#正则语法\" class=\"headerlink\" title=\"正则语法\"></a>正则语法</h2><p>学习语法这里着重推荐一个网址：<a href=\"https://regexper.com/\" target=\"_blank\" rel=\"noopener\">https://regexper.com/</a><br>将正则表达式通过图形的方式表现出来，形象易于理解，真乃学习正则利器。</p>\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><p>正则表达式由两种基本字符类型组成：</p>\n<blockquote>\n<ul>\n<li>原义文本字符：就是代表它本身含义的字符，比如a就是字母a，2就是数字2；</li>\n<li>元字符：就是正则中有特殊含义的非字母字符。</li>\n</ul>\n</blockquote>\n<p>原义文本字符没什么好讲，重点是元字符。<br>常用的元字符：</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td style=\"text-align:left\">匹配除换行符以外的任意字符</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td style=\"text-align:left\">匹配字母或数字或下划线或汉字</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td style=\"text-align:left\">匹配任意的空白符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td style=\"text-align:left\">匹配数字</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td style=\"text-align:left\">匹配单词的开始或结束</td>\n</tr>\n<tr>\n<td>^</td>\n<td style=\"text-align:left\">匹配字符串的开始</td>\n</tr>\n<tr>\n<td>$</td>\n<td style=\"text-align:left\">匹配字符串的结束</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h3><p>当需要匹配某类字符的时候的时候就需要字符类。<br>用元字符[]来构建一个简单的类。<br>通过字符类可以轻松指定一个字符范围，比如[0-5]代表0到5中任意某个数字。</p>\n<p>其中，当字符类中出现^符号表示反向类，即不属于某类的内容的意思。比如[^0-5]表示匹配不是0到5的数字</p>\n<h3 id=\"预定义类\"><a href=\"#预定义类\" class=\"headerlink\" title=\"预定义类\"></a>预定义类</h3><p>正则表达式提供了预定义类来匹配常见的字符类</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th style=\"text-align:left\">等价类</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td style=\"text-align:left\">[^\\r\\n]</td>\n<td style=\"text-align:left\">除回车符和换行符以外的所有字符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td style=\"text-align:left\">[0-9]</td>\n<td style=\"text-align:left\">数字字符</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td style=\"text-align:left\">[^0-9]</td>\n<td style=\"text-align:left\">非数字字符</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td style=\"text-align:left\">[\\t\\n\\x0B\\f\\r]</td>\n<td style=\"text-align:left\">空白符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td style=\"text-align:left\">[^\\t\\n\\x0B\\f\\r]</td>\n<td style=\"text-align:left\">非空白符</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td style=\"text-align:left\">[a-zA-Z_0-9]</td>\n<td style=\"text-align:left\">单词字符（字母、数字下划线）</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td style=\"text-align:left\">[^a-zA-Z_0-9]</td>\n<td style=\"text-align:left\">非单词字符</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"重复（量词）\"><a href=\"#重复（量词）\" class=\"headerlink\" title=\"重复（量词）\"></a>重复（量词）</h3><p>当需要多次匹配相同规则的时候，正则也给我们提供了重复的方式。</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td style=\"text-align:left\">重复零次或更多次</td>\n</tr>\n<tr>\n<td>+</td>\n<td style=\"text-align:left\">重复一次或更多次</td>\n</tr>\n<tr>\n<td>？</td>\n<td style=\"text-align:left\">重复零次或一次</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td style=\"text-align:left\">重复n次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td style=\"text-align:left\">重复n次或更多次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td style=\"text-align:left\">重复n到m次</td>\n</tr>\n<tr>\n<td>{0,n}</td>\n<td style=\"text-align:left\">最多重复n次</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"贪婪与懒惰\"><a href=\"#贪婪与懒惰\" class=\"headerlink\" title=\"贪婪与懒惰\"></a>贪婪与懒惰</h3><p>当正则表达式中包含能接受重复的限定符时，通常的行为是匹配尽可能多的字符。这就是贪婪模式。</p>\n<p>而当我们需要懒惰模式（非贪婪模式），即让正则表达式尽可能少的匹配时，只要在重复后面加上问好?即可。<br>比如：</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*?</td>\n<td style=\"text-align:left\">重复任意次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>+?</td>\n<td style=\"text-align:left\">重复1次或更多次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>??</td>\n<td style=\"text-align:left\">重复0次或1次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,} ?</td>\n<td style=\"text-align:left\">重复n次以上，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,m} ?</td>\n<td style=\"text-align:left\">重复n到m次，但尽可能少重复</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><p>使用（）可以当到分组的功能，通过量词重复分组。<br>默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p>\n<p>如果是想使用（）进行分组而不捕获，只需要在分组内加上“? :”。</p>\n<h2 id=\"RegExp对象\"><a href=\"#RegExp对象\" class=\"headerlink\" title=\"RegExp对象\"></a>RegExp对象</h2><p>JavaScript通过内置对象RegExp来支持正则表达式。创建方式有字面量和构造函数。</p>\n<h3 id=\"通过字面量创建\"><a href=\"#通过字面量创建\" class=\"headerlink\" title=\"通过字面量创建\"></a>通过字面量创建</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reg = /pattern /flags ;</span><br></pre></td></tr></table></figure>\n<p>其中模块（pattern）是任何简单或复杂的正则表达式。每个正则表达式都可带一个或多个标志（flags）用来表明正则表达式的行为。其中包括g(全局模式)，i（不区分大小写模式）和m（多行模式）三个标志。<br>比如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//匹配所有以“.at”结尾的三个字符的组合，不区分大小写</span><br><span class=\"line\">var reg = /\\.at /gi</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"通过构造函数创建\"><a href=\"#通过构造函数创建\" class=\"headerlink\" title=\"通过构造函数创建\"></a>通过构造函数创建</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reg = new RegExp(&quot;pattern&quot;,&quot;flags&quot;)</span><br></pre></td></tr></table></figure>\n<p>它接收两个参数：一个是要匹配的字符串模式，另一种是可选的标志字符串。<br>注意：由于RegExp构造函数的 模式参数是字符串，所以在某些情况下要对字符进行双重转义。<br>比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//匹配所有以“.at”结尾的三个字符的组合，不区分大小写</span><br><span class=\"line\">var reg =new RegExp(&quot;\\\\.at&quot;,&quot;gi&quot;)</span><br></pre></td></tr></table></figure></p>"},{"title":"JavaScript 闭包","date":"2016-07-26T09:35:35.000Z","_content":"要想学好JavaScript有一道坎是无论如何都要迈过的，那就是闭包。它是JS中一个非常重要但又难以掌握的概念。\n### 闭包的定义\n让我们开门见山，什么是闭包？\n<!-- more -->\n“闭包是指有权访问另一个函数作用域中的变量的函数。”这是《JavaScript高级程序设计》给出的定义。这句话很简单，但不好理解。让我们直接看例子：\n```javascript\nfunction foo(){\n    var a = 2;\n    function bar(){\n        console.log(a);\n    }\n    bar();\n}\nfoo();  //2\n```\n首先，这是闭包吗？是，它是一个闭包。但它不能展示出闭包的特性。bar()对a的引用是基于词法作用域的查找规则，内部函数能访问外部作用域的变量。而下面这个例子就能很好地展示了闭包：\n<!-- more -->\n```javascript\nfunction foo(){\n    var a = 2;\n    function bar(){\n        console.log(a);\n    }\n    return bar;\n}\nvar baz = foo();\nbaz();  //2\n```\n让我们先抛开闭包来看这段代码。首先，函数bar()能访问foo()的内部作用域中的变量a，没问题，这是基于词法作用域自里向外的查找规则。\n\n在foo()执行后，其返回值(也就是内部的bar()函数)赋值给了变量baz并调用了baz(),实际上只是通过不同的标识符(也就是这里的bar和baz)引用调用了内部的函数bar()。但是这是它自己定义的词法作用域以外的地方执行，讲道理它应该无权访问到变量a的值啊，为什么最后还是输出结果2了呢？所以这就是闭包神奇的地方！\n\n我们都知道JS的垃圾回收机制会释放不再使用的内存空间。看上去foo()的内容不再被使用，所以自然会考虑将其回收。而闭包“神奇”的地方就在于可以阻止这件事的发生。由于bar()声明在foo()内部，它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在之后任何时刻引用。这个引用就是闭包！\n\n所以，无论通过何种手段将内部函数传递到所在词法作用域以外，他都会持有对原始作用域的引用，无论在何处执行这个函数都会使用闭包。\n### 闭包与循环\n在循环中使用闭包会有一个坑。例如：\n```javascript\nfor(var i = 1; i <= 5; i++){\n    setTimeout(function timer(){\n        console.log(i);     //6,6,6,6,6\n    },i*1000);\n}\n```\n按照正常的思维，我们会觉得这段代码运行结果是每秒一个地输出1~5，但实际上，这段代码在运行时会 以每秒一次的频率输出五次6。这就很奇怪了，为什么它会和我们所想的结果不一样呢？\n原来尽管循环中的五个函数在每次循环中分别定义的，但它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i，也就是循环满足终止条件时i的值6。\n所以也就是说闭包只能取得包含函数中任何变量的最后一个值。\n\n那如何改造代码，让它向我们所期望的结果运行呢？看代码：\n```javascript\nfor(var i = 1; i <= 5; i++){\n    (function(j){\n        setTimeout(function timer(){\n            console.log(j);     //1,2,3,4,5\n        },j*1000);\n    })(i);\n}\n```\n这里我们通过声明并立即执行一个匿名函数来创建作用域。在调用每个匿名函数时，传入了变量i，由于函数参数是按值传递的，所以就会把变量i的当前值赋值给了j，从而产生了新的作用域，j的值是不会被循环改变的。这样一来每个函数都能获取到所对应的i的值。\n\n上述方法在每次循环中都创建了一个新的作用域。换句话说，要想得到所期望的结果，每次循环我们都需要一个块级作用域。而在ES6中的let声明，可以用来劫持块作用域，并且在这个块级作用域中声明一个变量。如代码所示：\n```javascript\nfor(let i = 1; i <= 5; i++){\n    setTimeout(function timer(){\n        console.log(i);     //1,2,3,4,5\n    },i*1000);\n}\n```\n通过let声明，变量i在循环过程中不止被声明一次，每次循环都会声明，随后的每一次迭代都会使用上一个迭代结束时的值来初始化这个变量。本质上就是通过let声明在每次迭代都会生成一个新的作用域。\n## 资料参考\n1.你不知道的JavaScript（上卷）\n2.JavaScript高级程序设计（第3版）\n","source":"_posts/JavaScript-闭包.md","raw":"---\ntitle: JavaScript 闭包\ndate: 2016-07-26 17:35:35\ncategories:\n    JS\ntags:\n\t- 闭包\n---\n要想学好JavaScript有一道坎是无论如何都要迈过的，那就是闭包。它是JS中一个非常重要但又难以掌握的概念。\n### 闭包的定义\n让我们开门见山，什么是闭包？\n<!-- more -->\n“闭包是指有权访问另一个函数作用域中的变量的函数。”这是《JavaScript高级程序设计》给出的定义。这句话很简单，但不好理解。让我们直接看例子：\n```javascript\nfunction foo(){\n    var a = 2;\n    function bar(){\n        console.log(a);\n    }\n    bar();\n}\nfoo();  //2\n```\n首先，这是闭包吗？是，它是一个闭包。但它不能展示出闭包的特性。bar()对a的引用是基于词法作用域的查找规则，内部函数能访问外部作用域的变量。而下面这个例子就能很好地展示了闭包：\n<!-- more -->\n```javascript\nfunction foo(){\n    var a = 2;\n    function bar(){\n        console.log(a);\n    }\n    return bar;\n}\nvar baz = foo();\nbaz();  //2\n```\n让我们先抛开闭包来看这段代码。首先，函数bar()能访问foo()的内部作用域中的变量a，没问题，这是基于词法作用域自里向外的查找规则。\n\n在foo()执行后，其返回值(也就是内部的bar()函数)赋值给了变量baz并调用了baz(),实际上只是通过不同的标识符(也就是这里的bar和baz)引用调用了内部的函数bar()。但是这是它自己定义的词法作用域以外的地方执行，讲道理它应该无权访问到变量a的值啊，为什么最后还是输出结果2了呢？所以这就是闭包神奇的地方！\n\n我们都知道JS的垃圾回收机制会释放不再使用的内存空间。看上去foo()的内容不再被使用，所以自然会考虑将其回收。而闭包“神奇”的地方就在于可以阻止这件事的发生。由于bar()声明在foo()内部，它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在之后任何时刻引用。这个引用就是闭包！\n\n所以，无论通过何种手段将内部函数传递到所在词法作用域以外，他都会持有对原始作用域的引用，无论在何处执行这个函数都会使用闭包。\n### 闭包与循环\n在循环中使用闭包会有一个坑。例如：\n```javascript\nfor(var i = 1; i <= 5; i++){\n    setTimeout(function timer(){\n        console.log(i);     //6,6,6,6,6\n    },i*1000);\n}\n```\n按照正常的思维，我们会觉得这段代码运行结果是每秒一个地输出1~5，但实际上，这段代码在运行时会 以每秒一次的频率输出五次6。这就很奇怪了，为什么它会和我们所想的结果不一样呢？\n原来尽管循环中的五个函数在每次循环中分别定义的，但它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i，也就是循环满足终止条件时i的值6。\n所以也就是说闭包只能取得包含函数中任何变量的最后一个值。\n\n那如何改造代码，让它向我们所期望的结果运行呢？看代码：\n```javascript\nfor(var i = 1; i <= 5; i++){\n    (function(j){\n        setTimeout(function timer(){\n            console.log(j);     //1,2,3,4,5\n        },j*1000);\n    })(i);\n}\n```\n这里我们通过声明并立即执行一个匿名函数来创建作用域。在调用每个匿名函数时，传入了变量i，由于函数参数是按值传递的，所以就会把变量i的当前值赋值给了j，从而产生了新的作用域，j的值是不会被循环改变的。这样一来每个函数都能获取到所对应的i的值。\n\n上述方法在每次循环中都创建了一个新的作用域。换句话说，要想得到所期望的结果，每次循环我们都需要一个块级作用域。而在ES6中的let声明，可以用来劫持块作用域，并且在这个块级作用域中声明一个变量。如代码所示：\n```javascript\nfor(let i = 1; i <= 5; i++){\n    setTimeout(function timer(){\n        console.log(i);     //1,2,3,4,5\n    },i*1000);\n}\n```\n通过let声明，变量i在循环过程中不止被声明一次，每次循环都会声明，随后的每一次迭代都会使用上一个迭代结束时的值来初始化这个变量。本质上就是通过let声明在每次迭代都会生成一个新的作用域。\n## 资料参考\n1.你不知道的JavaScript（上卷）\n2.JavaScript高级程序设计（第3版）\n","slug":"JavaScript-闭包","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63wg000lw9uayfd675k8","content":"<p>要想学好JavaScript有一道坎是无论如何都要迈过的，那就是闭包。它是JS中一个非常重要但又难以掌握的概念。</p>\n<h3 id=\"闭包的定义\"><a href=\"#闭包的定义\" class=\"headerlink\" title=\"闭包的定义\"></a>闭包的定义</h3><p>让我们开门见山，什么是闭包？<br><a id=\"more\"></a><br>“闭包是指有权访问另一个函数作用域中的变量的函数。”这是《JavaScript高级程序设计》给出的定义。这句话很简单，但不好理解。让我们直接看例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bar();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();  <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure></p>\n<p>首先，这是闭包吗？是，它是一个闭包。但它不能展示出闭包的特性。bar()对a的引用是基于词法作用域的查找规则，内部函数能访问外部作用域的变量。而下面这个例子就能很好地展示了闭包：<br><!-- more --><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = foo();</span><br><span class=\"line\">baz();  <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure></p>\n<p>让我们先抛开闭包来看这段代码。首先，函数bar()能访问foo()的内部作用域中的变量a，没问题，这是基于词法作用域自里向外的查找规则。</p>\n<p>在foo()执行后，其返回值(也就是内部的bar()函数)赋值给了变量baz并调用了baz(),实际上只是通过不同的标识符(也就是这里的bar和baz)引用调用了内部的函数bar()。但是这是它自己定义的词法作用域以外的地方执行，讲道理它应该无权访问到变量a的值啊，为什么最后还是输出结果2了呢？所以这就是闭包神奇的地方！</p>\n<p>我们都知道JS的垃圾回收机制会释放不再使用的内存空间。看上去foo()的内容不再被使用，所以自然会考虑将其回收。而闭包“神奇”的地方就在于可以阻止这件事的发生。由于bar()声明在foo()内部，它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在之后任何时刻引用。这个引用就是闭包！</p>\n<p>所以，无论通过何种手段将内部函数传递到所在词法作用域以外，他都会持有对原始作用域的引用，无论在何处执行这个函数都会使用闭包。</p>\n<h3 id=\"闭包与循环\"><a href=\"#闭包与循环\" class=\"headerlink\" title=\"闭包与循环\"></a>闭包与循环</h3><p>在循环中使用闭包会有一个坑。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i);     <span class=\"comment\">//6,6,6,6,6</span></span><br><span class=\"line\">    &#125;,i*<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>按照正常的思维，我们会觉得这段代码运行结果是每秒一个地输出1~5，但实际上，这段代码在运行时会 以每秒一次的频率输出五次6。这就很奇怪了，为什么它会和我们所想的结果不一样呢？<br>原来尽管循环中的五个函数在每次循环中分别定义的，但它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i，也就是循环满足终止条件时i的值6。<br>所以也就是说闭包只能取得包含函数中任何变量的最后一个值。</p>\n<p>那如何改造代码，让它向我们所期望的结果运行呢？看代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(j);     <span class=\"comment\">//1,2,3,4,5</span></span><br><span class=\"line\">        &#125;,j*<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里我们通过声明并立即执行一个匿名函数来创建作用域。在调用每个匿名函数时，传入了变量i，由于函数参数是按值传递的，所以就会把变量i的当前值赋值给了j，从而产生了新的作用域，j的值是不会被循环改变的。这样一来每个函数都能获取到所对应的i的值。</p>\n<p>上述方法在每次循环中都创建了一个新的作用域。换句话说，要想得到所期望的结果，每次循环我们都需要一个块级作用域。而在ES6中的let声明，可以用来劫持块作用域，并且在这个块级作用域中声明一个变量。如代码所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i);     <span class=\"comment\">//1,2,3,4,5</span></span><br><span class=\"line\">    &#125;,i*<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过let声明，变量i在循环过程中不止被声明一次，每次循环都会声明，随后的每一次迭代都会使用上一个迭代结束时的值来初始化这个变量。本质上就是通过let声明在每次迭代都会生成一个新的作用域。</p>\n<h2 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h2><p>1.你不知道的JavaScript（上卷）<br>2.JavaScript高级程序设计（第3版）</p>\n","site":{"data":{}},"excerpt":"<p>要想学好JavaScript有一道坎是无论如何都要迈过的，那就是闭包。它是JS中一个非常重要但又难以掌握的概念。</p>\n<h3 id=\"闭包的定义\"><a href=\"#闭包的定义\" class=\"headerlink\" title=\"闭包的定义\"></a>闭包的定义</h3><p>让我们开门见山，什么是闭包？<br>","more":"<br>“闭包是指有权访问另一个函数作用域中的变量的函数。”这是《JavaScript高级程序设计》给出的定义。这句话很简单，但不好理解。让我们直接看例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bar();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();  <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure></p>\n<p>首先，这是闭包吗？是，它是一个闭包。但它不能展示出闭包的特性。bar()对a的引用是基于词法作用域的查找规则，内部函数能访问外部作用域的变量。而下面这个例子就能很好地展示了闭包：<br><!-- more --><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = foo();</span><br><span class=\"line\">baz();  <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure></p>\n<p>让我们先抛开闭包来看这段代码。首先，函数bar()能访问foo()的内部作用域中的变量a，没问题，这是基于词法作用域自里向外的查找规则。</p>\n<p>在foo()执行后，其返回值(也就是内部的bar()函数)赋值给了变量baz并调用了baz(),实际上只是通过不同的标识符(也就是这里的bar和baz)引用调用了内部的函数bar()。但是这是它自己定义的词法作用域以外的地方执行，讲道理它应该无权访问到变量a的值啊，为什么最后还是输出结果2了呢？所以这就是闭包神奇的地方！</p>\n<p>我们都知道JS的垃圾回收机制会释放不再使用的内存空间。看上去foo()的内容不再被使用，所以自然会考虑将其回收。而闭包“神奇”的地方就在于可以阻止这件事的发生。由于bar()声明在foo()内部，它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在之后任何时刻引用。这个引用就是闭包！</p>\n<p>所以，无论通过何种手段将内部函数传递到所在词法作用域以外，他都会持有对原始作用域的引用，无论在何处执行这个函数都会使用闭包。</p>\n<h3 id=\"闭包与循环\"><a href=\"#闭包与循环\" class=\"headerlink\" title=\"闭包与循环\"></a>闭包与循环</h3><p>在循环中使用闭包会有一个坑。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i);     <span class=\"comment\">//6,6,6,6,6</span></span><br><span class=\"line\">    &#125;,i*<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>按照正常的思维，我们会觉得这段代码运行结果是每秒一个地输出1~5，但实际上，这段代码在运行时会 以每秒一次的频率输出五次6。这就很奇怪了，为什么它会和我们所想的结果不一样呢？<br>原来尽管循环中的五个函数在每次循环中分别定义的，但它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i，也就是循环满足终止条件时i的值6。<br>所以也就是说闭包只能取得包含函数中任何变量的最后一个值。</p>\n<p>那如何改造代码，让它向我们所期望的结果运行呢？看代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(j);     <span class=\"comment\">//1,2,3,4,5</span></span><br><span class=\"line\">        &#125;,j*<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里我们通过声明并立即执行一个匿名函数来创建作用域。在调用每个匿名函数时，传入了变量i，由于函数参数是按值传递的，所以就会把变量i的当前值赋值给了j，从而产生了新的作用域，j的值是不会被循环改变的。这样一来每个函数都能获取到所对应的i的值。</p>\n<p>上述方法在每次循环中都创建了一个新的作用域。换句话说，要想得到所期望的结果，每次循环我们都需要一个块级作用域。而在ES6中的let声明，可以用来劫持块作用域，并且在这个块级作用域中声明一个变量。如代码所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i);     <span class=\"comment\">//1,2,3,4,5</span></span><br><span class=\"line\">    &#125;,i*<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过let声明，变量i在循环过程中不止被声明一次，每次循环都会声明，随后的每一次迭代都会使用上一个迭代结束时的值来初始化这个变量。本质上就是通过let声明在每次迭代都会生成一个新的作用域。</p>\n<h2 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h2><p>1.你不知道的JavaScript（上卷）<br>2.JavaScript高级程序设计（第3版）</p>"},{"_content":"---\ntitle: MooTools 源码分析之Core (未完待续)\ndate: 2016-08-02 17:04:55\ncategories:\n\tMooTools\ntags:\n\t- 源码分析\n---888\n```javascript\n(function(){\n\t//代码被包在一个匿名函数的内部，所以这里的this明确指向全局对象。\n\t//版本信息\nthis.MooTools = {\n\tversion: '1.6.0',\n\tbuild: '529422872adfff401b901b8b6c7ca5114ee95e2b'\n};\n```\n<!-- more -->\n```\n// 定义了typeOf, instanceOf两个函数来替代JS原生的typeof和instanceof方法(注意大小写)\n\n//定义typeOf方法(注意O大写！),在原生typeof的基础上做了拓展,判断参数类型\nvar typeOf = this.typeOf = function(item){\n\t//如果对象是null则返回null\n\tif (item == null) return 'null';\n\tif (item.$family != null) return item.$family();\n\n\t//判断node类型\n\tif (item.nodeName){\n\t\t//如果nodeType的值为1，则返回element\n\t\tif (item.nodeType == 1) return 'element';\n\t\t//如果nodeType的值为3，判断其有无值，选择返回值或者空白格\n\t\tif (item.nodeType == 3) return (/\\S/).test(item.nodeValue) ? 'textnode' : 'whitespace';\n\t} else if (typeof item.length == 'number'){\n\t\tif ('callee' in item) return 'arguments';\t\t\t\t//如果有callee属性的则返回arguments\n\t\tif ('item' in item) return 'collection';\t\t\t\t//如果有item属性的则返回collection\n\t}\n\t//如果都不满足则返回原生JS typeof运算符的结果：\"undefined\",\"boolean\",\"string\",\"number\",\"object\",\"function\"\n\treturn typeof item;\n};\n```\n```\n//定义instanceOf方法(注意O大写！)，在原生instanceof的基础上做了拓展,判断某个对象是否是某个特定类型的实例\nvar instanceOf = this.instanceOf = function(item, object){\n\t//如果对象为null则返回false\n\tif (item == null) return false;\n\t//定义constructor属性 判断是否可以追溯到object，如果可以则返回true\n\tvar constructor = item.$constructor || item.constructor;\n\twhile (constructor){\n\t\tif (constructor === object) return true;\n\t\tconstructor = constructor.parent;\n\t}\n\t/*<ltIE8>*/\t//------------>前后两个/*<ltIE8>*/表示为了兼容IE8.。。。。。。万恶的IE！！！\n\tif (!item.hasOwnProperty) return false;\n\t/*</ltIE8>*/\n\t//如果都不满足则返回原生JS typeof运算符的结果\n\treturn item instanceof object;\n};\n```\n```\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/*<ltIE8>*/\n\nvar enumerables = true;\n//对IE中不能遍历对象中toString属性的bug做一个修正\nfor (var i in {toString: 1}) enumerables = null;\n//如果遍历不到则enumerables为true，然后将这些属性暂存到一个数组保存到enumerables中\nif (enumerables) enumerables = ['hasOwnProperty', 'valueOf', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'constructor'];\n\n//该函数就是传进object和bind两个对象和fn方法，首先遍历判断object对象里是否有enumberables数组中的那些属性，\n//如果有则让bind对象执行fn方法，该方法传入k和object[k]两个参数\nfunction forEachObjectEnumberableKey(object, fn, bind){\n\tif (enumerables) for (var i = enumerables.length; i--;){\n\t\tvar k = enumerables[i];\n\t\t//hasOwnProperty.call(object, k) --> object.hasOwnProperty(k) -->object对象是否有自己的属性k\n\t\t//fn.call(bind, k, object[k]) --> bind.fn(k,object[k]) -->bind对象执行fn方法并传入参数k和object[k]\n\t\tif (hasOwnProperty.call(object, k)) fn.call(bind, k, object[k]);\n\t}\n}\n/*</ltIE8>*/\n\n```\n","source":"_posts/MooTools-源码分析之Core.md","raw":"---\ntitle: MooTools 源码分析之Core (未完待续)\ndate: 2016-08-02 17:04:55\ncategories:\n\tMooTools\ntags:\n\t- 源码分析\n---888\n```javascript\n(function(){\n\t//代码被包在一个匿名函数的内部，所以这里的this明确指向全局对象。\n\t//版本信息\nthis.MooTools = {\n\tversion: '1.6.0',\n\tbuild: '529422872adfff401b901b8b6c7ca5114ee95e2b'\n};\n```\n<!-- more -->\n```\n// 定义了typeOf, instanceOf两个函数来替代JS原生的typeof和instanceof方法(注意大小写)\n\n//定义typeOf方法(注意O大写！),在原生typeof的基础上做了拓展,判断参数类型\nvar typeOf = this.typeOf = function(item){\n\t//如果对象是null则返回null\n\tif (item == null) return 'null';\n\tif (item.$family != null) return item.$family();\n\n\t//判断node类型\n\tif (item.nodeName){\n\t\t//如果nodeType的值为1，则返回element\n\t\tif (item.nodeType == 1) return 'element';\n\t\t//如果nodeType的值为3，判断其有无值，选择返回值或者空白格\n\t\tif (item.nodeType == 3) return (/\\S/).test(item.nodeValue) ? 'textnode' : 'whitespace';\n\t} else if (typeof item.length == 'number'){\n\t\tif ('callee' in item) return 'arguments';\t\t\t\t//如果有callee属性的则返回arguments\n\t\tif ('item' in item) return 'collection';\t\t\t\t//如果有item属性的则返回collection\n\t}\n\t//如果都不满足则返回原生JS typeof运算符的结果：\"undefined\",\"boolean\",\"string\",\"number\",\"object\",\"function\"\n\treturn typeof item;\n};\n```\n```\n//定义instanceOf方法(注意O大写！)，在原生instanceof的基础上做了拓展,判断某个对象是否是某个特定类型的实例\nvar instanceOf = this.instanceOf = function(item, object){\n\t//如果对象为null则返回false\n\tif (item == null) return false;\n\t//定义constructor属性 判断是否可以追溯到object，如果可以则返回true\n\tvar constructor = item.$constructor || item.constructor;\n\twhile (constructor){\n\t\tif (constructor === object) return true;\n\t\tconstructor = constructor.parent;\n\t}\n\t/*<ltIE8>*/\t//------------>前后两个/*<ltIE8>*/表示为了兼容IE8.。。。。。。万恶的IE！！！\n\tif (!item.hasOwnProperty) return false;\n\t/*</ltIE8>*/\n\t//如果都不满足则返回原生JS typeof运算符的结果\n\treturn item instanceof object;\n};\n```\n```\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/*<ltIE8>*/\n\nvar enumerables = true;\n//对IE中不能遍历对象中toString属性的bug做一个修正\nfor (var i in {toString: 1}) enumerables = null;\n//如果遍历不到则enumerables为true，然后将这些属性暂存到一个数组保存到enumerables中\nif (enumerables) enumerables = ['hasOwnProperty', 'valueOf', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'constructor'];\n\n//该函数就是传进object和bind两个对象和fn方法，首先遍历判断object对象里是否有enumberables数组中的那些属性，\n//如果有则让bind对象执行fn方法，该方法传入k和object[k]两个参数\nfunction forEachObjectEnumberableKey(object, fn, bind){\n\tif (enumerables) for (var i = enumerables.length; i--;){\n\t\tvar k = enumerables[i];\n\t\t//hasOwnProperty.call(object, k) --> object.hasOwnProperty(k) -->object对象是否有自己的属性k\n\t\t//fn.call(bind, k, object[k]) --> bind.fn(k,object[k]) -->bind对象执行fn方法并传入参数k和object[k]\n\t\tif (hasOwnProperty.call(object, k)) fn.call(bind, k, object[k]);\n\t}\n}\n/*</ltIE8>*/\n\n```\n","slug":"MooTools-源码分析之Core","published":1,"date":"2016-10-07T21:25:40.000Z","updated":"2016-10-07T21:25:40.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63wh000pw9uai75xghd3","content":"<hr>\n<p>title: MooTools 源码分析之Core (未完待续)<br>date: 2016-08-02 17:04:55<br>categories:<br>    MooTools<br>tags:</p>\n<pre><code>- 源码分析\n</code></pre><p>—888<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//代码被包在一个匿名函数的内部，所以这里的this明确指向全局对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">//版本信息</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.MooTools = &#123;</span><br><span class=\"line\">\tversion: <span class=\"string\">'1.6.0'</span>,</span><br><span class=\"line\">\tbuild: <span class=\"string\">'529422872adfff401b901b8b6c7ca5114ee95e2b'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义了typeOf, instanceOf两个函数来替代JS原生的typeof和instanceof方法(注意大小写)</span><br><span class=\"line\"></span><br><span class=\"line\">//定义typeOf方法(注意O大写！),在原生typeof的基础上做了拓展,判断参数类型</span><br><span class=\"line\">var typeOf = this.typeOf = function(item)&#123;</span><br><span class=\"line\">\t//如果对象是null则返回null</span><br><span class=\"line\">\tif (item == null) return &apos;null&apos;;</span><br><span class=\"line\">\tif (item.$family != null) return item.$family();</span><br><span class=\"line\"></span><br><span class=\"line\">\t//判断node类型</span><br><span class=\"line\">\tif (item.nodeName)&#123;</span><br><span class=\"line\">\t\t//如果nodeType的值为1，则返回element</span><br><span class=\"line\">\t\tif (item.nodeType == 1) return &apos;element&apos;;</span><br><span class=\"line\">\t\t//如果nodeType的值为3，判断其有无值，选择返回值或者空白格</span><br><span class=\"line\">\t\tif (item.nodeType == 3) return (/\\S/).test(item.nodeValue) ? &apos;textnode&apos; : &apos;whitespace&apos;;</span><br><span class=\"line\">\t&#125; else if (typeof item.length == &apos;number&apos;)&#123;</span><br><span class=\"line\">\t\tif (&apos;callee&apos; in item) return &apos;arguments&apos;;\t\t\t\t//如果有callee属性的则返回arguments</span><br><span class=\"line\">\t\tif (&apos;item&apos; in item) return &apos;collection&apos;;\t\t\t\t//如果有item属性的则返回collection</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t//如果都不满足则返回原生JS typeof运算符的结果：&quot;undefined&quot;,&quot;boolean&quot;,&quot;string&quot;,&quot;number&quot;,&quot;object&quot;,&quot;function&quot;</span><br><span class=\"line\">\treturn typeof item;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义instanceOf方法(注意O大写！)，在原生instanceof的基础上做了拓展,判断某个对象是否是某个特定类型的实例</span><br><span class=\"line\">var instanceOf = this.instanceOf = function(item, object)&#123;</span><br><span class=\"line\">\t//如果对象为null则返回false</span><br><span class=\"line\">\tif (item == null) return false;</span><br><span class=\"line\">\t//定义constructor属性 判断是否可以追溯到object，如果可以则返回true</span><br><span class=\"line\">\tvar constructor = item.$constructor || item.constructor;</span><br><span class=\"line\">\twhile (constructor)&#123;</span><br><span class=\"line\">\t\tif (constructor === object) return true;</span><br><span class=\"line\">\t\tconstructor = constructor.parent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/*&lt;ltIE8&gt;*/\t//------------&gt;前后两个/*&lt;ltIE8&gt;*/表示为了兼容IE8.。。。。。。万恶的IE！！！</span><br><span class=\"line\">\tif (!item.hasOwnProperty) return false;</span><br><span class=\"line\">\t/*&lt;/ltIE8&gt;*/</span><br><span class=\"line\">\t//如果都不满足则返回原生JS typeof运算符的结果</span><br><span class=\"line\">\treturn item instanceof object;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var hasOwnProperty = Object.prototype.hasOwnProperty;</span><br><span class=\"line\"></span><br><span class=\"line\">/*&lt;ltIE8&gt;*/</span><br><span class=\"line\"></span><br><span class=\"line\">var enumerables = true;</span><br><span class=\"line\">//对IE中不能遍历对象中toString属性的bug做一个修正</span><br><span class=\"line\">for (var i in &#123;toString: 1&#125;) enumerables = null;</span><br><span class=\"line\">//如果遍历不到则enumerables为true，然后将这些属性暂存到一个数组保存到enumerables中</span><br><span class=\"line\">if (enumerables) enumerables = [&apos;hasOwnProperty&apos;, &apos;valueOf&apos;, &apos;isPrototypeOf&apos;, &apos;propertyIsEnumerable&apos;, &apos;toLocaleString&apos;, &apos;toString&apos;, &apos;constructor&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">//该函数就是传进object和bind两个对象和fn方法，首先遍历判断object对象里是否有enumberables数组中的那些属性，</span><br><span class=\"line\">//如果有则让bind对象执行fn方法，该方法传入k和object[k]两个参数</span><br><span class=\"line\">function forEachObjectEnumberableKey(object, fn, bind)&#123;</span><br><span class=\"line\">\tif (enumerables) for (var i = enumerables.length; i--;)&#123;</span><br><span class=\"line\">\t\tvar k = enumerables[i];</span><br><span class=\"line\">\t\t//hasOwnProperty.call(object, k) --&gt; object.hasOwnProperty(k) --&gt;object对象是否有自己的属性k</span><br><span class=\"line\">\t\t//fn.call(bind, k, object[k]) --&gt; bind.fn(k,object[k]) --&gt;bind对象执行fn方法并传入参数k和object[k]</span><br><span class=\"line\">\t\tif (hasOwnProperty.call(object, k)) fn.call(bind, k, object[k]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*&lt;/ltIE8&gt;*/</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<hr>\n<p>title: MooTools 源码分析之Core (未完待续)<br>date: 2016-08-02 17:04:55<br>categories:<br>    MooTools<br>tags:</p>\n<pre><code>- 源码分析\n</code></pre><p>—888<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//代码被包在一个匿名函数的内部，所以这里的this明确指向全局对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">//版本信息</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.MooTools = &#123;</span><br><span class=\"line\">\tversion: <span class=\"string\">'1.6.0'</span>,</span><br><span class=\"line\">\tbuild: <span class=\"string\">'529422872adfff401b901b8b6c7ca5114ee95e2b'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义了typeOf, instanceOf两个函数来替代JS原生的typeof和instanceof方法(注意大小写)</span><br><span class=\"line\"></span><br><span class=\"line\">//定义typeOf方法(注意O大写！),在原生typeof的基础上做了拓展,判断参数类型</span><br><span class=\"line\">var typeOf = this.typeOf = function(item)&#123;</span><br><span class=\"line\">\t//如果对象是null则返回null</span><br><span class=\"line\">\tif (item == null) return &apos;null&apos;;</span><br><span class=\"line\">\tif (item.$family != null) return item.$family();</span><br><span class=\"line\"></span><br><span class=\"line\">\t//判断node类型</span><br><span class=\"line\">\tif (item.nodeName)&#123;</span><br><span class=\"line\">\t\t//如果nodeType的值为1，则返回element</span><br><span class=\"line\">\t\tif (item.nodeType == 1) return &apos;element&apos;;</span><br><span class=\"line\">\t\t//如果nodeType的值为3，判断其有无值，选择返回值或者空白格</span><br><span class=\"line\">\t\tif (item.nodeType == 3) return (/\\S/).test(item.nodeValue) ? &apos;textnode&apos; : &apos;whitespace&apos;;</span><br><span class=\"line\">\t&#125; else if (typeof item.length == &apos;number&apos;)&#123;</span><br><span class=\"line\">\t\tif (&apos;callee&apos; in item) return &apos;arguments&apos;;\t\t\t\t//如果有callee属性的则返回arguments</span><br><span class=\"line\">\t\tif (&apos;item&apos; in item) return &apos;collection&apos;;\t\t\t\t//如果有item属性的则返回collection</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t//如果都不满足则返回原生JS typeof运算符的结果：&quot;undefined&quot;,&quot;boolean&quot;,&quot;string&quot;,&quot;number&quot;,&quot;object&quot;,&quot;function&quot;</span><br><span class=\"line\">\treturn typeof item;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义instanceOf方法(注意O大写！)，在原生instanceof的基础上做了拓展,判断某个对象是否是某个特定类型的实例</span><br><span class=\"line\">var instanceOf = this.instanceOf = function(item, object)&#123;</span><br><span class=\"line\">\t//如果对象为null则返回false</span><br><span class=\"line\">\tif (item == null) return false;</span><br><span class=\"line\">\t//定义constructor属性 判断是否可以追溯到object，如果可以则返回true</span><br><span class=\"line\">\tvar constructor = item.$constructor || item.constructor;</span><br><span class=\"line\">\twhile (constructor)&#123;</span><br><span class=\"line\">\t\tif (constructor === object) return true;</span><br><span class=\"line\">\t\tconstructor = constructor.parent;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/*&lt;ltIE8&gt;*/\t//------------&gt;前后两个/*&lt;ltIE8&gt;*/表示为了兼容IE8.。。。。。。万恶的IE！！！</span><br><span class=\"line\">\tif (!item.hasOwnProperty) return false;</span><br><span class=\"line\">\t/*&lt;/ltIE8&gt;*/</span><br><span class=\"line\">\t//如果都不满足则返回原生JS typeof运算符的结果</span><br><span class=\"line\">\treturn item instanceof object;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var hasOwnProperty = Object.prototype.hasOwnProperty;</span><br><span class=\"line\"></span><br><span class=\"line\">/*&lt;ltIE8&gt;*/</span><br><span class=\"line\"></span><br><span class=\"line\">var enumerables = true;</span><br><span class=\"line\">//对IE中不能遍历对象中toString属性的bug做一个修正</span><br><span class=\"line\">for (var i in &#123;toString: 1&#125;) enumerables = null;</span><br><span class=\"line\">//如果遍历不到则enumerables为true，然后将这些属性暂存到一个数组保存到enumerables中</span><br><span class=\"line\">if (enumerables) enumerables = [&apos;hasOwnProperty&apos;, &apos;valueOf&apos;, &apos;isPrototypeOf&apos;, &apos;propertyIsEnumerable&apos;, &apos;toLocaleString&apos;, &apos;toString&apos;, &apos;constructor&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">//该函数就是传进object和bind两个对象和fn方法，首先遍历判断object对象里是否有enumberables数组中的那些属性，</span><br><span class=\"line\">//如果有则让bind对象执行fn方法，该方法传入k和object[k]两个参数</span><br><span class=\"line\">function forEachObjectEnumberableKey(object, fn, bind)&#123;</span><br><span class=\"line\">\tif (enumerables) for (var i = enumerables.length; i--;)&#123;</span><br><span class=\"line\">\t\tvar k = enumerables[i];</span><br><span class=\"line\">\t\t//hasOwnProperty.call(object, k) --&gt; object.hasOwnProperty(k) --&gt;object对象是否有自己的属性k</span><br><span class=\"line\">\t\t//fn.call(bind, k, object[k]) --&gt; bind.fn(k,object[k]) --&gt;bind对象执行fn方法并传入参数k和object[k]</span><br><span class=\"line\">\t\tif (hasOwnProperty.call(object, k)) fn.call(bind, k, object[k]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*&lt;/ltIE8&gt;*/</span><br></pre></td></tr></table></figure>"},{"title":"一把梯子","date":"2016-04-20T10:34:01.000Z","_content":"昨天晚上躺在床上逛技术贴，发现一个叫做XX-Net的好东西，一时惊为天人，这不，今天早上一起我就迫不及待Download下来看看。弄完试了下的确还不错，装个插件后浏览墙内墙外的网站它自己能够自动切换很方便。\n<!-- more -->\n\nGithub上的地址：https://github.com/XX-net/XX-Net\n里面文档介绍的配置方法很详细，稍微折腾下就可以了。\n\n之前翻墙用的是[ShadowSocks](http://www.fqjiasu.com/)，也蛮好用的。最低只需要6块钱一个月，不过有5个G的使用上限。\n\n\n\n\n\n\n","source":"_posts/一把梯子.md","raw":"---\ntitle: 一把梯子\ndate: 2016-04-20 18:34:01\ncategories:\n\t工具\ntags:\n\t- 翻墙\n\t- XX-Net\n\t- ShadowSocks\n---\n昨天晚上躺在床上逛技术贴，发现一个叫做XX-Net的好东西，一时惊为天人，这不，今天早上一起我就迫不及待Download下来看看。弄完试了下的确还不错，装个插件后浏览墙内墙外的网站它自己能够自动切换很方便。\n<!-- more -->\n\nGithub上的地址：https://github.com/XX-net/XX-Net\n里面文档介绍的配置方法很详细，稍微折腾下就可以了。\n\n之前翻墙用的是[ShadowSocks](http://www.fqjiasu.com/)，也蛮好用的。最低只需要6块钱一个月，不过有5个G的使用上限。\n\n\n\n\n\n\n","slug":"一把梯子","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63wi000rw9uab96h6vbm","content":"<p>昨天晚上躺在床上逛技术贴，发现一个叫做XX-Net的好东西，一时惊为天人，这不，今天早上一起我就迫不及待Download下来看看。弄完试了下的确还不错，装个插件后浏览墙内墙外的网站它自己能够自动切换很方便。<br><a id=\"more\"></a></p>\n<p>Github上的地址：<a href=\"https://github.com/XX-net/XX-Net\" target=\"_blank\" rel=\"noopener\">https://github.com/XX-net/XX-Net</a><br>里面文档介绍的配置方法很详细，稍微折腾下就可以了。</p>\n<p>之前翻墙用的是<a href=\"http://www.fqjiasu.com/\" target=\"_blank\" rel=\"noopener\">ShadowSocks</a>，也蛮好用的。最低只需要6块钱一个月，不过有5个G的使用上限。</p>\n","site":{"data":{}},"excerpt":"<p>昨天晚上躺在床上逛技术贴，发现一个叫做XX-Net的好东西，一时惊为天人，这不，今天早上一起我就迫不及待Download下来看看。弄完试了下的确还不错，装个插件后浏览墙内墙外的网站它自己能够自动切换很方便。<br>","more":"</p>\n<p>Github上的地址：<a href=\"https://github.com/XX-net/XX-Net\" target=\"_blank\" rel=\"noopener\">https://github.com/XX-net/XX-Net</a><br>里面文档介绍的配置方法很详细，稍微折腾下就可以了。</p>\n<p>之前翻墙用的是<a href=\"http://www.fqjiasu.com/\" target=\"_blank\" rel=\"noopener\">ShadowSocks</a>，也蛮好用的。最低只需要6块钱一个月，不过有5个G的使用上限。</p>"},{"title":"关于实习校招","date":"2016-04-16T09:16:23.000Z","_content":"打3月起了解到好几家公司开始实习生招聘后，我就抱着试一试的态度陆陆续续投了几份简历。说来惭愧，可能也是自己不够重视，怀着打酱油的心态，就连简历也没能好好准备。\n<!-- more -->\n\n整个3月份参加了三场笔试，有腾讯，网易和360。三场考试下来，我觉得网易的试题是最好的，倒不是说我答的多好，而是它最让我感受到我是在答前端的笔试。因为学习时间短，知识积累不足，三场笔试就过了360一家，就连过的那场也是踩着线过的。的确我在这知识储备这方面太不足了，总而言之，还是要多看书。\n\n这次360招前端流程比较复杂，笔试过了不是直接面试，而是穿插了一次项目作业和培训。而我递交的作业没能通过筛选，最后只能止步这一环节。现在想想挺可惜的，只恨当时做那份项目作业没能多思考多拓展一些细节，只想着早点交上去。不过说实在的，这份作业给了我许多体会，让我感受到只是单单看书看资料是远远不够的，编程这玩意说白了还得靠项目实践，靠代码量。真应了那句 “无他，唯手熟尔”。\n\n尽管这次没能得到一个理想的结果，但是我也从中感受到了自己离目标的差距，也算为自己点亮了新地图，知道自己该往什么方向努力。\n\n公主已经死去，屠龙的勇士还在燃烧！","source":"_posts/关于实习校招.md","raw":"---\ntitle: 关于实习校招\ndate: 2016-04-16 17:16:23\ncategories: \n\t随笔\ntags:\n \tblog\n---\n打3月起了解到好几家公司开始实习生招聘后，我就抱着试一试的态度陆陆续续投了几份简历。说来惭愧，可能也是自己不够重视，怀着打酱油的心态，就连简历也没能好好准备。\n<!-- more -->\n\n整个3月份参加了三场笔试，有腾讯，网易和360。三场考试下来，我觉得网易的试题是最好的，倒不是说我答的多好，而是它最让我感受到我是在答前端的笔试。因为学习时间短，知识积累不足，三场笔试就过了360一家，就连过的那场也是踩着线过的。的确我在这知识储备这方面太不足了，总而言之，还是要多看书。\n\n这次360招前端流程比较复杂，笔试过了不是直接面试，而是穿插了一次项目作业和培训。而我递交的作业没能通过筛选，最后只能止步这一环节。现在想想挺可惜的，只恨当时做那份项目作业没能多思考多拓展一些细节，只想着早点交上去。不过说实在的，这份作业给了我许多体会，让我感受到只是单单看书看资料是远远不够的，编程这玩意说白了还得靠项目实践，靠代码量。真应了那句 “无他，唯手熟尔”。\n\n尽管这次没能得到一个理想的结果，但是我也从中感受到了自己离目标的差距，也算为自己点亮了新地图，知道自己该往什么方向努力。\n\n公主已经死去，屠龙的勇士还在燃烧！","slug":"关于实习校招","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63wk000vw9ua70js2qf7","content":"<p>打3月起了解到好几家公司开始实习生招聘后，我就抱着试一试的态度陆陆续续投了几份简历。说来惭愧，可能也是自己不够重视，怀着打酱油的心态，就连简历也没能好好准备。<br><a id=\"more\"></a></p>\n<p>整个3月份参加了三场笔试，有腾讯，网易和360。三场考试下来，我觉得网易的试题是最好的，倒不是说我答的多好，而是它最让我感受到我是在答前端的笔试。因为学习时间短，知识积累不足，三场笔试就过了360一家，就连过的那场也是踩着线过的。的确我在这知识储备这方面太不足了，总而言之，还是要多看书。</p>\n<p>这次360招前端流程比较复杂，笔试过了不是直接面试，而是穿插了一次项目作业和培训。而我递交的作业没能通过筛选，最后只能止步这一环节。现在想想挺可惜的，只恨当时做那份项目作业没能多思考多拓展一些细节，只想着早点交上去。不过说实在的，这份作业给了我许多体会，让我感受到只是单单看书看资料是远远不够的，编程这玩意说白了还得靠项目实践，靠代码量。真应了那句 “无他，唯手熟尔”。</p>\n<p>尽管这次没能得到一个理想的结果，但是我也从中感受到了自己离目标的差距，也算为自己点亮了新地图，知道自己该往什么方向努力。</p>\n<p>公主已经死去，屠龙的勇士还在燃烧！</p>\n","site":{"data":{}},"excerpt":"<p>打3月起了解到好几家公司开始实习生招聘后，我就抱着试一试的态度陆陆续续投了几份简历。说来惭愧，可能也是自己不够重视，怀着打酱油的心态，就连简历也没能好好准备。<br>","more":"</p>\n<p>整个3月份参加了三场笔试，有腾讯，网易和360。三场考试下来，我觉得网易的试题是最好的，倒不是说我答的多好，而是它最让我感受到我是在答前端的笔试。因为学习时间短，知识积累不足，三场笔试就过了360一家，就连过的那场也是踩着线过的。的确我在这知识储备这方面太不足了，总而言之，还是要多看书。</p>\n<p>这次360招前端流程比较复杂，笔试过了不是直接面试，而是穿插了一次项目作业和培训。而我递交的作业没能通过筛选，最后只能止步这一环节。现在想想挺可惜的，只恨当时做那份项目作业没能多思考多拓展一些细节，只想着早点交上去。不过说实在的，这份作业给了我许多体会，让我感受到只是单单看书看资料是远远不够的，编程这玩意说白了还得靠项目实践，靠代码量。真应了那句 “无他，唯手熟尔”。</p>\n<p>尽管这次没能得到一个理想的结果，但是我也从中感受到了自己离目标的差距，也算为自己点亮了新地图，知道自己该往什么方向努力。</p>\n<p>公主已经死去，屠龙的勇士还在燃烧！</p>"},{"title":"回望","date":"2016-05-12T05:16:23.000Z","_content":"一晃半个多月过去了，说实话这段时间过得蛮荒废的。\n<!-- more -->\n之前看过一个演说，讲到人的拖延症。里面说到每个人或多或少都有点拖延症，一份限时一个月的报告想着剩半个月再做，等到了半个月又拖到最后一礼拜…等到最后一两天实在不能拖，然后加班加点粗制滥造，最后结果难免不尽人意。而当遇到没有期限的工作，一旦拖延起来，那完成也就遥遥无期，也许就像温水煮青蛙，只有在大难临头的刹那才会想到挣扎，而那时必然已经来不及了。\n\n想到自己，深思极恐，半个多月的时间，如果我能坚持每天学习的话，说不定我已经把js的红宝书看一半了，说不定我能练手两三个实战项目了。可我就让它就像水一样白白流过，没有留下一点痕迹，没有任何收获，想起来的只是我作为一个人类在这叫做地球的星球上生存了半个月。想到这里，我一阵惊慌，到底有多少个这样的半个月从我眼前掠过。而我如果再这样无所谓，不有所改变的话，那也许一切的理想都是妄谈。\n\n我在想如果我之前没有写博客，就这么过了半个月也许不会有这么大的感触，而当我看到半个多月没有更新，然后再想起这段时间的无所事事，对于自己有种罪恶感，让我回望过去，鞭策自己。\n\n知乎上有句很经典的话“种一棵树最好的时间是十年前，其次是现在。”","source":"_posts/回望.md","raw":"---\ntitle: 回望\ndate: 2016-05-12 13:16:23\ncategories: \n\t随笔\ntags:\n \tblog\n---\n一晃半个多月过去了，说实话这段时间过得蛮荒废的。\n<!-- more -->\n之前看过一个演说，讲到人的拖延症。里面说到每个人或多或少都有点拖延症，一份限时一个月的报告想着剩半个月再做，等到了半个月又拖到最后一礼拜…等到最后一两天实在不能拖，然后加班加点粗制滥造，最后结果难免不尽人意。而当遇到没有期限的工作，一旦拖延起来，那完成也就遥遥无期，也许就像温水煮青蛙，只有在大难临头的刹那才会想到挣扎，而那时必然已经来不及了。\n\n想到自己，深思极恐，半个多月的时间，如果我能坚持每天学习的话，说不定我已经把js的红宝书看一半了，说不定我能练手两三个实战项目了。可我就让它就像水一样白白流过，没有留下一点痕迹，没有任何收获，想起来的只是我作为一个人类在这叫做地球的星球上生存了半个月。想到这里，我一阵惊慌，到底有多少个这样的半个月从我眼前掠过。而我如果再这样无所谓，不有所改变的话，那也许一切的理想都是妄谈。\n\n我在想如果我之前没有写博客，就这么过了半个月也许不会有这么大的感触，而当我看到半个多月没有更新，然后再想起这段时间的无所事事，对于自己有种罪恶感，让我回望过去，鞭策自己。\n\n知乎上有句很经典的话“种一棵树最好的时间是十年前，其次是现在。”","slug":"回望","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63wl000yw9uauep5u2fq","content":"<p>一晃半个多月过去了，说实话这段时间过得蛮荒废的。<br><a id=\"more\"></a><br>之前看过一个演说，讲到人的拖延症。里面说到每个人或多或少都有点拖延症，一份限时一个月的报告想着剩半个月再做，等到了半个月又拖到最后一礼拜…等到最后一两天实在不能拖，然后加班加点粗制滥造，最后结果难免不尽人意。而当遇到没有期限的工作，一旦拖延起来，那完成也就遥遥无期，也许就像温水煮青蛙，只有在大难临头的刹那才会想到挣扎，而那时必然已经来不及了。</p>\n<p>想到自己，深思极恐，半个多月的时间，如果我能坚持每天学习的话，说不定我已经把js的红宝书看一半了，说不定我能练手两三个实战项目了。可我就让它就像水一样白白流过，没有留下一点痕迹，没有任何收获，想起来的只是我作为一个人类在这叫做地球的星球上生存了半个月。想到这里，我一阵惊慌，到底有多少个这样的半个月从我眼前掠过。而我如果再这样无所谓，不有所改变的话，那也许一切的理想都是妄谈。</p>\n<p>我在想如果我之前没有写博客，就这么过了半个月也许不会有这么大的感触，而当我看到半个多月没有更新，然后再想起这段时间的无所事事，对于自己有种罪恶感，让我回望过去，鞭策自己。</p>\n<p>知乎上有句很经典的话“种一棵树最好的时间是十年前，其次是现在。”</p>\n","site":{"data":{}},"excerpt":"<p>一晃半个多月过去了，说实话这段时间过得蛮荒废的。<br>","more":"<br>之前看过一个演说，讲到人的拖延症。里面说到每个人或多或少都有点拖延症，一份限时一个月的报告想着剩半个月再做，等到了半个月又拖到最后一礼拜…等到最后一两天实在不能拖，然后加班加点粗制滥造，最后结果难免不尽人意。而当遇到没有期限的工作，一旦拖延起来，那完成也就遥遥无期，也许就像温水煮青蛙，只有在大难临头的刹那才会想到挣扎，而那时必然已经来不及了。</p>\n<p>想到自己，深思极恐，半个多月的时间，如果我能坚持每天学习的话，说不定我已经把js的红宝书看一半了，说不定我能练手两三个实战项目了。可我就让它就像水一样白白流过，没有留下一点痕迹，没有任何收获，想起来的只是我作为一个人类在这叫做地球的星球上生存了半个月。想到这里，我一阵惊慌，到底有多少个这样的半个月从我眼前掠过。而我如果再这样无所谓，不有所改变的话，那也许一切的理想都是妄谈。</p>\n<p>我在想如果我之前没有写博客，就这么过了半个月也许不会有这么大的感触，而当我看到半个多月没有更新，然后再想起这段时间的无所事事，对于自己有种罪恶感，让我回望过去，鞭策自己。</p>\n<p>知乎上有句很经典的话“种一棵树最好的时间是十年前，其次是现在。”</p>"},{"title":"是时候开始一门后端语言了","date":"2016-08-08T10:50:11.000Z","_content":"一直以来就有好好认真系统地学一门后端语言，毕竟学前端不能局限自己只是个切图仔，只会做静态页面。\n\n之前有纠结过是该学node.js还是php还是python。后来发现纠结学什么并不重要，重要的是现在就开始学。\n<!-- more -->\n语言都是相通的，真正学好一门，以后再去学另一门也容易上手了。\n\n所以，Just do it!\n","source":"_posts/是时候开始一门后端语言了.md","raw":"---\ntitle: 是时候开始一门后端语言了\ndate: 2016-08-08 18:50:11\ncategories:\n\t随笔\ntags:\n\t- 学习\n---\n一直以来就有好好认真系统地学一门后端语言，毕竟学前端不能局限自己只是个切图仔，只会做静态页面。\n\n之前有纠结过是该学node.js还是php还是python。后来发现纠结学什么并不重要，重要的是现在就开始学。\n<!-- more -->\n语言都是相通的，真正学好一门，以后再去学另一门也容易上手了。\n\n所以，Just do it!\n","slug":"是时候开始一门后端语言了","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63wm0011w9uahlmvchap","content":"<p>一直以来就有好好认真系统地学一门后端语言，毕竟学前端不能局限自己只是个切图仔，只会做静态页面。</p>\n<p>之前有纠结过是该学node.js还是php还是python。后来发现纠结学什么并不重要，重要的是现在就开始学。<br><a id=\"more\"></a><br>语言都是相通的，真正学好一门，以后再去学另一门也容易上手了。</p>\n<p>所以，Just do it!</p>\n","site":{"data":{}},"excerpt":"<p>一直以来就有好好认真系统地学一门后端语言，毕竟学前端不能局限自己只是个切图仔，只会做静态页面。</p>\n<p>之前有纠结过是该学node.js还是php还是python。后来发现纠结学什么并不重要，重要的是现在就开始学。<br>","more":"<br>语言都是相通的，真正学好一门，以后再去学另一门也容易上手了。</p>\n<p>所以，Just do it!</p>"},{"title":"我们的征途是星辰大海！","date":"2016-07-27T12:06:53.000Z","_content":"“我们的征途是星辰大海！”\n<!-- more -->\n不知道为什么今天的脑海里一直浮现着这句话。可能是我注定是天选之人，是上帝给我的暗示吧！\n好了，不意淫了。少年还是快醒醒吧。。\n\n暑假留校已经大半个月了，讲道理这段时间过得还是挺充实的。每天都在知识的海洋里摇荡啊摇荡的，简直不要太满足。平心而论这几天我真的蛮认真的，除了前两天天津下暴雨我没出来，其他日子我都几乎一整天都呆在图书馆。下雨那天真的可怕，大马路都被淹了。我还以为就我们那里会发大水，没想到天津这里要不不下雨，一下起来也是惊心动魄。下雨就下雨吧，关键它下完雨后还非常的热。那种湿热！真~~特么~~受不了！\n\n这个暑假是我最期盼有个女朋友的暑假。为什么呢？因为可以用上单身狗梦寐以求但是不敢用的神器！遮阳伞！\n\n前段日子想着找点出去找实习，后来发现各大公司八九月份陆续都开始校招了，想想好好准备校招吧，到时候搭不上校招这趟高铁，再回来坐这绿皮火车去小作坊吧。话说天津这边心仪的互联网公司真的不多，机会也要少好多。陆陆续续投了好几份简历，网易啦，阿里啦我也都投了，人总得有个盼头，你说不是，万一一不小心就进了呢！\n\n好了，最后来一句！\"我们的征途是星辰大海!\"\n","source":"_posts/我们的征途是星辰大海！.md","raw":"---\ntitle: 我们的征途是星辰大海！\ndate: 2016-07-27 20:06:53\ncategories:\n\t随笔\ntags:\n\t- 校招\n\t- 梦想\n---\n“我们的征途是星辰大海！”\n<!-- more -->\n不知道为什么今天的脑海里一直浮现着这句话。可能是我注定是天选之人，是上帝给我的暗示吧！\n好了，不意淫了。少年还是快醒醒吧。。\n\n暑假留校已经大半个月了，讲道理这段时间过得还是挺充实的。每天都在知识的海洋里摇荡啊摇荡的，简直不要太满足。平心而论这几天我真的蛮认真的，除了前两天天津下暴雨我没出来，其他日子我都几乎一整天都呆在图书馆。下雨那天真的可怕，大马路都被淹了。我还以为就我们那里会发大水，没想到天津这里要不不下雨，一下起来也是惊心动魄。下雨就下雨吧，关键它下完雨后还非常的热。那种湿热！真~~特么~~受不了！\n\n这个暑假是我最期盼有个女朋友的暑假。为什么呢？因为可以用上单身狗梦寐以求但是不敢用的神器！遮阳伞！\n\n前段日子想着找点出去找实习，后来发现各大公司八九月份陆续都开始校招了，想想好好准备校招吧，到时候搭不上校招这趟高铁，再回来坐这绿皮火车去小作坊吧。话说天津这边心仪的互联网公司真的不多，机会也要少好多。陆陆续续投了好几份简历，网易啦，阿里啦我也都投了，人总得有个盼头，你说不是，万一一不小心就进了呢！\n\n好了，最后来一句！\"我们的征途是星辰大海!\"\n","slug":"我们的征途是星辰大海！","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63wn0013w9ua1xo2a7i1","content":"<p>“我们的征途是星辰大海！”<br><a id=\"more\"></a><br>不知道为什么今天的脑海里一直浮现着这句话。可能是我注定是天选之人，是上帝给我的暗示吧！<br>好了，不意淫了。少年还是快醒醒吧。。</p>\n<p>暑假留校已经大半个月了，讲道理这段时间过得还是挺充实的。每天都在知识的海洋里摇荡啊摇荡的，简直不要太满足。平心而论这几天我真的蛮认真的，除了前两天天津下暴雨我没出来，其他日子我都几乎一整天都呆在图书馆。下雨那天真的可怕，大马路都被淹了。我还以为就我们那里会发大水，没想到天津这里要不不下雨，一下起来也是惊心动魄。下雨就下雨吧，关键它下完雨后还非常的热。那种湿热！真<del>特么</del>受不了！</p>\n<p>这个暑假是我最期盼有个女朋友的暑假。为什么呢？因为可以用上单身狗梦寐以求但是不敢用的神器！遮阳伞！</p>\n<p>前段日子想着找点出去找实习，后来发现各大公司八九月份陆续都开始校招了，想想好好准备校招吧，到时候搭不上校招这趟高铁，再回来坐这绿皮火车去小作坊吧。话说天津这边心仪的互联网公司真的不多，机会也要少好多。陆陆续续投了好几份简历，网易啦，阿里啦我也都投了，人总得有个盼头，你说不是，万一一不小心就进了呢！</p>\n<p>好了，最后来一句！”我们的征途是星辰大海!”</p>\n","site":{"data":{}},"excerpt":"<p>“我们的征途是星辰大海！”<br>","more":"<br>不知道为什么今天的脑海里一直浮现着这句话。可能是我注定是天选之人，是上帝给我的暗示吧！<br>好了，不意淫了。少年还是快醒醒吧。。</p>\n<p>暑假留校已经大半个月了，讲道理这段时间过得还是挺充实的。每天都在知识的海洋里摇荡啊摇荡的，简直不要太满足。平心而论这几天我真的蛮认真的，除了前两天天津下暴雨我没出来，其他日子我都几乎一整天都呆在图书馆。下雨那天真的可怕，大马路都被淹了。我还以为就我们那里会发大水，没想到天津这里要不不下雨，一下起来也是惊心动魄。下雨就下雨吧，关键它下完雨后还非常的热。那种湿热！真<del>特么</del>受不了！</p>\n<p>这个暑假是我最期盼有个女朋友的暑假。为什么呢？因为可以用上单身狗梦寐以求但是不敢用的神器！遮阳伞！</p>\n<p>前段日子想着找点出去找实习，后来发现各大公司八九月份陆续都开始校招了，想想好好准备校招吧，到时候搭不上校招这趟高铁，再回来坐这绿皮火车去小作坊吧。话说天津这边心仪的互联网公司真的不多，机会也要少好多。陆陆续续投了好几份简历，网易啦，阿里啦我也都投了，人总得有个盼头，你说不是，万一一不小心就进了呢！</p>\n<p>好了，最后来一句！”我们的征途是星辰大海!”</p>"},{"title":"留校以后","date":"2016-07-17T08:04:23.000Z","_content":"放假一个星期了，和宿舍里另一个留校的同学相依为命了一周，颇有些感慨。\n<!-- more -->\n\n之前都买好了暑假回家的火车票，但就像受了什么刺激导致我临时决定留校。可能是遇到什么感情受挫。好吧，其实是扯淡。真正留下来的原因是就要大四了，既然决定不考研就得好好找实习了，一来总感觉自己在前端方面找实习还差点，二来家离学校实在太远，如果回去找，大四这年不太方便。\n\n虽然留校条件是挺差的。我就不说某天晚上回寝室开个灯，再开个风扇，”啪“就跳闸了。。。宝宝心里苦啊。。好在这几天天津也不是很热，再者白天基本都泡在图书馆，也就没觉得日子有多难过。\n\n之前预期着再看个把月的书，巩固巩固知识，好好准备些项目再去找实习。后来想想边做边学似乎更加好，想来通过项目来巩固自己是最好的。所以估摸着这几天完善完善自己的简历，整理下做的那些个项目就准备去撒网了。\n\n学而不思则罔，思而不学则殆。老祖宗的话总是那么精炼而耐人寻味。","source":"_posts/留校以后.md","raw":"---\ntitle: 留校以后\ndate: 2016-07-17 16:04:23\ncategories: \n\t随笔\ntags:\n \tblog\n---\n放假一个星期了，和宿舍里另一个留校的同学相依为命了一周，颇有些感慨。\n<!-- more -->\n\n之前都买好了暑假回家的火车票，但就像受了什么刺激导致我临时决定留校。可能是遇到什么感情受挫。好吧，其实是扯淡。真正留下来的原因是就要大四了，既然决定不考研就得好好找实习了，一来总感觉自己在前端方面找实习还差点，二来家离学校实在太远，如果回去找，大四这年不太方便。\n\n虽然留校条件是挺差的。我就不说某天晚上回寝室开个灯，再开个风扇，”啪“就跳闸了。。。宝宝心里苦啊。。好在这几天天津也不是很热，再者白天基本都泡在图书馆，也就没觉得日子有多难过。\n\n之前预期着再看个把月的书，巩固巩固知识，好好准备些项目再去找实习。后来想想边做边学似乎更加好，想来通过项目来巩固自己是最好的。所以估摸着这几天完善完善自己的简历，整理下做的那些个项目就准备去撒网了。\n\n学而不思则罔，思而不学则殆。老祖宗的话总是那么精炼而耐人寻味。","slug":"留校以后","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63wr0017w9ua65qh5tqy","content":"<p>放假一个星期了，和宿舍里另一个留校的同学相依为命了一周，颇有些感慨。<br><a id=\"more\"></a></p>\n<p>之前都买好了暑假回家的火车票，但就像受了什么刺激导致我临时决定留校。可能是遇到什么感情受挫。好吧，其实是扯淡。真正留下来的原因是就要大四了，既然决定不考研就得好好找实习了，一来总感觉自己在前端方面找实习还差点，二来家离学校实在太远，如果回去找，大四这年不太方便。</p>\n<p>虽然留校条件是挺差的。我就不说某天晚上回寝室开个灯，再开个风扇，”啪“就跳闸了。。。宝宝心里苦啊。。好在这几天天津也不是很热，再者白天基本都泡在图书馆，也就没觉得日子有多难过。</p>\n<p>之前预期着再看个把月的书，巩固巩固知识，好好准备些项目再去找实习。后来想想边做边学似乎更加好，想来通过项目来巩固自己是最好的。所以估摸着这几天完善完善自己的简历，整理下做的那些个项目就准备去撒网了。</p>\n<p>学而不思则罔，思而不学则殆。老祖宗的话总是那么精炼而耐人寻味。</p>\n","site":{"data":{}},"excerpt":"<p>放假一个星期了，和宿舍里另一个留校的同学相依为命了一周，颇有些感慨。<br>","more":"</p>\n<p>之前都买好了暑假回家的火车票，但就像受了什么刺激导致我临时决定留校。可能是遇到什么感情受挫。好吧，其实是扯淡。真正留下来的原因是就要大四了，既然决定不考研就得好好找实习了，一来总感觉自己在前端方面找实习还差点，二来家离学校实在太远，如果回去找，大四这年不太方便。</p>\n<p>虽然留校条件是挺差的。我就不说某天晚上回寝室开个灯，再开个风扇，”啪“就跳闸了。。。宝宝心里苦啊。。好在这几天天津也不是很热，再者白天基本都泡在图书馆，也就没觉得日子有多难过。</p>\n<p>之前预期着再看个把月的书，巩固巩固知识，好好准备些项目再去找实习。后来想想边做边学似乎更加好，想来通过项目来巩固自己是最好的。所以估摸着这几天完善完善自己的简历，整理下做的那些个项目就准备去撒网了。</p>\n<p>学而不思则罔，思而不学则殆。老祖宗的话总是那么精炼而耐人寻味。</p>"},{"title":"ES6学习笔记之let和const","date":"2016-09-06T02:15:55.000Z","_content":"## 块级作用域\nJavaScript的ES5规范中只有全局作用域和函数作用域，这带来很多不合理的地方。比如内层变量覆盖外层变量,用来计数的循环变量泄露为全局变量。ES6中为我们提供了let和const命令来构造块级作用域。\n<!-- more -->\n## let命令\nES6新增了let命令来申明变量，其用法类似var。不过let声明的变量，只在所在的代码块内有效。也就是形成了JavaScript所没有的**块级作用域**。\n### 基本用法\n直接来例子：\n```\n{\n    let a = 2;\n    var b = 3;\n}\nconsole.log(a);   //ReferenceError: a is not defined.\nconsole.log(b);   //3\n```\n在代码块中，分别用let和var声明了两个变量，然后在代码块外调用了这两个变量，结果var声明的变量返回了正确的值，而let声明的变量报错。这表明了let声明的变量只在它所在的代码块中有效 。\n\nlet声明在循环中极其好用，之前在闭包中有提到：[JavaScript 闭包](http://smilebug.me/2016/07/26/JavaScript-%E9%97%AD%E5%8C%85/);\n### 不存在变量提升\n总所周知，var声明变量和函数声明都会提前，而let声明不会，变量在声明前使用就会报错。\n例如：\n```\nconsole.log(a); ////ReferenceError: a is not defined.\nconsole.log(b); //undefined\nlet a = 2;\nvar b = 3;\n```\n### 暂时性死区\n如果区块中存在let命令，这个区块对以let声明的变量，从一开始就行形成了封闭作用域。凡是在声明前就使用这些变量，就会报错。（总之，在代码块内，使用let声明变量前，该变量都是不可用的，即使在全局作用域中有这个对象）\n例如：\n```\nvar a = 2;\n{\n    console.log(a); //ReferenceError: a is not defined\n    let a = 3;\n}\n```\n### 不允许重复声明\nlet不允许在相同作用域内，重复声明同一个变量。因此也不能在函数内部重新声明参数。\n## const命令\nES6中的const命令声明一个只读的常量，一旦声明，常量的值就不能改变，这也意味着，const一旦声明变量就必须立即赋值，而不能等到以后赋值。\n### const使用注意\nconst的作用域和let相同：只在声明的块级作用域中有效。\n\nconst命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。\n\nconst声明的常量，也与let一样不可重复声明。\n### 复合类型的变量声明\n对于复合类型的变量，变量名不指向数据，而指向数据所在的地址。const命令只是保证变量名指向的地址不变，而不保证该地址的数据不变。\n## 全局对象的属性\n全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。ES5之中，全局对象的属性与全局变量是等价的。\nES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是全局对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。\n```\nvar a = 1;\nconsole.log(a);  //1\nlet b = 2;\nconsle.log(b)  //undefined\n```\n上面代码中，全局变量a由var命令声明，所以它是全局对象的属性；全局变量b由let命令声明，所以它不是全局对象的属性，返回undefined。\n## 资料参考\n[《ES6 标准入门》](http://es6.ruanyifeng.com/#docs/let)\n","source":"_posts/ES6学习笔记之let和const.md","raw":"---\ntitle: ES6学习笔记之let和const\ndate: 2016-09-06 10:15:55\ncategories:\n\tES6\ntags:\n\t- let\n\t- const\n\t- 块级作用域\n---\n## 块级作用域\nJavaScript的ES5规范中只有全局作用域和函数作用域，这带来很多不合理的地方。比如内层变量覆盖外层变量,用来计数的循环变量泄露为全局变量。ES6中为我们提供了let和const命令来构造块级作用域。\n<!-- more -->\n## let命令\nES6新增了let命令来申明变量，其用法类似var。不过let声明的变量，只在所在的代码块内有效。也就是形成了JavaScript所没有的**块级作用域**。\n### 基本用法\n直接来例子：\n```\n{\n    let a = 2;\n    var b = 3;\n}\nconsole.log(a);   //ReferenceError: a is not defined.\nconsole.log(b);   //3\n```\n在代码块中，分别用let和var声明了两个变量，然后在代码块外调用了这两个变量，结果var声明的变量返回了正确的值，而let声明的变量报错。这表明了let声明的变量只在它所在的代码块中有效 。\n\nlet声明在循环中极其好用，之前在闭包中有提到：[JavaScript 闭包](http://smilebug.me/2016/07/26/JavaScript-%E9%97%AD%E5%8C%85/);\n### 不存在变量提升\n总所周知，var声明变量和函数声明都会提前，而let声明不会，变量在声明前使用就会报错。\n例如：\n```\nconsole.log(a); ////ReferenceError: a is not defined.\nconsole.log(b); //undefined\nlet a = 2;\nvar b = 3;\n```\n### 暂时性死区\n如果区块中存在let命令，这个区块对以let声明的变量，从一开始就行形成了封闭作用域。凡是在声明前就使用这些变量，就会报错。（总之，在代码块内，使用let声明变量前，该变量都是不可用的，即使在全局作用域中有这个对象）\n例如：\n```\nvar a = 2;\n{\n    console.log(a); //ReferenceError: a is not defined\n    let a = 3;\n}\n```\n### 不允许重复声明\nlet不允许在相同作用域内，重复声明同一个变量。因此也不能在函数内部重新声明参数。\n## const命令\nES6中的const命令声明一个只读的常量，一旦声明，常量的值就不能改变，这也意味着，const一旦声明变量就必须立即赋值，而不能等到以后赋值。\n### const使用注意\nconst的作用域和let相同：只在声明的块级作用域中有效。\n\nconst命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。\n\nconst声明的常量，也与let一样不可重复声明。\n### 复合类型的变量声明\n对于复合类型的变量，变量名不指向数据，而指向数据所在的地址。const命令只是保证变量名指向的地址不变，而不保证该地址的数据不变。\n## 全局对象的属性\n全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。ES5之中，全局对象的属性与全局变量是等价的。\nES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是全局对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。\n```\nvar a = 1;\nconsole.log(a);  //1\nlet b = 2;\nconsle.log(b)  //undefined\n```\n上面代码中，全局变量a由var命令声明，所以它是全局对象的属性；全局变量b由let命令声明，所以它不是全局对象的属性，返回undefined。\n## 资料参考\n[《ES6 标准入门》](http://es6.ruanyifeng.com/#docs/let)\n","slug":"ES6学习笔记之let和const","published":1,"updated":"2016-10-07T21:25:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlov63ws001bw9uavz6eh3i4","content":"<h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><p>JavaScript的ES5规范中只有全局作用域和函数作用域，这带来很多不合理的地方。比如内层变量覆盖外层变量,用来计数的循环变量泄露为全局变量。ES6中为我们提供了let和const命令来构造块级作用域。<br><a id=\"more\"></a></p>\n<h2 id=\"let命令\"><a href=\"#let命令\" class=\"headerlink\" title=\"let命令\"></a>let命令</h2><p>ES6新增了let命令来申明变量，其用法类似var。不过let声明的变量，只在所在的代码块内有效。也就是形成了JavaScript所没有的<strong>块级作用域</strong>。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>直接来例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    let a = 2;</span><br><span class=\"line\">    var b = 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(a);   //ReferenceError: a is not defined.</span><br><span class=\"line\">console.log(b);   //3</span><br></pre></td></tr></table></figure></p>\n<p>在代码块中，分别用let和var声明了两个变量，然后在代码块外调用了这两个变量，结果var声明的变量返回了正确的值，而let声明的变量报错。这表明了let声明的变量只在它所在的代码块中有效 。</p>\n<p>let声明在循环中极其好用，之前在闭包中有提到：<a href=\"http://smilebug.me/2016/07/26/JavaScript-%E9%97%AD%E5%8C%85/\" target=\"_blank\" rel=\"noopener\">JavaScript 闭包</a>;</p>\n<h3 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h3><p>总所周知，var声明变量和函数声明都会提前，而let声明不会，变量在声明前使用就会报错。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a); ////ReferenceError: a is not defined.</span><br><span class=\"line\">console.log(b); //undefined</span><br><span class=\"line\">let a = 2;</span><br><span class=\"line\">var b = 3;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h3><p>如果区块中存在let命令，这个区块对以let声明的变量，从一开始就行形成了封闭作用域。凡是在声明前就使用这些变量，就会报错。（总之，在代码块内，使用let声明变量前，该变量都是不可用的，即使在全局作用域中有这个对象）<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    console.log(a); //ReferenceError: a is not defined</span><br><span class=\"line\">    let a = 3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h3><p>let不允许在相同作用域内，重复声明同一个变量。因此也不能在函数内部重新声明参数。</p>\n<h2 id=\"const命令\"><a href=\"#const命令\" class=\"headerlink\" title=\"const命令\"></a>const命令</h2><p>ES6中的const命令声明一个只读的常量，一旦声明，常量的值就不能改变，这也意味着，const一旦声明变量就必须立即赋值，而不能等到以后赋值。</p>\n<h3 id=\"const使用注意\"><a href=\"#const使用注意\" class=\"headerlink\" title=\"const使用注意\"></a>const使用注意</h3><p>const的作用域和let相同：只在声明的块级作用域中有效。</p>\n<p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>\n<p>const声明的常量，也与let一样不可重复声明。</p>\n<h3 id=\"复合类型的变量声明\"><a href=\"#复合类型的变量声明\" class=\"headerlink\" title=\"复合类型的变量声明\"></a>复合类型的变量声明</h3><p>对于复合类型的变量，变量名不指向数据，而指向数据所在的地址。const命令只是保证变量名指向的地址不变，而不保证该地址的数据不变。</p>\n<h2 id=\"全局对象的属性\"><a href=\"#全局对象的属性\" class=\"headerlink\" title=\"全局对象的属性\"></a>全局对象的属性</h2><p>全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。ES5之中，全局对象的属性与全局变量是等价的。<br>ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是全局对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">console.log(a);  //1</span><br><span class=\"line\">let b = 2;</span><br><span class=\"line\">consle.log(b)  //undefined</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，全局变量a由var命令声明，所以它是全局对象的属性；全局变量b由let命令声明，所以它不是全局对象的属性，返回undefined。</p>\n<h2 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h2><p><a href=\"http://es6.ruanyifeng.com/#docs/let\" target=\"_blank\" rel=\"noopener\">《ES6 标准入门》</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><p>JavaScript的ES5规范中只有全局作用域和函数作用域，这带来很多不合理的地方。比如内层变量覆盖外层变量,用来计数的循环变量泄露为全局变量。ES6中为我们提供了let和const命令来构造块级作用域。<br>","more":"</p>\n<h2 id=\"let命令\"><a href=\"#let命令\" class=\"headerlink\" title=\"let命令\"></a>let命令</h2><p>ES6新增了let命令来申明变量，其用法类似var。不过let声明的变量，只在所在的代码块内有效。也就是形成了JavaScript所没有的<strong>块级作用域</strong>。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>直接来例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    let a = 2;</span><br><span class=\"line\">    var b = 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(a);   //ReferenceError: a is not defined.</span><br><span class=\"line\">console.log(b);   //3</span><br></pre></td></tr></table></figure></p>\n<p>在代码块中，分别用let和var声明了两个变量，然后在代码块外调用了这两个变量，结果var声明的变量返回了正确的值，而let声明的变量报错。这表明了let声明的变量只在它所在的代码块中有效 。</p>\n<p>let声明在循环中极其好用，之前在闭包中有提到：<a href=\"http://smilebug.me/2016/07/26/JavaScript-%E9%97%AD%E5%8C%85/\" target=\"_blank\" rel=\"noopener\">JavaScript 闭包</a>;</p>\n<h3 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h3><p>总所周知，var声明变量和函数声明都会提前，而let声明不会，变量在声明前使用就会报错。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a); ////ReferenceError: a is not defined.</span><br><span class=\"line\">console.log(b); //undefined</span><br><span class=\"line\">let a = 2;</span><br><span class=\"line\">var b = 3;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h3><p>如果区块中存在let命令，这个区块对以let声明的变量，从一开始就行形成了封闭作用域。凡是在声明前就使用这些变量，就会报错。（总之，在代码块内，使用let声明变量前，该变量都是不可用的，即使在全局作用域中有这个对象）<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    console.log(a); //ReferenceError: a is not defined</span><br><span class=\"line\">    let a = 3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h3><p>let不允许在相同作用域内，重复声明同一个变量。因此也不能在函数内部重新声明参数。</p>\n<h2 id=\"const命令\"><a href=\"#const命令\" class=\"headerlink\" title=\"const命令\"></a>const命令</h2><p>ES6中的const命令声明一个只读的常量，一旦声明，常量的值就不能改变，这也意味着，const一旦声明变量就必须立即赋值，而不能等到以后赋值。</p>\n<h3 id=\"const使用注意\"><a href=\"#const使用注意\" class=\"headerlink\" title=\"const使用注意\"></a>const使用注意</h3><p>const的作用域和let相同：只在声明的块级作用域中有效。</p>\n<p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>\n<p>const声明的常量，也与let一样不可重复声明。</p>\n<h3 id=\"复合类型的变量声明\"><a href=\"#复合类型的变量声明\" class=\"headerlink\" title=\"复合类型的变量声明\"></a>复合类型的变量声明</h3><p>对于复合类型的变量，变量名不指向数据，而指向数据所在的地址。const命令只是保证变量名指向的地址不变，而不保证该地址的数据不变。</p>\n<h2 id=\"全局对象的属性\"><a href=\"#全局对象的属性\" class=\"headerlink\" title=\"全局对象的属性\"></a>全局对象的属性</h2><p>全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。ES5之中，全局对象的属性与全局变量是等价的。<br>ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是全局对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">console.log(a);  //1</span><br><span class=\"line\">let b = 2;</span><br><span class=\"line\">consle.log(b)  //undefined</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，全局变量a由var命令声明，所以它是全局对象的属性；全局变量b由let命令声明，所以它不是全局对象的属性，返回undefined。</p>\n<h2 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h2><p><a href=\"http://es6.ruanyifeng.com/#docs/let\" target=\"_blank\" rel=\"noopener\">《ES6 标准入门》</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjlov63vv0000w9ua9bn6sufv","category_id":"cjlov63w10002w9uayme91qxs","_id":"cjlov63wb000dw9uafg83w9nn"},{"post_id":"cjlov63vy0001w9uaa077z5h0","category_id":"cjlov63w10002w9uayme91qxs","_id":"cjlov63we000hw9ua8s8og20t"},{"post_id":"cjlov63w30004w9ua53j4mrx6","category_id":"cjlov63wb000cw9uant87dnkv","_id":"cjlov63wh000mw9uadaagm774"},{"post_id":"cjlov63w40005w9uap8t6uzdo","category_id":"cjlov63wf000iw9uamklsxdpt","_id":"cjlov63wj000tw9uad7d9y11r"},{"post_id":"cjlov63w50006w9ua90kxq7jh","category_id":"cjlov63wf000iw9uamklsxdpt","_id":"cjlov63wl000zw9uag7l27u3a"},{"post_id":"cjlov63wk000vw9ua70js2qf7","category_id":"cjlov63wf000iw9uamklsxdpt","_id":"cjlov63wq0014w9uaw768vegv"},{"post_id":"cjlov63w8000aw9uar0jr03is","category_id":"cjlov63wj000sw9uanqdqej9m","_id":"cjlov63wr0018w9ua9bb5btnw"},{"post_id":"cjlov63wl000yw9uauep5u2fq","category_id":"cjlov63wf000iw9uamklsxdpt","_id":"cjlov63wt001cw9ua2co83n1b"},{"post_id":"cjlov63wm0011w9uahlmvchap","category_id":"cjlov63wf000iw9uamklsxdpt","_id":"cjlov63wt001fw9uagj4ry1dx"},{"post_id":"cjlov63wa000bw9ualdn4qcfb","category_id":"cjlov63wj000sw9uanqdqej9m","_id":"cjlov63wu001iw9uafhaghvf6"},{"post_id":"cjlov63wn0013w9ua1xo2a7i1","category_id":"cjlov63wf000iw9uamklsxdpt","_id":"cjlov63wv001lw9uay876tweo"},{"post_id":"cjlov63wr0017w9ua65qh5tqy","category_id":"cjlov63wf000iw9uamklsxdpt","_id":"cjlov63wv001mw9ua8rqe1gog"},{"post_id":"cjlov63wc000fw9uatdrq7gu6","category_id":"cjlov63wj000sw9uanqdqej9m","_id":"cjlov63ww001qw9uahvbdsums"},{"post_id":"cjlov63ws001bw9uavz6eh3i4","category_id":"cjlov63w10002w9uayme91qxs","_id":"cjlov63ww001rw9uacpevtftb"},{"post_id":"cjlov63wd000gw9ua50bciijn","category_id":"cjlov63wj000sw9uanqdqej9m","_id":"cjlov63wx001uw9ua5dg6785j"},{"post_id":"cjlov63wf000kw9uaccjixup3","category_id":"cjlov63wj000sw9uanqdqej9m","_id":"cjlov63wx001vw9uaf2ejkmpv"},{"post_id":"cjlov63wg000lw9uayfd675k8","category_id":"cjlov63wj000sw9uanqdqej9m","_id":"cjlov63wx001xw9ua7mgxlkbh"},{"post_id":"cjlov63wi000rw9uab96h6vbm","category_id":"cjlov63ww001tw9uaqua7ospq","_id":"cjlov63wy0021w9uae3elrngl"}],"PostTag":[{"post_id":"cjlov63vv0000w9ua9bn6sufv","tag_id":"cjlov63w30003w9uauwr2yfkl","_id":"cjlov63w80009w9ua46eqkx4r"},{"post_id":"cjlov63vy0001w9uaa077z5h0","tag_id":"cjlov63w60008w9uae9qwvb74","_id":"cjlov63wi000qw9uafinjyjbp"},{"post_id":"cjlov63vy0001w9uaa077z5h0","tag_id":"cjlov63wc000ew9ua3crqw32r","_id":"cjlov63wj000uw9uapezofkky"},{"post_id":"cjlov63vy0001w9uaa077z5h0","tag_id":"cjlov63wf000jw9uax209zggt","_id":"cjlov63wl000xw9uaehwd5bnf"},{"post_id":"cjlov63w30004w9ua53j4mrx6","tag_id":"cjlov63wh000ow9ua11sb5pqn","_id":"cjlov63wq0015w9uaf88ux3gm"},{"post_id":"cjlov63w30004w9ua53j4mrx6","tag_id":"cjlov63wk000ww9uasf5xhb5y","_id":"cjlov63ws0019w9uaw8yvoyv1"},{"post_id":"cjlov63w40005w9uap8t6uzdo","tag_id":"cjlov63wn0012w9ua8n8oncju","_id":"cjlov63wt001dw9uac91w7vil"},{"post_id":"cjlov63wr0017w9ua65qh5tqy","tag_id":"cjlov63wn0012w9ua8n8oncju","_id":"cjlov63wu001gw9uadglmsm70"},{"post_id":"cjlov63w50006w9ua90kxq7jh","tag_id":"cjlov63ws001aw9ua5y624z5t","_id":"cjlov63wu001jw9uay6xeuafd"},{"post_id":"cjlov63w8000aw9uar0jr03is","tag_id":"cjlov63wu001hw9uar80rdtsy","_id":"cjlov63ww001pw9uanxe465s8"},{"post_id":"cjlov63wa000bw9ualdn4qcfb","tag_id":"cjlov63wv001nw9uaotxgwoit","_id":"cjlov63wx001yw9uaiva9xwet"},{"post_id":"cjlov63wa000bw9ualdn4qcfb","tag_id":"cjlov63ww001sw9uaq32deg8r","_id":"cjlov63wx001zw9uamel4ipjt"},{"post_id":"cjlov63wc000fw9uatdrq7gu6","tag_id":"cjlov63wx001ww9uayuz4d6d1","_id":"cjlov63wz0024w9uankneekfu"},{"post_id":"cjlov63wc000fw9uatdrq7gu6","tag_id":"cjlov63wy0020w9ual71t0fof","_id":"cjlov63wz0025w9uarg532pjr"},{"post_id":"cjlov63wc000fw9uatdrq7gu6","tag_id":"cjlov63wy0022w9uaoz00rf3o","_id":"cjlov63wz0027w9uaq07zv4s6"},{"post_id":"cjlov63wd000gw9ua50bciijn","tag_id":"cjlov63wy0023w9ua0lastk2g","_id":"cjlov63wz0028w9uanvchod5r"},{"post_id":"cjlov63wf000kw9uaccjixup3","tag_id":"cjlov63wz0026w9ua5cfr9gn1","_id":"cjlov63x0002aw9uaz00nslov"},{"post_id":"cjlov63wg000lw9uayfd675k8","tag_id":"cjlov63wz0029w9uakcteglpw","_id":"cjlov63x0002cw9ua3u3nhtxu"},{"post_id":"cjlov63wi000rw9uab96h6vbm","tag_id":"cjlov63x0002bw9uay2ef3bhl","_id":"cjlov63x2002gw9uafhglipse"},{"post_id":"cjlov63wi000rw9uab96h6vbm","tag_id":"cjlov63x1002dw9uax4k3pzob","_id":"cjlov63x2002hw9ua5ed37pau"},{"post_id":"cjlov63wi000rw9uab96h6vbm","tag_id":"cjlov63x1002ew9uai40babb1","_id":"cjlov63x2002jw9uaitxtw0q1"},{"post_id":"cjlov63wk000vw9ua70js2qf7","tag_id":"cjlov63wn0012w9ua8n8oncju","_id":"cjlov63x3002kw9uagmewdhvs"},{"post_id":"cjlov63wl000yw9uauep5u2fq","tag_id":"cjlov63wn0012w9ua8n8oncju","_id":"cjlov63x3002mw9uarrguicij"},{"post_id":"cjlov63wm0011w9uahlmvchap","tag_id":"cjlov63x3002lw9uap87z972f","_id":"cjlov63x4002ow9ua721aanpv"},{"post_id":"cjlov63wn0013w9ua1xo2a7i1","tag_id":"cjlov63x3002nw9uaaeo7xj3y","_id":"cjlov63x5002rw9ua0k93fcjz"},{"post_id":"cjlov63wn0013w9ua1xo2a7i1","tag_id":"cjlov63x4002pw9uav751vqwo","_id":"cjlov63x5002sw9uapgeq43g5"},{"post_id":"cjlov63ws001bw9uavz6eh3i4","tag_id":"cjlov63x5002qw9uajdxhrny8","_id":"cjlov63x6002vw9uai1p0bs3q"},{"post_id":"cjlov63ws001bw9uavz6eh3i4","tag_id":"cjlov63x5002tw9uavtbj2ovf","_id":"cjlov63x7002ww9uakpbseogd"},{"post_id":"cjlov63ws001bw9uavz6eh3i4","tag_id":"cjlov63x6002uw9ua62gopplj","_id":"cjlov63x7002xw9uaf2rq7pqh"}],"Tag":[{"name":"Promise","_id":"cjlov63w30003w9uauwr2yfkl"},{"name":"Class","_id":"cjlov63w60008w9uae9qwvb74"},{"name":"extends","_id":"cjlov63wc000ew9ua3crqw32r"},{"name":"super","_id":"cjlov63wf000jw9uax209zggt"},{"name":"状态码","_id":"cjlov63wh000ow9ua11sb5pqn"},{"name":"喵星人","_id":"cjlov63wk000ww9uasf5xhb5y"},{"name":"blog","_id":"cjlov63wn0012w9ua8n8oncju"},{"name":"-idea -红宝书","_id":"cjlov63ws001aw9ua5y624z5t"},{"name":"作用域","_id":"cjlov63wu001hw9uar80rdtsy"},{"name":"instanceof","_id":"cjlov63wv001nw9uaotxgwoit"},{"name":"isArray","_id":"cjlov63ww001sw9uaq32deg8r"},{"name":"易错","_id":"cjlov63wx001ww9uayuz4d6d1"},{"name":"变态","_id":"cjlov63wy0020w9ual71t0fof"},{"name":"44道题","_id":"cjlov63wy0022w9uaoz00rf3o"},{"name":"this","_id":"cjlov63wy0023w9ua0lastk2g"},{"name":"正则表达式","_id":"cjlov63wz0026w9ua5cfr9gn1"},{"name":"闭包","_id":"cjlov63wz0029w9uakcteglpw"},{"name":"翻墙","_id":"cjlov63x0002bw9uay2ef3bhl"},{"name":"XX-Net","_id":"cjlov63x1002dw9uax4k3pzob"},{"name":"ShadowSocks","_id":"cjlov63x1002ew9uai40babb1"},{"name":"学习","_id":"cjlov63x3002lw9uap87z972f"},{"name":"校招","_id":"cjlov63x3002nw9uaaeo7xj3y"},{"name":"梦想","_id":"cjlov63x4002pw9uav751vqwo"},{"name":"let","_id":"cjlov63x5002qw9uajdxhrny8"},{"name":"const","_id":"cjlov63x5002tw9uavtbj2ovf"},{"name":"块级作用域","_id":"cjlov63x6002uw9ua62gopplj"}]}}